{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/filters.ts","webpack:///./src/mixins/navigation-mixin.ts","webpack:///./src/components/NoTokens.vue?3cf4","webpack:///./src/components/HeaderIdenticon.vue?4d2f","webpack:///./src/components/HeaderIdenticon.vue","webpack:///./src/components/HeaderIdenticon.vue?cf9b","webpack:///./src/components/HeaderIdenticon.vue?6aa2","webpack:///./src/components/ConnectDialog.vue?70a0","webpack:///./src/locales sync [A-Za-z0-9-_,\\s]+\\.json$/","webpack:///./src/views/Home.vue?7f12","webpack:///./src/components/RaidenDialog.vue?6706","webpack:///./src/components/AppHeader.vue?a29b","webpack:///./src/App.vue?d8d7","webpack:///./src/assets/back_arrow.svg","webpack:///./src/components/ActionButton.vue?3493","webpack:///./src/components/ActionButton.vue","webpack:///./src/components/ActionButton.vue?a1dd","webpack:///./src/components/ActionButton.vue?9dc2","webpack:///./src/components/NoAccessMessage.vue?9636","webpack:///./src/mixins/blockie-mixin.ts","webpack:///./src/router/route-names.ts","webpack:///./src/model/types.ts","webpack:///./src/utils/logstore.ts","webpack:///./src/components/BlurredOverlay.vue?5fd0","webpack:///./src/components/BlurredOverlay.vue","webpack:///./src/components/BlurredOverlay.vue?36f7","webpack:///./src/components/BlurredOverlay.vue?f341","webpack:///./src/components/AddressDisplay.vue?08bb","webpack:///./src/components/AddressDisplay.vue","webpack:///./src/components/AddressDisplay.vue?b65d","webpack:///./src/components/AddressDisplay.vue?5467","webpack:///./src/assets/logo.svg","webpack:///./src/components/AddressDisplay.vue?6405","webpack:///./src/utils/balance-utils.ts","webpack:///./src/components/RaidenDialog.vue?044a","webpack:///./src/components/RaidenDialog.vue","webpack:///./src/components/RaidenDialog.vue?42d6","webpack:///./src/components/RaidenDialog.vue?3f05","webpack:///./src/views/Home.vue?83f3","webpack:///./src/components/ConnectDialog.vue?4556","webpack:///./src/components/NoAccessMessage.vue?a1a2","webpack:///./src/components/NoAccessMessage.vue","webpack:///./src/components/NoAccessMessage.vue?d29a","webpack:///./src/components/NoAccessMessage.vue?48a5","webpack:///./src/components/ConnectDialog.vue","webpack:///./src/components/ConnectDialog.vue?2959","webpack:///./src/components/ConnectDialog.vue?5db7","webpack:///./src/components/NoTokens.vue?c02e","webpack:///./src/components/NoTokens.vue","webpack:///./src/components/NoTokens.vue?99be","webpack:///./src/components/NoTokens.vue?d754","webpack:///./src/views/Home.vue","webpack:///./src/views/Home.vue?2eb0","webpack:///./src/views/Home.vue?c61b","webpack:///./src/components/HeaderIdenticon.vue?80f2","webpack:///./src/components/ActionButton.vue?a0bf","webpack:///./src/components/BlurredOverlay.vue?fc40","webpack:///./src/App.vue?0cac","webpack:///./src/components/AppHeader.vue?37d3","webpack:///./src/components/AppHeader.vue","webpack:///./src/components/AppHeader.vue?99d0","webpack:///./src/components/AppHeader.vue?deb5","webpack:///./src/components/OfflineSnackbar.vue?49cf","webpack:///./src/components/OfflineSnackbar.vue","webpack:///./src/components/OfflineSnackbar.vue?2992","webpack:///./src/components/OfflineSnackbar.vue?6e6b","webpack:///./src/components/UpdateSnackbar.vue?a5d3","webpack:///./src/components/UpdateSnackbar.vue","webpack:///./src/components/UpdateSnackbar.vue?b435","webpack:///./src/components/UpdateSnackbar.vue?b2a8","webpack:///./src/App.vue","webpack:///./src/App.vue?7b22","webpack:///./src/App.vue?86d0","webpack:///./src/plugins/class-component.hooks.ts","webpack:///./src/router/index.ts","webpack:///./src/store/index.ts","webpack:///./src/class-component-hooks.ts","webpack:///./src/services/config-provider.ts","webpack:///./src/services/raiden-service.ts","webpack:///./src/plugins/raiden.ts","webpack:///./src/services/identicon-cache.ts","webpack:///./src/plugins/identicon-plugin.ts","webpack:///./src/i18n.ts","webpack:///./src/plugins/vuetify.ts","webpack:///./src/registerServiceWorker.ts","webpack:///./src/main.ts","webpack:///./src/services/web3-provider.ts","webpack:///../src/polyfills.ts","webpack:///../raiden-ts/dist/contracts/TokenNetworkRegistryFactory.ts","webpack:///../raiden-ts/dist/contracts/TokenNetworkFactory.ts","webpack:///../raiden-ts/dist/contracts/HumanStandardTokenFactory.ts","webpack:///../raiden-ts/dist/contracts/ServiceRegistryFactory.ts","webpack:///../raiden-ts/dist/contracts/CustomTokenFactory.ts","webpack:///../raiden-ts/dist/contracts/UserDepositFactory.ts","webpack:///../raiden-ts/dist/contracts/SecretRegistryFactory.ts","webpack:///../src/types.ts","webpack:///../src/constants.ts","webpack:///../../src/utils/types.ts","webpack:///../../src/utils/ethers.ts","webpack:///../src/config.ts","webpack:///../../src/utils/error.ts","webpack:///../../src/utils/actions.ts","webpack:///../../src/channels/types.ts","webpack:///../../src/messages/types.ts","webpack:///../../src/channels/actions.ts","webpack:///../../src/transport/state.ts","webpack:///../../src/transport/actions.ts","webpack:///../../src/messages/actions.ts","webpack:///../../src/services/types.ts","webpack:///../../src/transfers/actions.ts","webpack:///../../src/services/actions.ts","webpack:///../src/actions.ts","webpack:///../../src/migration/0.ts","webpack:///../../src/migration/1.ts","webpack:///../../src/migration/2.ts","webpack:///../../src/migration/index.ts","webpack:///../../src/utils/data.ts","webpack:///../../src/channels/state.ts","webpack:///../../src/transfers/state.ts","webpack:///../src/state.ts","webpack:///../../src/utils/redux.ts","webpack:///../../src/channels/reducer.ts","webpack:///../../src/transport/reducer.ts","webpack:///../../src/messages/utils.ts","webpack:///../../src/transfers/utils.ts","webpack:///../../src/transfers/reducer.ts","webpack:///../../src/services/reducer.ts","webpack:///../src/reducer.ts","webpack:///../../src/utils/rx.ts","webpack:///../../src/transport/utils.ts","webpack:///../../src/channels/utils.ts","webpack:///../src/helpers.ts","webpack:///../../src/channels/epics.ts","webpack:///../../src/utils/matrix.ts","webpack:///../../src/utils/lru.ts","webpack:///../../src/transport/epics.ts","webpack:///../../../src/transfers/epics/close.ts","webpack:///../../../src/transfers/epics/utils.ts","webpack:///../../../src/transfers/epics/expire.ts","webpack:///../../../src/transfers/epics/locked.ts","webpack:///../../../src/transfers/epics/init.ts","webpack:///../../../src/transfers/epics/mediate.ts","webpack:///../../../src/transfers/epics/processed.ts","webpack:///../../../src/transfers/epics/refund.ts","webpack:///../../../src/transfers/epics/retry.ts","webpack:///../../../src/transfers/epics/secret.ts","webpack:///../../../src/transfers/epics/withdraw.ts","webpack:///../../src/services/utils.ts","webpack:///../../src/services/epics.ts","webpack:///../src/epics.ts","webpack:///../src/raiden.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","installedCssChunks","jsonpScriptSrc","p","exports","module","l","e","promises","cssChunks","Promise","resolve","reject","href","fullhref","existingLinkTags","document","getElementsByTagName","tag","dataHref","getAttribute","rel","existingStyleTags","linkTag","createElement","type","onload","onerror","event","request","target","src","err","Error","code","parentNode","removeChild","head","appendChild","then","installedChunkData","promise","onScriptComplete","script","charset","timeout","nc","setAttribute","error","clearTimeout","chunk","errorType","realSrc","message","name","undefined","setTimeout","all","m","c","d","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","oe","console","jsonpArray","window","oldJsonpFunction","slice","Filters","width","separator","substWidth","Math","floor","substr","parseFloat","toFixed","toLocaleUpperCase","amount","decimals","units","toUnits","deposit","integerPart","decimalPart","newDecimal","substring","wei","filter","truncate","upper","displayFormat","capitalizeFirst","NavigationMixin","token","this","$router","SELECT_HUB","params","HOME","catch","partner","OPEN_CHANNEL","CHANNELS","route","TRANSFER","query","SELECT_TOKEN","TRANSFER_STEPS","GENERAL_HOME","BACKUP_STATE","RAIDEN_ACCOUNT","go","$route","navigateToSelectTransferTarget","navigateToHome","navigateToTokenSelect","navigateToSelectHub","render","_vm","_h","$createElement","_c","_self","staticClass","attrs","scopedSlots","_u","fn","ref","on","pendingTransferAmount","_g","$blockie","defaultAccount","_v","_s","$tc","class","staticRenderFns","HeaderIdenticon","keys","pendingTransfers","computed","component","VBadge","VImg","VTooltip","map","webpackContext","req","id","webpackContextResolve","sticky","ghost","fullWidth","enabled","loading","$event","click","text","_e","ActionButton","required","Boolean","default","VBtn","VCol","VIcon","VRow","BlockieMixin","address","$identicon","getIdenticon","RouteNames","DeniedReason","emptyDescription","label","title","description","emptyTokenModel","symbol","opening","open","closing","closed","settling","settled","PlaceHolderNetwork","chainId","db","collectionName","serializeError","strError","toString","stack","startsWith","filterMessage","payload","serialize","JSON","stringify","setupLogStore","a","dbName","additionalLoggers","upgrade","logsStore","createObjectStore","createIndex","log","origFactory","methodFactory","methodName","level","loggerName","rawMethod","filtered","put","logger","Date","now","getLogger","getLogsFromStore","content","transaction","store","openCursor","cursor","lastTime","line","join","time","toISOString","continue","fullscreen","_t","BlurredOverlay","copy","addressOutput","domProps","copied","$t","input","focus","select","blur","stopPropagation","selectAddress","$refs","execCommand","deselectAddress","fullAddress","BalanceUtils","depositTokens","indexOf","split","visible","hideClose","close","RaidenDialog","components","VCard","VDialog","inaccessible","isConnected","connectDialog","connecting","connectingSubkey","connect","stateBackup","accessDenied","injectedProvider","reason","UNSUPPORTED_NETWORK","INITIALIZATION_FAILED","RDN_STATE_MIGRATION","VAlert","uploadedState","subkey","injectedWeb3Available","NoAccessMessage","VCardText","VCardTitle","VProgressCircular","tokens","NoTokens","immediate","VContainer","connectOptions","$store","commit","$raiden","UNDEFINED","ConnectDialog","onBackClicked","meta","network","nativeOn","navigateToGeneralHome","routesWithoutBackBtn","includes","AddressDisplay","VSpacer","offline","model","callback","$$v","expression","OfflineSnackbar","navigator","onLine","addEventListener","handleOffline","handleOnline","removeEventListener","VSnackbar","updateAvailable","isUpdating","update","UpdateSnackbar","swRegistration","handleSWUpdate","once","serviceWorker","location","reload","detail","waiting","postMessage","App","disconnect","AppHeader","VApp","VContent","registerHooks","use","router","base","routes","path","Home","redirect","GENERAL","beforeEnter","to","from","next","matched","modal","children","_defaultState","accountBalance","raidenAccountBalance","providerDetected","channels","transfers","presences","defaultState","state","mutations","noProvider","account","loadComplete","balance","updateChannels","updateTokens","entries","updatePresence","presence","reset","assign","updateTransfers","transfer","secrethash","backupState","actions","getters","reducer","acc","channel","tokenChannels","tokenInfo","allTokens","values","tokenAddress","channelWithBiggestCapacity","_","openChannels","secretHash","completed","reduce","paymentId","find","Store","url","fetch","json","_userDepositTokenAddress","_raiden","getBalance","raiden","getTokenList","toFetch","placeholders","fetchTokenData","resolveName","EnsResolveFailed","raidenPackageConfigUrl","VUE_APP_RAIDEN_PACKAGE","config","provider","RaidenService","createRaiden","PRIVATE_KEY","getAccount","userDepositTokenAddress","events$","pipe","exhaustMap","subscribe","available","channels$","transfers$","initiator","stop","start","deniedReason","RaidenInitializationFailed","NO_ACCOUNT","mainAddress","toEth","getTokenBalance","getTokenInfo","progress","progressUpdater","current","total","openChannel","OPENED","ChannelOpenFailed","closeChannel","ChannelCloseFailed","depositChannel","ChannelDepositFailed","settleChannel","ChannelSettleFailed","fetchToken","getToken","paths","waitTransfer","TransferFailed","raidenPFS","getAvailability","findRoutes","pfs","findPFS","directRoute","mint","depositing","depositToUDC","APPROVED","getUDCCapacity","state$","toPromise","transferOnchainBalance","updateBalances","storage","localStorage","pfsSafetyMargin","matrixServer","RaidenPlugin","Vue","_options","cache","cached","generated","IdenticonPlugin","loadLocaleMessages","locales","messages","forEach","match","locale","fallbackLocale","icons","iconfont","theme","dark","themes","primary","secondary","ready","registered","registration","setInterval","updatefound","updated","dispatchEvent","CustomEvent","productionTip","vuetify","i18n","h","$mount","Web3Provider","ethereum","INFURA_ENDPOINT","enable","web3","currentProvider","isMetaMask","autoRefreshOnNetworkChange","replace","origin","signerOrProvider","_abi","inputs","internalType","stateMutability","anonymous","indexed","outputs","ShutdownReason","Capabilities","ErrorCodes","MessageType","secret","ChannelState","contractsInfo","action","roomId","lock","LruCache"],"mappings":"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ACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,qBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,0BACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,yBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,yBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,wBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,0BACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,a,6TC5NH,IAAM,EAAb,iFAEIoK,EACAwV,GAEA,OAAO,IAAI,cAASxV,EAAS,EAAMwV,OALvC,KASM,EAAO,CACX,CACEE,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,iBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,mBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,YACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,0BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,0BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,wBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,qCACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,+BACN7B,KAAM,YAGVggB,gBAAiB,aACjBhgB,KAAM,eAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,sBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,eACN7B,KAAM,YAGV6B,KAAM,gBACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,gBACN7B,KAAM,YAGV6B,KAAM,oBACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,iBACN7B,KAAM,YAGV6B,KAAM,gBACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,sBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,yBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,sBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,yBACN7B,KAAM,YAGV6B,KAAM,iBACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,WACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,YACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,kBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,kBACN7B,KAAM,YAGV6B,KAAM,kBACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,iBACN7B,KAAM,YAGV6B,KAAM,kBACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,OACdle,KAAM,YACN7B,KAAM,SAGV6B,KAAM,oBACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,sBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,eACN7B,KAAM,YAGV6B,KAAM,gCACN7B,KAAM,SAER,CACE8f,OAAQ,GACRje,KAAM,mBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,kBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,oCACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,sBACN7B,KAAM,WAER,CACE+f,aAAc,iCACdle,KAAM,QACN7B,KAAM,UAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,0BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,sBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,kBACN7B,KAAM,WAER,CACE+f,aAAc,QACdle,KAAM,wBACN7B,KAAM,SAER,CACE+f,aAAc,QACdle,KAAM,oBACN7B,KAAM,UAGV6B,KAAM,eACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,mBACN7B,KAAM,YAGV6B,KAAM,iBACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,GACN7B,KAAM,SAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,YACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,uBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,UACN7B,KAAM,YAGV6B,KAAM,uBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,eACN7B,KAAM,YAGV6B,KAAM,iBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,WAER,CACE+f,aAAc,iCACdle,KAAM,GACN7B,KAAM,UAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,UACN7B,KAAM,YAGV6B,KAAM,4BACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,GACN7B,KAAM,WAER,CACE+f,aAAc,OACdle,KAAM,GACN7B,KAAM,QAER,CACE+f,aAAc,UACdle,KAAM,GACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,GACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,GACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,UACN7B,KAAM,YAGV6B,KAAM,sBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,WACN7B,KAAM,YAGV6B,KAAM,sBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,iBACN7B,KAAM,YAGV6B,KAAM,cACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,0CACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,4BACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,GACN7B,KAAM,SAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,kBACNse,QAAS,CACP,CACEJ,aAAc,0BACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,gBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,UACN7B,KAAM,YAGV6B,KAAM,kBACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,iBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,mBACN7B,KAAM,WAER,CACE+f,aAAc,QACdle,KAAM,wBACN7B,KAAM,SAER,CACE+f,aAAc,QACdle,KAAM,oBACN7B,KAAM,UAGV6B,KAAM,mBACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,kCACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,6BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,yBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,kCACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,6BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,yBACN7B,KAAM,YAGV6B,KAAM,gBACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,yBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,yBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,mBACNse,QAAS,CACP,CACEJ,aAAc,SACdle,KAAM,GACN7B,KAAM,WAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,QACNse,QAAS,CACP,CACEJ,aAAc,iBACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,8BACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,WACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACE+f,aAAc,QACdle,KAAM,QACN7B,KAAM,UAGV6B,KAAM,SACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,qBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,sBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,0BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,kBACN7B,KAAM,WAER,CACE+f,aAAc,QACdle,KAAM,oBACN7B,KAAM,SAER,CACE+f,aAAc,QACdle,KAAM,wBACN7B,KAAM,UAGV6B,KAAM,+BACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,a,iUC77BH,IAAM,GAAb,kFAEIoK,EACAwV,GAEA,OAAO,IAAI,cAASxV,EAAS,GAAMwV,OALvC,KASM,GAAO,CACX,CACEE,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,iBACN7B,KAAM,WAER,CACE+f,aAAc,QACdle,KAAM,gBACN7B,KAAM,SAER,CACE+f,aAAc,SACdle,KAAM,aACN7B,KAAM,UAER,CACE+f,aAAc,SACdle,KAAM,eACN7B,KAAM,WAGVggB,gBAAiB,aACjBhgB,KAAM,eAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,WACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,WACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,MACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,WACN7B,KAAM,SAER,CACEggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,YACNse,QAAS,CACP,CACEJ,aAAc,QACdle,KAAM,GACN7B,KAAM,UAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,WACN7B,KAAM,YAGV6B,KAAM,YACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,YACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,WACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,UACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,UACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,WACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACE+f,aAAc,QACdle,KAAM,aACN7B,KAAM,UAGV6B,KAAM,iBACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,UACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,YACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,UACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,QACdle,KAAM,WACN7B,KAAM,UAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,OACNse,QAAS,CACP,CACEJ,aAAc,SACdle,KAAM,GACN7B,KAAM,WAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,SACNse,QAAS,CACP,CACEJ,aAAc,SACdle,KAAM,GACN7B,KAAM,WAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,cACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,MACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,UACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,MACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,eACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,UACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,UACNse,QAAS,CACP,CACEJ,aAAc,SACdle,KAAM,GACN7B,KAAM,WAGVggB,gBAAiB,OACjBhgB,KAAM,a,kUC9UH,IAAM,GAAb,mFAEIoK,EACAwV,GAEA,OAAO,IAAI,cAASxV,EAAS,GAAMwV,OALvC,KASM,GAAO,CACX,CACEE,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,0BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,iBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,wBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,0BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,kBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,aACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,yBACN7B,KAAM,YAGVggB,gBAAiB,aACjBhgB,KAAM,eAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,UACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,aACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,iBACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,mBACdle,KAAM,mBACN7B,KAAM,YAGV6B,KAAM,oBACN7B,KAAM,SAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,wBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,0BACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,kBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,aACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,yBACN7B,KAAM,YAGV6B,KAAM,mBACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,WACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,mBACN7B,KAAM,YAGV6B,KAAM,iBACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,GACN7B,KAAM,SAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,aACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,eACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,iBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,aACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,kBACN7B,KAAM,YAGV6B,KAAM,eACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,gBACN7B,KAAM,YAGV6B,KAAM,UACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,WACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,aACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,GACN7B,KAAM,SAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,sBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,OACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,qBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,WACN7B,KAAM,YAGV6B,KAAM,uBACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,oBACN7B,KAAM,SAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,YACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,yBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,uBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,wBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,qBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,uBACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,WACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,SACdle,KAAM,UACN7B,KAAM,WAGV6B,KAAM,SACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,WACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,YACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,eACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,QACNse,QAAS,CACP,CACEJ,aAAc,iBACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,OACNse,QAAS,CACP,CACEJ,aAAc,SACdle,KAAM,GACN7B,KAAM,WAGVggB,gBAAiB,OACjBhgB,KAAM,a,kUClcH,IAAM,GAAb,mFAEIoK,EACAwV,GAEA,OAAO,IAAI,cAASxV,EAAS,GAAMwV,OALvC,KASM,GAAO,CACX,CACEE,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,iBACN7B,KAAM,WAER,CACE+f,aAAc,QACdle,KAAM,gBACN7B,KAAM,SAER,CACE+f,aAAc,SACdle,KAAM,aACN7B,KAAM,UAER,CACE+f,aAAc,SACdle,KAAM,eACN7B,KAAM,WAGVggB,gBAAiB,aACjBhgB,KAAM,eAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,WACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,WACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,MACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,OACN7B,KAAM,YAGV6B,KAAM,SACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,MACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,WACN7B,KAAM,SAER,CACE8f,OAAQ,GACRje,KAAM,YACNse,QAAS,CACP,CACEJ,aAAc,QACdle,KAAM,GACN7B,KAAM,UAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,WACN7B,KAAM,YAGV6B,KAAM,YACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,YACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,WACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,UACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,UACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,YACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,UACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,QACdle,KAAM,WACN7B,KAAM,UAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,MACN7B,KAAM,YAGV6B,KAAM,OACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,MACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,UACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,aACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,OACNse,QAAS,CACP,CACEJ,aAAc,SACdle,KAAM,GACN7B,KAAM,WAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,gBACNse,QAAS,CACP,CACEJ,aAAc,kBACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,SACNse,QAAS,CACP,CACEJ,aAAc,SACdle,KAAM,GACN7B,KAAM,WAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,cACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,MACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,UACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,MACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,eACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,UACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,gBACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,UACNse,QAAS,CACP,CACEJ,aAAc,SACdle,KAAM,GACN7B,KAAM,WAGVggB,gBAAiB,OACjBhgB,KAAM,a,kUChYH,IAAM,GAAb,mFAEIoK,EACAwV,GAEA,OAAO,IAAI,cAASxV,EAAS,GAAMwV,OALvC,KASM,GAAO,CACX,CACEE,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,iBACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,uBACN7B,KAAM,YAGVggB,gBAAiB,aACjBhgB,KAAM,eAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,QACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,aACN7B,KAAM,YAGV6B,KAAM,iBACN7B,KAAM,SAER,CACEigB,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,aACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,iBACN7B,KAAM,YAGV6B,KAAM,kBACN7B,KAAM,SAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,mBACN7B,KAAM,YAGV6B,KAAM,iBACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,GACN7B,KAAM,SAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,cACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,oBACN7B,KAAM,YAGV6B,KAAM,UACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,QACN7B,KAAM,YAGV6B,KAAM,mBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,oBACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,eACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,oBACN7B,KAAM,YAGV6B,KAAM,OACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,cACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,mBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,eACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,QACNse,QAAS,CACP,CACEJ,aAAc,iBACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,gBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,WACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,WACNse,QAAS,CACP,CACEJ,aAAc,OACdle,KAAM,UACN7B,KAAM,SAGVggB,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,gBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,sBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,WACNse,QAAS,GACTH,gBAAiB,aACjBhgB,KAAM,YAER,CACE8f,OAAQ,GACRje,KAAM,iBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGV6B,KAAM,iBACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,SACN7B,KAAM,WAER,CACE+f,aAAc,UACdle,KAAM,iBACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,a,kUC3UH,IC4DK,GD5DC,GAAb,mFAEIoK,EACAwV,GAEA,OAAO,IAAI,cAASxV,EAAS,GAAMwV,OALvC,KASM,GAAO,CACX,CACEK,WAAW,EACXH,OAAQ,CACN,CACEI,SAAS,EACTH,aAAc,UACdle,KAAM,aACN7B,KAAM,WAER,CACEkgB,SAAS,EACTH,aAAc,UACdle,KAAM,SACN7B,KAAM,YAGV6B,KAAM,iBACN7B,KAAM,SAER,CACE8f,OAAQ,CACN,CACEC,aAAc,UACdle,KAAM,aACN7B,KAAM,YAGV6B,KAAM,6BACNse,QAAS,CACP,CACEJ,aAAc,UACdle,KAAM,GACN7B,KAAM,YAGVggB,gBAAiB,OACjBhgB,KAAM,YAER,CACE8f,OAAQ,CACN,CACEC,a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","file":"js/app.8586aff7.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded CSS chunks\n \tvar installedCssChunks = {\n \t\t\"app\": 0\n \t}\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// script path function\n \tfunction jsonpScriptSrc(chunkId) {\n \t\treturn __webpack_require__.p + \"js/\" + ({}[chunkId]||chunkId) + \".\" + {\"chunk-15f0b7af\":\"e2945db7\",\"chunk-0ad86ad4\":\"65157950\",\"chunk-43b69ccc\":\"14c25553\",\"chunk-74cc7fa6\":\"a80d0629\",\"chunk-895be7da\":\"0920c1ab\",\"chunk-31a29a51\":\"741eb17b\",\"chunk-5e7189c2\":\"bf466540\",\"chunk-08d0b51d\":\"d54fb8ca\",\"chunk-54fa7be7\":\"1a291c51\",\"chunk-83f2575a\":\"0d858c9d\",\"chunk-24410f9b\":\"0625ee7c\",\"chunk-5dcb669a\":\"3d1edba2\",\"chunk-d088a722\":\"d168c676\",\"chunk-e17a21de\":\"770ec442\"}[chunkId] + \".js\"\n \t}\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// mini-css-extract-plugin CSS loading\n \t\tvar cssChunks = {\"chunk-15f0b7af\":1,\"chunk-0ad86ad4\":1,\"chunk-43b69ccc\":1,\"chunk-74cc7fa6\":1,\"chunk-895be7da\":1,\"chunk-31a29a51\":1,\"chunk-5e7189c2\":1,\"chunk-08d0b51d\":1,\"chunk-54fa7be7\":1,\"chunk-83f2575a\":1,\"chunk-24410f9b\":1,\"chunk-5dcb669a\":1,\"chunk-d088a722\":1,\"chunk-e17a21de\":1};\n \t\tif(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);\n \t\telse if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {\n \t\t\tpromises.push(installedCssChunks[chunkId] = new Promise(function(resolve, reject) {\n \t\t\t\tvar href = \"css/\" + ({}[chunkId]||chunkId) + \".\" + {\"chunk-15f0b7af\":\"1d5a726d\",\"chunk-0ad86ad4\":\"85781be9\",\"chunk-43b69ccc\":\"c60dbc20\",\"chunk-74cc7fa6\":\"385bbc7a\",\"chunk-895be7da\":\"b86104e5\",\"chunk-31a29a51\":\"39ba85ce\",\"chunk-5e7189c2\":\"295d09cf\",\"chunk-08d0b51d\":\"5b30d335\",\"chunk-54fa7be7\":\"6eaf9e5f\",\"chunk-83f2575a\":\"015f581c\",\"chunk-24410f9b\":\"5c951042\",\"chunk-5dcb669a\":\"0727a159\",\"chunk-d088a722\":\"d70ab06c\",\"chunk-e17a21de\":\"1740c2a4\"}[chunkId] + \".css\";\n \t\t\t\tvar fullhref = __webpack_require__.p + href;\n \t\t\t\tvar existingLinkTags = document.getElementsByTagName(\"link\");\n \t\t\t\tfor(var i = 0; i < existingLinkTags.length; i++) {\n \t\t\t\t\tvar tag = existingLinkTags[i];\n \t\t\t\t\tvar dataHref = tag.getAttribute(\"data-href\") || tag.getAttribute(\"href\");\n \t\t\t\t\tif(tag.rel === \"stylesheet\" && (dataHref === href || dataHref === fullhref)) return resolve();\n \t\t\t\t}\n \t\t\t\tvar existingStyleTags = document.getElementsByTagName(\"style\");\n \t\t\t\tfor(var i = 0; i < existingStyleTags.length; i++) {\n \t\t\t\t\tvar tag = existingStyleTags[i];\n \t\t\t\t\tvar dataHref = tag.getAttribute(\"data-href\");\n \t\t\t\t\tif(dataHref === href || dataHref === fullhref) return resolve();\n \t\t\t\t}\n \t\t\t\tvar linkTag = document.createElement(\"link\");\n \t\t\t\tlinkTag.rel = \"stylesheet\";\n \t\t\t\tlinkTag.type = \"text/css\";\n \t\t\t\tlinkTag.onload = resolve;\n \t\t\t\tlinkTag.onerror = function(event) {\n \t\t\t\t\tvar request = event && event.target && event.target.src || fullhref;\n \t\t\t\t\tvar err = new Error(\"Loading CSS chunk \" + chunkId + \" failed.\\n(\" + request + \")\");\n \t\t\t\t\terr.code = \"CSS_CHUNK_LOAD_FAILED\";\n \t\t\t\t\terr.request = request;\n \t\t\t\t\tdelete installedCssChunks[chunkId]\n \t\t\t\t\tlinkTag.parentNode.removeChild(linkTag)\n \t\t\t\t\treject(err);\n \t\t\t\t};\n \t\t\t\tlinkTag.href = fullhref;\n\n \t\t\t\tvar head = document.getElementsByTagName(\"head\")[0];\n \t\t\t\thead.appendChild(linkTag);\n \t\t\t}).then(function() {\n \t\t\t\tinstalledCssChunks[chunkId] = 0;\n \t\t\t}));\n \t\t}\n\n \t\t// JSONP chunk loading for javascript\n\n \t\tvar installedChunkData = installedChunks[chunkId];\n \t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n \t\t\t// a Promise means \"currently loading\".\n \t\t\tif(installedChunkData) {\n \t\t\t\tpromises.push(installedChunkData[2]);\n \t\t\t} else {\n \t\t\t\t// setup Promise in chunk cache\n \t\t\t\tvar promise = new Promise(function(resolve, reject) {\n \t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n \t\t\t\t});\n \t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n \t\t\t\t// start chunk loading\n \t\t\t\tvar script = document.createElement('script');\n \t\t\t\tvar onScriptComplete;\n\n \t\t\t\tscript.charset = 'utf-8';\n \t\t\t\tscript.timeout = 120;\n \t\t\t\tif (__webpack_require__.nc) {\n \t\t\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n \t\t\t\t}\n \t\t\t\tscript.src = jsonpScriptSrc(chunkId);\n\n \t\t\t\t// create error before stack unwound to get useful stacktrace later\n \t\t\t\tvar error = new Error();\n \t\t\t\tonScriptComplete = function (event) {\n \t\t\t\t\t// avoid mem leaks in IE.\n \t\t\t\t\tscript.onerror = script.onload = null;\n \t\t\t\t\tclearTimeout(timeout);\n \t\t\t\t\tvar chunk = installedChunks[chunkId];\n \t\t\t\t\tif(chunk !== 0) {\n \t\t\t\t\t\tif(chunk) {\n \t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n \t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n \t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n \t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n \t\t\t\t\t\t\terror.type = errorType;\n \t\t\t\t\t\t\terror.request = realSrc;\n \t\t\t\t\t\t\tchunk[1](error);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tinstalledChunks[chunkId] = undefined;\n \t\t\t\t\t}\n \t\t\t\t};\n \t\t\t\tvar timeout = setTimeout(function(){\n \t\t\t\t\tonScriptComplete({ type: 'timeout', target: script });\n \t\t\t\t}, 120000);\n \t\t\t\tscript.onerror = script.onload = onScriptComplete;\n \t\t\t\tdocument.head.appendChild(script);\n \t\t\t}\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/staging/\";\n\n \t// on error function for async loading\n \t__webpack_require__.oe = function(err) { console.error(err); throw err; };\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import Vue from 'vue';\nimport { BigNumber } from 'ethers/utils';\nimport { BalanceUtils } from '@/utils/balance-utils';\nimport split from 'lodash/split';\nimport capitalize from 'lodash/capitalize';\n\nexport default class Filters {\n  static truncate(value: string, width: number = 12) {\n    const separator = '...';\n    if (value.length <= width) {\n      return value;\n    } else {\n      const substWidth = Math.floor(width / 2);\n      return (\n        value.substr(0, substWidth) +\n        separator +\n        value.substr(value.length - substWidth)\n      );\n    }\n  }\n\n  static decimals(value: string, decimals: number = 3) {\n    return parseFloat(value).toFixed(decimals);\n  }\n\n  static upper(value?: string) {\n    if (!value) {\n      return '';\n    }\n    return value.toLocaleUpperCase();\n  }\n\n  static displayFormat(amount: BigNumber, decimals?: number): string {\n    const units = BalanceUtils.toUnits(amount, decimals || 18);\n    const deposit = parseFloat(units);\n    if (deposit === 0) {\n      return '0.0';\n    } else if (deposit < 0.000001) {\n      return '<0.000001';\n    } else {\n      const [integerPart, decimalPart] = split(units, '.');\n\n      if (decimalPart && decimalPart.length > 6) {\n        let newDecimal = decimalPart.substring(0, 6);\n        return `${integerPart}.${newDecimal}`;\n      } else {\n        return units;\n      }\n    }\n  }\n\n  static capitalizeFirst(value: string): string {\n    return capitalize(value);\n  }\n\n  static toUnits = (wei: BigNumber, decimals?: number) =>\n    BalanceUtils.toUnits(wei, decimals || 18);\n}\n\nVue.filter('truncate', Filters.truncate);\nVue.filter('decimals', Filters.decimals);\nVue.filter('upper', Filters.upper);\nVue.filter('displayFormat', Filters.displayFormat);\nVue.filter('capitalizeFirst', Filters.capitalizeFirst);\nVue.filter('toUnits', Filters.toUnits);\n","import { Component, Vue } from 'vue-property-decorator';\nimport { RouteNames } from '@/router/route-names';\n\n@Component\nexport default class NavigationMixin extends Vue {\n  navigateToSelectHub(token: string) {\n    this.$router.push({\n      name: RouteNames.SELECT_HUB,\n      params: {\n        token: token\n      }\n    });\n  }\n\n  navigateToHome() {\n    this.$router\n      .push({\n        name: RouteNames.HOME\n      })\n      .catch(() => {});\n  }\n\n  navigateToOpenChannel(token: string, partner: string) {\n    this.$router.push({\n      name: RouteNames.OPEN_CHANNEL,\n      params: {\n        token: token,\n        partner: partner\n      }\n    });\n  }\n\n  navigateToChannels(token: string) {\n    this.$router.push({\n      name: RouteNames.CHANNELS,\n      params: {\n        token: token\n      }\n    });\n  }\n\n  navigateToSelectTransferTarget(\n    token: string,\n    target?: string,\n    amount?: string\n  ) {\n    const route = {\n      name: RouteNames.TRANSFER,\n      params: { token: token },\n      query: {}\n    };\n    if (target && amount) {\n      route.query = { target, amount };\n    }\n    this.$router.push(route);\n  }\n\n  navigateToTokenSelect() {\n    this.$router.push({\n      name: RouteNames.SELECT_TOKEN\n    });\n  }\n\n  navigateToTransferSteps(target: string, amount: string) {\n    this.$router.push({\n      name: RouteNames.TRANSFER_STEPS,\n      params: { target },\n      query: { amount }\n    });\n  }\n\n  navigateToGeneralHome() {\n    this.$router.push({\n      name: RouteNames.GENERAL_HOME\n    });\n  }\n\n  navigateToBackupState() {\n    this.$router.push({\n      name: RouteNames.BACKUP_STATE\n    });\n  }\n\n  navigateToRaidenAccountTransfer() {\n    this.$router.push({\n      name: RouteNames.RAIDEN_ACCOUNT\n    });\n  }\n\n  onGeneralBackClicked() {\n    this.$router.go(-1);\n  }\n\n  onBackClicked() {\n    switch (this.$route.name) {\n      case RouteNames.TRANSFER_STEPS:\n        this.navigateToSelectTransferTarget(\n          this.$route.params.token,\n          this.$route.params.target,\n          this.$route.params.amount\n        );\n        break;\n      case RouteNames.TRANSFER:\n      case RouteNames.CHANNELS:\n      case RouteNames.SELECT_TOKEN:\n        this.navigateToHome();\n        break;\n      case RouteNames.SELECT_HUB:\n        this.navigateToTokenSelect();\n        break;\n      case RouteNames.OPEN_CHANNEL:\n        this.navigateToSelectHub(this.$route.params.token);\n        break;\n    }\n  }\n}\n","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NoTokens.vue?vue&type=style&index=0&id=4f16408a&lang=scss&scoped=true&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NoTokens.vue?vue&type=style&index=0&id=4f16408a&lang=scss&scoped=true&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"header-identicon\"},[(_vm.pendingTransferAmount)?_c('v-tooltip',{attrs:{\"bottom\":\"\"},scopedSlots:_vm._u([{key:\"activator\",fn:function(ref){\nvar on = ref.on;\nreturn [_c('v-badge',{attrs:{\"color\":\"primary\",\"bordered\":\"\",\"content\":_vm.pendingTransferAmount,\"overlap\":\"\"}},[_c('v-img',_vm._g({staticClass:\"header-identicon__blockie\",attrs:{\"src\":_vm.$blockie(_vm.defaultAccount),\"contain\":\"\",\"aspect-ratio\":\"1\"}},on))],1)]}}],null,false,1705622633)},[_c('span',[_vm._v(\" \"+_vm._s(_vm.$tc('app-header.pending-transfers', _vm.pendingTransferAmount, { amount: _vm.pendingTransferAmount }))+\" \")])]):_c('v-img',{class:{\n      'header-identicon__blockie': _vm.defaultAccount,\n      'header-identicon__blockie header-identicon__blockie__grayscale': !_vm.defaultAccount\n    },attrs:{\"src\":_vm.$blockie(_vm.defaultAccount),\"contain\":\"\",\"aspect-ratio\":\"1\"}})],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Mixins } from 'vue-property-decorator';\nimport { mapGetters, mapState } from 'vuex';\nimport BlockieMixin from '@/mixins/blockie-mixin';\nimport { Transfers } from '@/types';\n\n@Component({\n  computed: {\n    ...mapState(['defaultAccount']),\n    ...mapGetters(['pendingTransfers'])\n  }\n})\nexport default class HeaderIdenticon extends Mixins(BlockieMixin) {\n  defaultAccount!: string;\n  pendingTransfers!: Transfers;\n\n  get pendingTransferAmount(): number {\n    return Object.keys(this.pendingTransfers).length;\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./HeaderIdenticon.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./HeaderIdenticon.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./HeaderIdenticon.vue?vue&type=template&id=b740b99e&scoped=true&\"\nimport script from \"./HeaderIdenticon.vue?vue&type=script&lang=ts&\"\nexport * from \"./HeaderIdenticon.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./HeaderIdenticon.vue?vue&type=style&index=0&id=b740b99e&scoped=true&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"b740b99e\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBadge } from 'vuetify/lib/components/VBadge';\nimport { VImg } from 'vuetify/lib/components/VImg';\nimport { VTooltip } from 'vuetify/lib/components/VTooltip';\ninstallComponents(component, {VBadge,VImg,VTooltip})\n","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConnectDialog.vue?vue&type=style&index=0&id=3604c23c&lang=scss&scoped=true&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConnectDialog.vue?vue&type=style&index=0&id=3604c23c&lang=scss&scoped=true&\"","var map = {\n\t\"./en.json\": \"edd4\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"49f8\";","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Home.vue?vue&type=style&index=0&id=02ef831a&lang=scss&scoped=true&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Home.vue?vue&type=style&index=0&id=02ef831a&lang=scss&scoped=true&\"","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./RaidenDialog.vue?vue&type=style&index=0&id=23c69e33&scoped=true&lang=scss&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./RaidenDialog.vue?vue&type=style&index=0&id=23c69e33&scoped=true&lang=scss&\"","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AppHeader.vue?vue&type=style&index=0&id=4b1e8dd8&lang=scss&scoped=true&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AppHeader.vue?vue&type=style&index=0&id=4b1e8dd8&lang=scss&scoped=true&\"","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&id=3bcb8e58&lang=scss&scoped=true&\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&id=3bcb8e58&lang=scss&scoped=true&\"","module.exports = __webpack_public_path__ + \"img/back_arrow.268247fb.svg\";","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-row',{staticClass:\"action-button\",class:{ sticky: _vm.sticky },attrs:{\"no-gutters\":\"\",\"align-content\":\"center\",\"justify\":\"center\"}},[_c('v-col',{staticClass:\"text-center\",attrs:{\"cols\":_vm.sticky ? 12 : 10}},[_c('v-btn',{staticClass:\"text-capitalize action-button__button\",class:{\n        sticky: _vm.sticky,\n        'action-button__button--ghost': _vm.ghost,\n        'action-button__button--full-width': _vm.fullWidth\n      },attrs:{\"type\":\"submit\",\"disabled\":!_vm.enabled,\"loading\":_vm.loading,\"depressed\":\"\",\"large\":\"\"},on:{\"click\":function($event){return _vm.click()}}},[_vm._v(\" \"+_vm._s(_vm.text)+\" \"),(_vm.arrow)?_c('v-icon',{attrs:{\"right\":\"\"}},[_vm._v(\"keyboard_arrow_right\")]):_vm._e()],1)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Emit, Prop, Vue } from 'vue-property-decorator';\n\n@Component({})\nexport default class ActionButton extends Vue {\n  @Prop({ required: true, type: Boolean })\n  enabled!: boolean;\n\n  @Prop({ required: true })\n  text!: string;\n\n  @Prop({ type: Boolean, default: false })\n  loading!: boolean;\n\n  @Prop({ type: Boolean, default: false })\n  sticky?: boolean;\n\n  @Prop({ type: Boolean, default: false })\n  arrow?: boolean;\n\n  @Prop({ type: Boolean, default: false })\n  ghost?: boolean;\n\n  @Prop({ type: Boolean, default: false })\n  fullWidth?: boolean;\n\n  @Emit()\n  click() {}\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ActionButton.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ActionButton.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ActionButton.vue?vue&type=template&id=de9d7fe4&scoped=true&\"\nimport script from \"./ActionButton.vue?vue&type=script&lang=ts&\"\nexport * from \"./ActionButton.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./ActionButton.vue?vue&type=style&index=0&id=de9d7fe4&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"de9d7fe4\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBtn } from 'vuetify/lib/components/VBtn';\nimport { VCol } from 'vuetify/lib/components/VGrid';\nimport { VIcon } from 'vuetify/lib/components/VIcon';\nimport { VRow } from 'vuetify/lib/components/VGrid';\ninstallComponents(component, {VBtn,VCol,VIcon,VRow})\n","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NoAccessMessage.vue?vue&type=style&index=0&id=7b92b083&scoped=true&lang=scss&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NoAccessMessage.vue?vue&type=style&index=0&id=7b92b083&scoped=true&lang=scss&\"","import { Component, Vue } from 'vue-property-decorator';\n\n@Component\nexport default class BlockieMixin extends Vue {\n  $blockie(address?: string) {\n    if (address) {\n      return this.$identicon.getIdenticon(address);\n    } else {\n      return this.$identicon.getIdenticon('0x000');\n    }\n  }\n}\n","export enum RouteNames {\n  TRANSFER = 'transfer',\n  TRANSFER_STEPS = 'transfer-steps',\n  SELECT_TOKEN = 'select-token',\n  SELECT_HUB = 'select-hub',\n  HOME = 'home',\n  CHANNELS = 'channels',\n  OPEN_CHANNEL = 'open-channel',\n  GENERAL = 'general',\n  GENERAL_HOME = 'general-home',\n  BACKUP_STATE = 'backup-state',\n  RAIDEN_ACCOUNT = 'raiden-account'\n}\n","import { BigNumber, BigNumberish, Network } from 'ethers/utils';\n\nexport interface Token {\n  readonly address: string;\n  readonly decimals?: number;\n  readonly balance?: BigNumberish;\n  readonly symbol?: string;\n  readonly name?: string;\n}\n\nexport interface Presences {\n  [address: string]: boolean;\n}\n\nexport interface AccTokenModel {\n  name: string;\n  symbol: string;\n  address: string;\n  opening: number;\n  open: number;\n  closing: number;\n  closed: number;\n  settling: number;\n  settled: number;\n\n  [index: string]: number | string;\n}\n\nexport interface TokenModel extends AccTokenModel {\n  readonly name: string;\n  readonly symbol: string;\n  readonly address: string;\n  readonly opening: number;\n  readonly open: number;\n  readonly closing: number;\n  readonly closed: number;\n  readonly settling: number;\n  readonly settled: number;\n}\nexport interface Progress {\n  readonly current: number;\n  readonly total: number;\n}\n\nexport interface StepDescription {\n  readonly label: string;\n  readonly title: string;\n  readonly description: string;\n}\n\nexport interface Route {\n  readonly key: number;\n  readonly hops: number;\n  readonly path: string[];\n  readonly fee: BigNumber;\n  readonly displayFee: string;\n}\n\nexport interface Transfer {\n  pfsAddress?: string;\n  serviceFee?: BigNumber;\n  serviceToken?: Token;\n  mediationFee?: BigNumber;\n  target: string;\n  hops: number;\n  paymentId: BigNumberish;\n  transferAmount: BigNumber;\n  transferToken: Token;\n  transferTotal: BigNumber;\n}\n\nexport const emptyDescription = (): StepDescription => ({\n  label: '',\n  title: '',\n  description: ''\n});\n\nexport const emptyTokenModel = (): AccTokenModel => ({\n  name: '',\n  symbol: '',\n  address: '',\n  opening: 0,\n  open: 0,\n  closing: 0,\n  closed: 0,\n  settling: 0,\n  settled: 0\n});\n\nexport const PlaceHolderNetwork: Network = {\n  name: '',\n  chainId: -1\n};\n\nexport enum DeniedReason {\n  UNDEFINED,\n  NO_ACCOUNT,\n  UNSUPPORTED_NETWORK,\n  INITIALIZATION_FAILED,\n  RDN_STATE_MIGRATION\n}\n","import logging from 'loglevel';\nimport { openDB, DBSchema, IDBPDatabase } from 'idb';\n\nconst collectionName = 'logs';\n\ninterface RaidenDB extends DBSchema {\n  [collectionName]: {\n    value: {\n      logger: string;\n      level: string;\n      message: any[];\n    };\n    key: number;\n    indexes: {\n      'by-logger': string;\n      'by-level': number;\n    };\n  };\n}\n\nlet db: IDBPDatabase<RaidenDB>;\n\n/* istanbul ignore next */\nfunction serializeError(e: Error): string {\n  // special handling of Errors, since firefox doesn't like to structure-clone it\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=1556604\n  const strError = e.toString();\n  if (!e.stack) {\n    return strError;\n  } else if (e.stack.startsWith(strError)) {\n    return e.stack; // chrome includes error str repr on top of stack\n  } else {\n    return `${strError}\\n${e.stack}`;\n  }\n}\n\n/* istanbul ignore next */\nfunction filterMessage(message: any[]) {\n  if (message[0] === '%c prev state') return;\n  if (message[0] === ' log end ') return;\n  message = message.map(e =>\n    e instanceof Error\n      ? serializeError(e)\n      : e?.payload instanceof Error // error action\n      ? { ...e, payload: serializeError(e.payload) }\n      : e\n  );\n  if (typeof message[1] === 'string' && message[1].startsWith('color:'))\n    message.splice(1, 1);\n  return message;\n}\n\n/* istanbul ignore next */\nfunction serialize(e: any): string {\n  if (typeof e === 'string') return e;\n  try {\n    return JSON.stringify(e);\n  } catch (err) {\n    try {\n      return e.toString();\n    } catch (err) {\n      return '<unserializable>';\n    }\n  }\n}\n\n/* istanbul ignore next */\nexport async function setupLogStore(\n  dbName = 'raiden',\n  additionalLoggers: string[] = ['matrix']\n): Promise<void> {\n  if (typeof db !== 'undefined') return;\n  db = await openDB<RaidenDB>(dbName, 1, {\n    upgrade(db) {\n      const logsStore = db.createObjectStore(collectionName);\n      logsStore.createIndex('by-logger', 'logger');\n      logsStore.createIndex('by-level', 'level');\n    }\n  });\n\n  for (const log of [logging, ...additionalLoggers.map(logging.getLogger)]) {\n    const origFactory = log.methodFactory;\n    log.methodFactory = (\n      methodName: string,\n      level: 0 | 1 | 2 | 3 | 4 | 5,\n      loggerName: string\n    ): logging.LoggingMethod => {\n      const rawMethod = origFactory(methodName, level, loggerName);\n      return (...message: any[]): void => {\n        rawMethod(...message);\n        const filtered = filterMessage(message);\n        if (!filtered) return;\n        db.put(\n          collectionName,\n          { logger: loggerName, level: methodName, message },\n          Date.now()\n        ).catch(() =>\n          db.put(\n            collectionName,\n            {\n              logger: loggerName,\n              level: methodName,\n              message: message.map(serialize)\n            },\n            Date.now()\n          )\n        );\n      };\n    };\n  }\n}\n\nexport async function getLogsFromStore(): Promise<[number, string]> {\n  let content = '';\n  let cursor = await db.transaction(collectionName).store.openCursor();\n  let lastTime = Date.now();\n  while (cursor) {\n    const { logger, level, message } = cursor.value;\n    const line = message\n      .map(m => (typeof m === 'string' ? m : JSON.stringify(m)))\n      .join(' ');\n    lastTime = +cursor.key;\n    const time = new Date(cursor.key).toISOString();\n    content += `${time} @ ${logger} [${level}] \\t=> ${line}\\n`;\n    cursor = await cursor.continue();\n  }\n  return [lastTime, content];\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.show)?_c('div',{staticClass:\"blurred-overlay\",class:{ fullscreen: _vm.fullscreen }},[_vm._t(\"default\")],2):_vm._e()}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\nimport { Component, Vue, Prop } from 'vue-property-decorator';\n\n@Component({})\nexport default class BlurredOverlay extends Vue {\n  @Prop({ type: Boolean, required: true })\n  show!: boolean;\n  @Prop({ required: false, default: false, type: Boolean })\n  fullscreen!: boolean;\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BlurredOverlay.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BlurredOverlay.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./BlurredOverlay.vue?vue&type=template&id=1d51571c&scoped=true&\"\nimport script from \"./BlurredOverlay.vue?vue&type=script&lang=ts&\"\nexport * from \"./BlurredOverlay.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./BlurredOverlay.vue?vue&type=style&index=0&id=1d51571c&scoped=true&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"1d51571c\",\n  null\n  \n)\n\nexport default component.exports","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"address__container\"},[_c('v-tooltip',{attrs:{\"bottom\":\"\",\"close-delay\":\"1400\"},scopedSlots:_vm._u([{key:\"activator\",fn:function(ref){\nvar on = ref.on;\nreturn [_c('p',_vm._g({staticClass:\"address__label\",on:{\"click\":_vm.copy}},on),[_vm._v(\" \"+_vm._s(_vm.addressOutput)+\" \")])]}}])},[_c('div',{staticClass:\"address__tooltip\"},[_c('input',{ref:\"copy\",staticClass:\"address__input\",domProps:{\"value\":_vm.address}}),_c('div',[_vm._v(\" \"+_vm._s(_vm.copied ? _vm.$t('address-display.copied') : _vm.$t('address-display.copy'))+\" \")])])])],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Prop, Vue } from 'vue-property-decorator';\nimport Filters from '../filters';\n\n@Component({})\nexport default class AddressDisplay extends Vue {\n  @Prop({ required: true })\n  address!: string;\n\n  @Prop({ required: false, default: false, type: Boolean })\n  fullAddress!: boolean;\n\n  copied: boolean = false;\n  private timeout: number = 0;\n\n  get addressOutput() {\n    return this.fullAddress ? this.address : Filters.truncate(this.address, 8);\n  }\n\n  selectAddress(input?: HTMLInputElement): void {\n    if (input) {\n      input.focus();\n      input.select();\n    }\n  }\n\n  deselectAddress(input?: HTMLInputElement): void {\n    if (input) {\n      input.blur();\n    }\n  }\n\n  copy(event: MouseEvent) {\n    event.stopPropagation();\n\n    // Select address\n    this.selectAddress(this.$refs.copy as HTMLInputElement);\n    this.copied = document.execCommand('copy');\n\n    // Deselect text\n    this.deselectAddress(this.$refs.copy as HTMLInputElement);\n\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n    }\n\n    this.timeout = (setTimeout(() => {\n      this.copied = false;\n    }, 2000) as unknown) as number;\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddressDisplay.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddressDisplay.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./AddressDisplay.vue?vue&type=template&id=dda182e6&scoped=true&\"\nimport script from \"./AddressDisplay.vue?vue&type=script&lang=ts&\"\nexport * from \"./AddressDisplay.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./AddressDisplay.vue?vue&type=style&index=0&id=dda182e6&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"dda182e6\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VTooltip } from 'vuetify/lib/components/VTooltip';\ninstallComponents(component, {VTooltip})\n","module.exports = __webpack_public_path__ + \"img/logo.5c4b022d.svg\";","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddressDisplay.vue?vue&type=style&index=0&id=dda182e6&lang=scss&scoped=true&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AddressDisplay.vue?vue&type=style&index=0&id=dda182e6&lang=scss&scoped=true&\"","import { BigNumber, parseUnits, formatUnits, formatEther } from 'ethers/utils';\n\nexport class BalanceUtils {\n  static toEth(wei: BigNumber): string {\n    return formatEther(wei);\n  }\n\n  static toUnits(wei: BigNumber, decimals: number): string {\n    return formatUnits(wei, decimals);\n  }\n\n  static decimalsOverflow(depositTokens: string, decimals: number): boolean {\n    let decimalPart: string;\n    if (depositTokens.indexOf('.') > 0) {\n      decimalPart = depositTokens.split('.')[1];\n    } else {\n      decimalPart = '';\n    }\n    return decimalPart.length > decimals;\n  }\n\n  static parse(deposit: string, decimals: number) {\n    return parseUnits(deposit, decimals);\n  }\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('blurred-overlay',{attrs:{\"show\":_vm.visible,\"fullscreen\":\"\"}},[_c('v-dialog',{attrs:{\"value\":_vm.visible,\"width\":\"350\",\"hide-overlay\":\"\",\"dark\":\"\",\"persistent\":_vm.hideClose},on:{\"click:outside\":function($event){return _vm.close()}}},[_c('v-card',{staticClass:\"raiden-dialog\"},[(!_vm.hideClose)?_c('v-btn',{staticClass:\"raiden-dialog__close\",attrs:{\"icon\":\"\"},on:{\"click\":function($event){return _vm.close()}}},[_c('v-icon',[_vm._v(\"mdi-close\")])],1):_vm._e(),_vm._t(\"default\")],2)],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport BlurredOverlay from '@/components/BlurredOverlay.vue';\nimport { Component, Emit, Vue, Prop } from 'vue-property-decorator';\n\n@Component({ components: { BlurredOverlay } })\nexport default class RaidenDialog extends Vue {\n  @Prop({ required: true, default: false, type: Boolean })\n  visible!: boolean;\n  @Prop({ required: false, default: false, type: Boolean })\n  hideClose!: boolean;\n\n  @Emit()\n  close() {}\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./RaidenDialog.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./RaidenDialog.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./RaidenDialog.vue?vue&type=template&id=23c69e33&scoped=true&\"\nimport script from \"./RaidenDialog.vue?vue&type=script&lang=ts&\"\nexport * from \"./RaidenDialog.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./RaidenDialog.vue?vue&type=style&index=0&id=23c69e33&scoped=true&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"23c69e33\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBtn } from 'vuetify/lib/components/VBtn';\nimport { VCard } from 'vuetify/lib/components/VCard';\nimport { VDialog } from 'vuetify/lib/components/VDialog';\nimport { VIcon } from 'vuetify/lib/components/VIcon';\ninstallComponents(component, {VBtn,VCard,VDialog,VIcon})\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-container',{staticClass:\"home\",attrs:{\"fluid\":\"\"}},[(!_vm.inaccessible && _vm.isConnected)?_c('no-tokens'):_c('div',[_c('v-row',{attrs:{\"no-gutters\":\"\"}},[_c('v-col',{attrs:{\"cols\":\"12\"}},[_c('div',{staticClass:\"home__logo-container\"},[_c('v-img',{staticClass:\"home__logo-container__logo\",attrs:{\"src\":require('../assets/logo.svg'),\"aspect-ratio\":\"1\",\"contain\":\"\"}})],1)])],1),_c('v-row',{attrs:{\"no-gutters\":\"\"}},[_c('v-col',{attrs:{\"cols\":\"12\"}},[_c('div',{staticClass:\"home__app-welcome text-center\"},[_vm._v(\" \"+_vm._s(_vm.$t('home.welcome'))+\" \")])])],1),_c('v-row',{attrs:{\"no-gutters\":\"\"}},[_c('v-col',{attrs:{\"cols\":\"12\"}},[_c('div',{staticClass:\"home__disclaimer text-center font-weight-light\"},[_vm._v(\" \"+_vm._s(_vm.$t('home.disclaimer'))+\" \")]),_c('i18n',{staticClass:\"home__getting-started text-center font-weight-light\",attrs:{\"path\":\"home.getting-started.description\",\"tag\":\"div\"}},[_c('a',{attrs:{\"href\":\"https://github.com/raiden-network/light-client#getting-started\",\"target\":\"_blank\"}},[_vm._v(\" \"+_vm._s(_vm.$t('home.getting-started.link-name'))+\" \")])])],1)],1),_c('action-button',{attrs:{\"enabled\":\"\",\"text\":_vm.$t('home.connect-button'),\"sticky\":\"\"},on:{\"click\":function($event){_vm.connectDialog = true}}}),_c('connect-dialog',{attrs:{\"connecting\":_vm.connecting,\"connecting-subkey\":_vm.connectingSubkey,\"visible\":_vm.connectDialog},on:{\"connect\":_vm.connect,\"close\":function($event){_vm.connectDialog = false}}})],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('raiden-dialog',{staticClass:\"connect\",attrs:{\"visible\":_vm.visible,\"hide-close\":_vm.hideClose},on:{\"close\":_vm.close}},[_c('v-card-title',[_vm._v(\" \"+_vm._s(_vm.$t('home.connect-dialog.connect-title'))+\" \")]),(_vm.injectedProvider)?_c('div',[_c('div',{staticClass:\"connect__button\"},[_c('action-button',{attrs:{\"text\":_vm.$t('home.connect-dialog.web3-provider'),\"enabled\":!_vm.connecting && !_vm.connectingSubkey,\"loading\":_vm.connecting},on:{\"click\":function($event){return _vm.connect(_vm.stateBackup)}}})],1),_c('div',{staticClass:\"text-center font-weight-light\"},[_vm._v(\" \"+_vm._s(_vm.$t('home.connect-dialog.divider'))+\" \")]),(!_vm.connectingSubkey)?_c('i18n',{staticClass:\"connect__raiden-account text-center font-weight-light\",attrs:{\"path\":\"home.connect-dialog.raiden-account.description\",\"tag\":\"div\"}},[(!_vm.connecting)?_c('a',{on:{\"click\":function($event){return _vm.connect(_vm.stateBackup, true)}}},[_vm._v(\" \"+_vm._s(_vm.$t('home.connect-dialog.raiden-account.link-name'))+\" \")]):_c('span',[_vm._v(\" \"+_vm._s(_vm.$t('home.connect-dialog.raiden-account.link-name'))+\" \")])]):_c('div',{staticClass:\"connect__raiden-account-spinner text-center\"},[_c('v-progress-circular',{attrs:{\"size\":30,\"width\":1,\"indeterminate\":\"\"}})],1)],1):_vm._e(),(_vm.accessDenied)?_c('no-access-message',{attrs:{\"reason\":_vm.accessDenied}}):_vm._e(),(!_vm.injectedProvider)?_c('v-card-text',[_c('div',{staticClass:\"text-center\"},[_vm._v(\" \"+_vm._s(_vm.$t('home.connect-dialog.no-provider'))+\" \")])]):_vm._e()],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-alert',{staticClass:\"no-access-message\",attrs:{\"value\":true,\"color\":\"error\",\"icon\":\"warning\"}},[_c('div',{staticClass:\"font-weight-light no-access-message__message\"},[(_vm.networkUnsupported)?_c('span',[_vm._v(\" \"+_vm._s(_vm.$t('no-access.unsupported-network'))+\" \")]):_vm._e(),(_vm.initializationFailed)?_c('span',[_vm._v(\" \"+_vm._s(_vm.$t('no-access.sdk-initialization-failure'))+\" \")]):_vm._e(),(_vm.rdnStateMigration)?_c('span',[_vm._v(\" \"+_vm._s(_vm.$t('no-access.rdn-state-migration'))+\" \")]):_c('span',[_vm._v(_vm._s(_vm.$t('no-access.generic-error')))])])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Prop, Vue } from 'vue-property-decorator';\nimport { DeniedReason } from '@/model/types';\n\n@Component({})\nexport default class NoAccessMessage extends Vue {\n  @Prop({ required: true })\n  reason!: DeniedReason;\n\n  get networkUnsupported(): boolean {\n    return this.reason === DeniedReason.UNSUPPORTED_NETWORK;\n  }\n\n  get initializationFailed(): boolean {\n    return this.reason === DeniedReason.INITIALIZATION_FAILED;\n  }\n\n  get rdnStateMigration(): boolean {\n    return this.reason === DeniedReason.RDN_STATE_MIGRATION;\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NoAccessMessage.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NoAccessMessage.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./NoAccessMessage.vue?vue&type=template&id=7b92b083&scoped=true&\"\nimport script from \"./NoAccessMessage.vue?vue&type=script&lang=ts&\"\nexport * from \"./NoAccessMessage.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./NoAccessMessage.vue?vue&type=style&index=0&id=7b92b083&scoped=true&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"7b92b083\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VAlert } from 'vuetify/lib/components/VAlert';\ninstallComponents(component, {VAlert})\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Prop, Emit, Vue } from 'vue-property-decorator';\nimport { mapState } from 'vuex';\nimport { Web3Provider } from '@/services/web3-provider';\nimport { DeniedReason } from '../model/types';\nimport RaidenDialog from '@/components/RaidenDialog.vue';\nimport ActionButton from '@/components/ActionButton.vue';\nimport NoAccessMessage from '@/components/NoAccessMessage.vue';\n\n@Component({\n  components: {\n    RaidenDialog,\n    ActionButton,\n    NoAccessMessage\n  },\n  computed: mapState(['stateBackup', 'accessDenied'])\n})\nexport default class ConnectDialog extends Vue {\n  hideClose: boolean = false;\n  stateBackup!: string;\n  accessDenied!: DeniedReason;\n\n  @Prop({ required: true, type: Boolean, default: false })\n  visible!: boolean;\n  @Prop({ default: false, required: true, type: Boolean })\n  connecting!: boolean;\n  @Prop({ default: false, required: true, type: Boolean })\n  connectingSubkey!: boolean;\n\n  @Emit()\n  close() {}\n\n  @Emit()\n  connect(uploadedState: string, subkey?: true) {\n    return { uploadedState, subkey };\n  }\n\n  get injectedProvider(): boolean {\n    return Web3Provider.injectedWeb3Available();\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConnectDialog.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ConnectDialog.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./ConnectDialog.vue?vue&type=template&id=3604c23c&scoped=true&\"\nimport script from \"./ConnectDialog.vue?vue&type=script&lang=ts&\"\nexport * from \"./ConnectDialog.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./ConnectDialog.vue?vue&type=style&index=0&id=3604c23c&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"3604c23c\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VCardText } from 'vuetify/lib/components/VCard';\nimport { VCardTitle } from 'vuetify/lib/components/VCard';\nimport { VProgressCircular } from 'vuetify/lib/components/VProgressCircular';\ninstallComponents(component, {VCardText,VCardTitle,VProgressCircular})\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (!_vm.tokens.length)?_c('v-container',{staticClass:\"new-token fill-height\",attrs:{\"fluid\":\"\"}},[_c('v-row',{attrs:{\"align\":\"center\",\"justify\":\"center\",\"no-gutters\":\"\"}},[_c('v-col',{staticClass:\"new-token__button\",attrs:{\"cols\":\"12\"}},[_c('v-btn',{attrs:{\"fab\":\"\",\"color\":\"primary\"},on:{\"click\":function($event){return _vm.navigateToTokenSelect()}}},[_c('v-icon',{attrs:{\"large\":\"\"}},[_vm._v(\"mdi-plus\")])],1)],1),_c('v-col',{staticClass:\"new-token__header\",attrs:{\"cols\":\"12\"}},[_vm._v(\" \"+_vm._s(_vm.$t('tokens.connect-new'))+\" \")])],1)],1):_vm._e()}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Watch, Mixins } from 'vue-property-decorator';\nimport { mapGetters } from 'vuex';\nimport { TokenModel } from '@/model/types';\nimport NavigationMixin from '@/mixins/navigation-mixin';\n\n@Component({\n  computed: {\n    ...mapGetters(['tokens'])\n  }\n})\nexport default class NoTokens extends Mixins(NavigationMixin) {\n  tokens!: TokenModel[];\n\n  @Watch('tokens', { immediate: true })\n  onChange(tokens: TokenModel[]) {\n    if (tokens.length) {\n      this.navigateToSelectTransferTarget(tokens[0].address);\n    }\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NoTokens.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./NoTokens.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./NoTokens.vue?vue&type=template&id=4f16408a&scoped=true&\"\nimport script from \"./NoTokens.vue?vue&type=script&lang=ts&\"\nexport * from \"./NoTokens.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./NoTokens.vue?vue&type=style&index=0&id=4f16408a&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"4f16408a\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBtn } from 'vuetify/lib/components/VBtn';\nimport { VCol } from 'vuetify/lib/components/VGrid';\nimport { VContainer } from 'vuetify/lib/components/VGrid';\nimport { VIcon } from 'vuetify/lib/components/VIcon';\nimport { VRow } from 'vuetify/lib/components/VGrid';\ninstallComponents(component, {VBtn,VCol,VContainer,VIcon,VRow})\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue } from 'vue-property-decorator';\nimport { mapState, mapGetters } from 'vuex';\nimport { ConnectOptions } from '@/types';\nimport { DeniedReason } from '@/model/types';\nimport ActionButton from '@/components/ActionButton.vue';\nimport ConnectDialog from '@/components/ConnectDialog.vue';\nimport NoTokens from '@/components/NoTokens.vue';\n\n@Component({\n  computed: {\n    ...mapState(['loading', 'accessDenied']),\n    ...mapGetters(['isConnected'])\n  },\n  components: {\n    ActionButton,\n    ConnectDialog,\n    NoTokens\n  }\n})\nexport default class Home extends Vue {\n  isConnected!: boolean;\n  connectDialog: boolean = false;\n  connecting: boolean = false;\n  connectingSubkey: boolean = false;\n  loading!: boolean;\n  accessDenied!: DeniedReason;\n\n  get inaccessible() {\n    return (\n      this.connecting ||\n      this.loading ||\n      this.accessDenied !== DeniedReason.UNDEFINED\n    );\n  }\n\n  async connect(connectOptions: ConnectOptions) {\n    const stateBackup = connectOptions.uploadedState;\n    let subkey = connectOptions.subkey;\n\n    if (subkey) {\n      this.connectingSubkey = true;\n    } else {\n      this.connecting = true;\n    }\n\n    this.$store.commit('reset');\n    await this.$raiden.connect(stateBackup, subkey);\n    this.connectingSubkey = false;\n    this.connecting = false;\n    if (!this.accessDenied) {\n      this.connectDialog = false;\n    }\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Home.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Home.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./Home.vue?vue&type=template&id=02ef831a&scoped=true&\"\nimport script from \"./Home.vue?vue&type=script&lang=ts&\"\nexport * from \"./Home.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./Home.vue?vue&type=style&index=0&id=02ef831a&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"02ef831a\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VCol } from 'vuetify/lib/components/VGrid';\nimport { VContainer } from 'vuetify/lib/components/VGrid';\nimport { VImg } from 'vuetify/lib/components/VImg';\nimport { VRow } from 'vuetify/lib/components/VGrid';\ninstallComponents(component, {VCol,VContainer,VImg,VRow})\n","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./HeaderIdenticon.vue?vue&type=style&index=0&id=b740b99e&scoped=true&lang=scss&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./HeaderIdenticon.vue?vue&type=style&index=0&id=b740b99e&scoped=true&lang=scss&\"","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ActionButton.vue?vue&type=style&index=0&id=de9d7fe4&lang=scss&scoped=true&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./ActionButton.vue?vue&type=style&index=0&id=de9d7fe4&lang=scss&scoped=true&\"","import mod from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BlurredOverlay.vue?vue&type=style&index=0&id=1d51571c&scoped=true&lang=scss&\"; export default mod; export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./BlurredOverlay.vue?vue&type=style&index=0&id=1d51571c&scoped=true&lang=scss&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('v-app',{attrs:{\"dark\":\"\"}},[_c('div',{attrs:{\"id\":\"application-wrapper\"}},[_c('router-view',{attrs:{\"name\":\"modal\"}}),_c('div',{attrs:{\"id\":\"application-content\"}},[_c('app-header'),_c('v-content',[_c('v-container',{staticClass:\"application__container fill-height\",attrs:{\"fluid\":\"\"}},[_c('router-view')],1)],1)],1)],1),_c('div',{staticClass:\"policy\"},[_c('a',{attrs:{\"href\":\"https://raiden.network/privacy.html\",\"target\":\"_blank\"}},[_vm._v(\" \"+_vm._s(_vm.$t('application.privacy-policy'))+\" \")])]),_c('offline-snackbar'),_c('update-snackbar')],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"app-header\"},[_c('v-row',{staticClass:\"app-header__top\",attrs:{\"justify\":\"center\",\"align\":\"center\",\"no-gutters\":\"\"}},[_c('v-col',{attrs:{\"cols\":\"12\"}},[_c('div',{staticClass:\"app-header__top__content\"},[_c('div',{staticClass:\"app-header__top__content__back\"},[(_vm.canGoBack)?_c('v-btn',{attrs:{\"height\":\"40px\",\"width\":\"40px\",\"text\":\"\",\"icon\":\"\"},on:{\"click\":function($event){return _vm.onBackClicked()}}},[_c('v-img',{attrs:{\"src\":require('../assets/back_arrow.svg'),\"max-width\":\"34px\"}})],1):_vm._e()],1),_c('v-spacer'),_c('v-col',[_c('div',{staticClass:\"app-header__top__content__title\"},[(_vm.isConnected)?_c('span',[_vm._v(\" \"+_vm._s(_vm.$route.meta.title)+\" \")]):_c('span',[_vm._v(\" \"+_vm._s(_vm.$t('home.title'))+\" \")])]),(!_vm.loading && _vm.defaultAccount)?_c('div',{staticClass:\"app-header__top__content__network\"},[_vm._v(\" \"+_vm._s(_vm.network)+\" \")]):_vm._e()]),_c('v-spacer'),_c('span',{staticClass:\"app-header__account-wrapper\"},[_c('header-identicon',{nativeOn:{\"click\":function($event){return _vm.navigateToGeneralHome()}}})],1)],1)])],1),_c('v-row',{staticClass:\"app-header__bottom\",attrs:{\"align\":\"center\",\"no-gutters\":\"\"}},[(!_vm.loading && _vm.defaultAccount)?_c('v-col',{attrs:{\"cols\":\"12\"}},[_c('div',{staticClass:\"app-header__bottom__address text-left\"},[_c('address-display',{attrs:{\"address\":_vm.defaultAccount}})],1)]):_vm._e()],1)],1)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Mixins } from 'vue-property-decorator';\nimport { mapGetters, mapState } from 'vuex';\nimport { RouteNames } from '@/router/route-names';\nimport NavigationMixin from '@/mixins/navigation-mixin';\nimport HeaderIdenticon from '@/components/HeaderIdenticon.vue';\nimport AddressDisplay from '@/components/AddressDisplay.vue';\n\n@Component({\n  components: {\n    HeaderIdenticon,\n    AddressDisplay\n  },\n  computed: {\n    ...mapState(['loading', 'defaultAccount']),\n    ...mapGetters(['network', 'isConnected'])\n  }\n})\nexport default class AppHeader extends Mixins(NavigationMixin) {\n  isConnected!: boolean;\n  defaultAccount!: string;\n  network!: string;\n\n  get canGoBack(): boolean {\n    const routesWithoutBackBtn: string[] = [\n      RouteNames.HOME,\n      RouteNames.TRANSFER\n    ];\n    return (\n      this.isConnected && !routesWithoutBackBtn.includes(this.$route.name!)\n    );\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AppHeader.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./AppHeader.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./AppHeader.vue?vue&type=template&id=4b1e8dd8&scoped=true&\"\nimport script from \"./AppHeader.vue?vue&type=script&lang=ts&\"\nexport * from \"./AppHeader.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./AppHeader.vue?vue&type=style&index=0&id=4b1e8dd8&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"4b1e8dd8\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBtn } from 'vuetify/lib/components/VBtn';\nimport { VCol } from 'vuetify/lib/components/VGrid';\nimport { VImg } from 'vuetify/lib/components/VImg';\nimport { VRow } from 'vuetify/lib/components/VGrid';\nimport { VSpacer } from 'vuetify/lib/components/VGrid';\ninstallComponents(component, {VBtn,VCol,VImg,VRow,VSpacer})\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.offline)?_c('span',[_c('blurred-overlay',{attrs:{\"show\":_vm.offline,\"fullscreen\":true}}),_c('v-snackbar',{attrs:{\"timeout\":0,\"color\":\"error\"},model:{value:(_vm.offline),callback:function ($$v) {_vm.offline=$$v},expression:\"offline\"}},[_vm._v(\" \"+_vm._s(_vm.$t('general.offline'))+\" \"),_c('v-icon',[_vm._v(\"mdi-alert\")])],1)],1):_vm._e()}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue } from 'vue-property-decorator';\nimport BlurredOverlay from '@/components/BlurredOverlay.vue';\n\n@Component({ components: { BlurredOverlay } })\nexport default class OfflineSnackbar extends Vue {\n  offline: boolean = false;\n\n  handleOnline() {\n    this.offline = false;\n  }\n\n  handleOffline() {\n    this.offline = true;\n  }\n\n  mounted() {\n    this.offline = !navigator.onLine;\n\n    window.addEventListener('offline', this.handleOffline);\n    window.addEventListener('online', this.handleOnline);\n  }\n\n  beforeDestroy() {\n    window.removeEventListener('offline', this.handleOffline);\n    window.removeEventListener('online', this.handleOnline);\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./OfflineSnackbar.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./OfflineSnackbar.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./OfflineSnackbar.vue?vue&type=template&id=11200242&\"\nimport script from \"./OfflineSnackbar.vue?vue&type=script&lang=ts&\"\nexport * from \"./OfflineSnackbar.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VIcon } from 'vuetify/lib/components/VIcon';\nimport { VSnackbar } from 'vuetify/lib/components/VSnackbar';\ninstallComponents(component, {VIcon,VSnackbar})\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.updateAvailable)?_c('span',[_c('blurred-overlay',{attrs:{\"show\":_vm.updateAvailable,\"fullscreen\":true}}),_c('v-snackbar',{attrs:{\"timeout\":0,\"color\":\"primary\"},model:{value:(_vm.updateAvailable),callback:function ($$v) {_vm.updateAvailable=$$v},expression:\"updateAvailable\"}},[_vm._v(\" \"+_vm._s(_vm.$t('update.available'))+\" \"),_c('v-btn',{attrs:{\"dark\":\"\",\"text\":\"\",\"loading\":_vm.isUpdating},on:{\"click\":_vm.update}},[_vm._v(\" \"+_vm._s(_vm.$t('update.update'))+\" \")])],1)],1):_vm._e()}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","\n\n\n\n\n\n\n\n\n\n\n\n\n/* istanbul ignore file */\nimport { Component, Vue } from 'vue-property-decorator';\nimport BlurredOverlay from '@/components/BlurredOverlay.vue';\n\n@Component({ components: { BlurredOverlay } })\nexport default class UpdateSnackbar extends Vue {\n  isUpdating: boolean = false;\n  updateAvailable: boolean = false;\n  swRegistration: ServiceWorkerRegistration | null = null;\n\n  created() {\n    document.addEventListener('swUpdated', this.handleSWUpdate, { once: true });\n\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      setTimeout(() => {\n        this.updateAvailable = false;\n        window.location.reload();\n      }, 1500);\n    });\n  }\n  beforeDestroy() {\n    document.removeEventListener('swUpdated', this.handleSWUpdate);\n  }\n\n  handleSWUpdate(event: any) {\n    this.swRegistration = event.detail;\n    this.updateAvailable = true;\n  }\n\n  update() {\n    this.isUpdating = true;\n    if (!this.swRegistration || !this.swRegistration.waiting) {\n      return;\n    }\n    this.swRegistration.waiting.postMessage('skipWaiting');\n  }\n}\n","import mod from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./UpdateSnackbar.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../../node_modules/cache-loader/dist/cjs.js??ref--14-0!../../node_modules/thread-loader/dist/cjs.js!../../node_modules/babel-loader/lib/index.js!../../node_modules/ts-loader/index.js??ref--14-3!../../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./UpdateSnackbar.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./UpdateSnackbar.vue?vue&type=template&id=1d4ed306&\"\nimport script from \"./UpdateSnackbar.vue?vue&type=script&lang=ts&\"\nexport * from \"./UpdateSnackbar.vue?vue&type=script&lang=ts&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VBtn } from 'vuetify/lib/components/VBtn';\nimport { VSnackbar } from 'vuetify/lib/components/VSnackbar';\ninstallComponents(component, {VBtn,VSnackbar})\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Mixins } from 'vue-property-decorator';\nimport NavigationMixin from './mixins/navigation-mixin';\nimport AppHeader from '@/components/AppHeader.vue';\nimport OfflineSnackbar from '@/components/OfflineSnackbar.vue';\nimport UpdateSnackbar from '@/components/UpdateSnackbar.vue';\n\n@Component({\n  components: {\n    AppHeader,\n    OfflineSnackbar,\n    UpdateSnackbar\n  }\n})\nexport default class App extends Mixins(NavigationMixin) {\n  destroyed() {\n    this.$raiden.disconnect();\n  }\n}\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--14-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--14-3!../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--14-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--14-3!../node_modules/vuetify-loader/lib/loader.js??ref--21-0!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=3bcb8e58&scoped=true&\"\nimport script from \"./App.vue?vue&type=script&lang=ts&\"\nexport * from \"./App.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./App.vue?vue&type=style&index=0&id=3bcb8e58&lang=scss&scoped=true&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"3bcb8e58\",\n  null\n  \n)\n\nexport default component.exports\n\n/* vuetify-loader */\nimport installComponents from \"!../node_modules/vuetify-loader/lib/runtime/installComponents.js\"\nimport { VApp } from 'vuetify/lib/components/VApp';\nimport { VContainer } from 'vuetify/lib/components/VGrid';\nimport { VContent } from 'vuetify/lib/components/VContent';\ninstallComponents(component, {VApp,VContainer,VContent})\n","/* istanbul ignore file */\nimport Component from 'vue-class-component';\n\n// Register the router hooks with their names\nComponent.registerHooks([\n  'beforeRouteEnter',\n  'beforeRouteLeave',\n  'beforeRouteUpdate' // for vue-router 2.2+\n]);\n","import Vue from 'vue';\nimport Router from 'vue-router';\n\nimport Home from '../views/Home.vue';\nimport { RouteNames } from '@/router/route-names';\n\nVue.use(Router);\n\n/* istanbul ignore next */\nconst router = new Router({\n  mode: 'history',\n  base: process.env.BASE_URL,\n  routes: [\n    {\n      path: '/',\n      name: RouteNames.HOME,\n      meta: {\n        title: 'Raiden dApp'\n      },\n      component: Home\n    },\n    {\n      path: '*',\n      redirect: '/'\n    },\n    {\n      path: '/transfer/:token',\n      name: RouteNames.TRANSFER,\n      meta: {\n        title: 'Transfer'\n      },\n      component: () => import('../views/TransferRoute.vue')\n    },\n    {\n      path: '/transfer/:token/:target',\n      name: RouteNames.TRANSFER_STEPS,\n      meta: {\n        title: 'Transfer'\n      },\n      component: () => import('../views/TransferStepsRoute.vue')\n    },\n    {\n      path: '/connect',\n      name: RouteNames.SELECT_TOKEN,\n      meta: {\n        title: 'Select Token'\n      },\n      component: () => import('../views/SelectTokenRoute.vue')\n    },\n    {\n      path: '/connect/:token',\n      name: RouteNames.SELECT_HUB,\n      meta: {\n        title: 'Select Hub'\n      },\n      component: () => import('../views/SelectHubRoute.vue')\n    },\n    {\n      path: '/connect/:token/:partner',\n      name: RouteNames.OPEN_CHANNEL,\n      meta: {\n        title: 'Open Channel'\n      },\n      component: () => import('../views/OpenChannelRoute.vue')\n    },\n    {\n      path: '/channels/:token',\n      name: RouteNames.CHANNELS,\n      meta: {\n        title: 'Channels'\n      },\n      component: () => import('../views/ChannelsRoute.vue')\n    },\n    {\n      path: '/general',\n      name: RouteNames.GENERAL,\n      beforeEnter: (to, from, next) => {\n        // Remembers the route that was visited just before the General view is opened and\n        // then loads the General view in a separate <router-view>. The last visited route\n        // is loaded when clicking out of the General view.\n        if (from.name === null) {\n          next({\n            name: RouteNames.HOME\n          });\n        } else if (to.matched.length) {\n          to.matched[0].components.default = from.matched[0].components.default;\n          to.matched[0].components.modal = () =>\n            import('../views/GeneralDialog.vue');\n        }\n        next();\n      },\n      children: [\n        {\n          path: 'general-home',\n          name: RouteNames.GENERAL_HOME,\n          meta: {\n            title: 'General'\n          },\n          component: () => import('../views/GeneralHome.vue')\n        },\n        {\n          path: 'backup-state',\n          name: RouteNames.BACKUP_STATE,\n          meta: {\n            title: 'Backup State'\n          },\n          component: () => import('../views/BackupState.vue')\n        },\n        {\n          path: 'raiden-account',\n          name: RouteNames.RAIDEN_ACCOUNT,\n          meta: {\n            title: 'Raiden Account'\n          },\n          component: () => import('../views/RaidenAccount.vue')\n        }\n      ]\n    }\n  ]\n});\n\nexport default router;\n","import Vue from 'vue';\nimport Vuex, { StoreOptions } from 'vuex';\nimport { RootState, Tokens, Transfers } from '@/types';\nimport {\n  ChannelState,\n  RaidenChannel,\n  RaidenChannels,\n  RaidenTransfer\n} from 'raiden-ts';\nimport {\n  AccTokenModel,\n  DeniedReason,\n  emptyTokenModel,\n  PlaceHolderNetwork,\n  Token,\n  TokenModel,\n  Presences\n} from '@/model/types';\nimport map from 'lodash/map';\nimport flatMap from 'lodash/flatMap';\nimport filter from 'lodash/filter';\nimport clone from 'lodash/clone';\nimport reduce from 'lodash/reduce';\nimport orderBy from 'lodash/orderBy';\nimport isEqual from 'lodash/isEqual';\nimport isEmpty from 'lodash/isEmpty';\nimport { Network, BigNumber } from 'ethers/utils';\n\nVue.use(Vuex);\n\nconst _defaultState: RootState = {\n  loading: true,\n  defaultAccount: '',\n  accountBalance: '0.0',\n  raidenAccountBalance: '',\n  providerDetected: true,\n  accessDenied: DeniedReason.UNDEFINED,\n  channels: {},\n  tokens: {},\n  transfers: {},\n  presences: {},\n  network: PlaceHolderNetwork,\n  stateBackup: ''\n};\n\nexport function defaultState(): RootState {\n  return clone(_defaultState);\n}\n\nconst store: StoreOptions<RootState> = {\n  state: defaultState(),\n  mutations: {\n    noProvider(state: RootState) {\n      state.providerDetected = false;\n    },\n    accessDenied(state: RootState, reason: DeniedReason) {\n      state.accessDenied = reason;\n    },\n    account(state: RootState, account: string) {\n      state.defaultAccount = account;\n    },\n    loadComplete(state: RootState) {\n      state.loading = false;\n    },\n    balance(state: RootState, balance: string) {\n      state.accountBalance = balance;\n    },\n    raidenAccountBalance(state: RootState, balance: string) {\n      state.raidenAccountBalance = balance;\n    },\n    updateChannels(state: RootState, channels: RaidenChannels) {\n      state.channels = channels;\n    },\n    updateTokens(state: RootState, tokens: Tokens) {\n      for (const [address, token] of Object.entries(tokens))\n        if (address in state.tokens && isEqual(token, state.tokens[address]))\n          continue;\n        else if (address in state.tokens)\n          state.tokens[address] = { ...state.tokens[address], ...token };\n        else state.tokens = { ...state.tokens, [address]: token };\n    },\n    updatePresence(state: RootState, presence: Presences) {\n      state.presences = { ...state.presences, ...presence };\n    },\n    network(state: RootState, network: Network) {\n      state.network = network;\n    },\n    reset(state: RootState) {\n      Object.assign(state, defaultState());\n    },\n    updateTransfers(state: RootState, transfer: RaidenTransfer) {\n      state.transfers = { ...state.transfers, [transfer.secrethash]: transfer };\n    },\n    backupState(state: RootState, uploadedState: string) {\n      state.stateBackup = uploadedState;\n    }\n  },\n  actions: {},\n  getters: {\n    tokens: function(state: RootState): TokenModel[] {\n      const reducer = (\n        acc: AccTokenModel,\n        channel: RaidenChannel\n      ): AccTokenModel => {\n        acc.address = channel.token;\n        (acc[channel.state] as number) += 1;\n        return acc;\n      };\n\n      return map(\n        filter(flatMap(state.channels), channels => !isEmpty(channels)),\n        tokenChannels => {\n          const model = reduce(tokenChannels, reducer, emptyTokenModel());\n          const tokenInfo = state.tokens[model.address];\n          if (tokenInfo) {\n            model.name = tokenInfo.name || '';\n            model.symbol = tokenInfo.symbol || '';\n          }\n\n          return model;\n        }\n      );\n    },\n    allTokens: (state: RootState): Token[] => {\n      return Object.values(state.tokens);\n    },\n    channels: (state: RootState) => (tokenAddress: string) => {\n      let channels: RaidenChannel[] = [];\n      const tokenChannels = state.channels[tokenAddress];\n      if (tokenChannels && !isEmpty(tokenChannels)) {\n        channels = flatMap(tokenChannels);\n      }\n      return channels;\n    },\n    token: (state: RootState) => (tokenAddress: string) => {\n      if (tokenAddress in state.tokens) {\n        return state.tokens[tokenAddress];\n      } else {\n        return null;\n      }\n    },\n    network: (state: RootState) => {\n      return state.network.name || `Chain ${state.network.chainId}`;\n    },\n    channelWithBiggestCapacity: (_, getters) => (tokenAddress: string) => {\n      const channels: RaidenChannel[] = getters.channels(tokenAddress);\n      const openChannels = channels.filter(\n        value => value.state === ChannelState.open\n      );\n      return orderBy(openChannels, ['capacity'], ['desc'])[0];\n    },\n    pendingTransfers: ({ transfers }: RootState) =>\n      Object.keys(transfers)\n        .filter(secretHash => {\n          const { completed } = transfers[secretHash];\n\n          // return whether transfer is pending or not\n          return !completed;\n        })\n        .reduce((pendingTransfers: Transfers, secretHash: string) => {\n          pendingTransfers[secretHash] = transfers[secretHash];\n          return pendingTransfers;\n        }, {}),\n    transfer: (state: RootState) => (paymentId: BigNumber) => {\n      const secretHash = Object.keys(state.transfers).find(\n        secretHash => state.transfers[secretHash].paymentId === paymentId\n      );\n\n      if (secretHash) {\n        return state.transfers[secretHash];\n      }\n\n      return undefined;\n    },\n    isConnected: (state: RootState): boolean => {\n      return (\n        !state.loading &&\n        !!(state.defaultAccount && state.defaultAccount !== '')\n      );\n    },\n    balance: (state: RootState): string => {\n      return state.raidenAccountBalance\n        ? state.raidenAccountBalance\n        : state.accountBalance;\n    }\n  }\n};\n\nexport default new Vuex.Store(store);\n","/* istanbul ignore file */\nimport Component from 'vue-class-component';\n\n// Register the router hooks with their names\nComponent.registerHooks([\n  'beforeRouteEnter',\n  'beforeRouteLeave',\n  'beforeRouteUpdate'\n]);\n","export class ConfigProvider {\n  static async fetch(\n    url?: string\n  ): Promise<{ INFURA_ENDPOINT: string; PRIVATE_KEY: string } | undefined> {\n    if (url) return await (await fetch(url)).json();\n\n    return undefined;\n  }\n}\n","import {\n  ChangeEvent,\n  EventTypes,\n  Raiden,\n  RaidenPaths,\n  RaidenPFS\n} from 'raiden-ts';\nimport { Store } from 'vuex';\nimport { RootState, Tokens } from '@/types';\nimport { Web3Provider } from '@/services/web3-provider';\nimport { BalanceUtils } from '@/utils/balance-utils';\nimport { DeniedReason, Progress, Token, TokenModel } from '@/model/types';\nimport { BigNumber, BigNumberish, parseEther } from 'ethers/utils';\nimport { exhaustMap, filter } from 'rxjs/operators';\nimport asyncPool from 'tiny-async-pool';\nimport { ConfigProvider } from './config-provider';\n\nexport default class RaidenService {\n  private _raiden?: Raiden;\n  private store: Store<RootState>;\n  private _userDepositTokenAddress: string = '';\n\n  private static async createRaiden(\n    provider: any,\n    account: string | number = 0,\n    stateBackup?: string,\n    subkey?: true\n  ): Promise<Raiden> {\n    try {\n      return await Raiden.create(\n        provider,\n        account,\n        {\n          storage: window.localStorage,\n          state: stateBackup\n        },\n        undefined,\n        {\n          pfsSafetyMargin: 1.1,\n          pfs: process.env.VUE_APP_PFS,\n          matrixServer: process.env.VUE_APP_TRANSPORT\n        },\n        subkey\n      );\n    } catch (e) {\n      throw new RaidenInitializationFailed(e);\n    }\n  }\n\n  private get raiden(): Raiden {\n    if (this._raiden === undefined) {\n      throw new Error('Raiden instance was not initialized');\n    } else {\n      return this._raiden;\n    }\n  }\n\n  private async updateBalances(): Promise<void> {\n    this.store.commit('balance', await this.getBalance());\n    this.store.commit(\n      'raidenAccountBalance',\n      await this.getBalance(this.raiden.address)\n    );\n  }\n\n  async fetchTokenList() {\n    const allTokens = await this.raiden.getTokenList();\n    const toFetch: string[] = [];\n    const placeholders: Tokens = {};\n\n    for (const token of allTokens) {\n      toFetch.push(token);\n      placeholders[token] = { address: token };\n    }\n\n    this.store.commit('updateTokens', placeholders);\n    await this.fetchTokenData(toFetch);\n  }\n\n  constructor(store: Store<RootState>) {\n    this._raiden = undefined;\n    this.store = store;\n  }\n\n  get userDepositTokenAddress(): string {\n    if (!this._userDepositTokenAddress) throw new Error('address empty');\n    return this._userDepositTokenAddress;\n  }\n\n  async ensResolve(name: string): Promise<string> {\n    try {\n      return await this.raiden.resolveName(name);\n    } catch (e) {\n      throw new EnsResolveFailed(e);\n    }\n  }\n\n  async connect(stateBackup?: string, subkey?: true) {\n    try {\n      const raidenPackageConfigUrl = process.env.VUE_APP_RAIDEN_PACKAGE;\n      let config;\n      let provider;\n      let raiden;\n\n      if (raidenPackageConfigUrl) {\n        config = await ConfigProvider.fetch(raidenPackageConfigUrl);\n        provider = await Web3Provider.provider(config);\n      } else {\n        provider = await Web3Provider.provider();\n      }\n\n      if (!provider) {\n        this.store.commit('noProvider');\n      } else {\n        if (config) {\n          raiden = await RaidenService.createRaiden(\n            provider,\n            config.PRIVATE_KEY,\n            stateBackup,\n            subkey\n          );\n        } else {\n          raiden = await RaidenService.createRaiden(\n            provider,\n            undefined,\n            stateBackup,\n            subkey\n          );\n        }\n\n        this._raiden = raiden;\n\n        const account = await this.getAccount();\n        this.store.commit('account', account);\n\n        this._userDepositTokenAddress = await raiden.userDepositTokenAddress();\n\n        // update connected tokens data on each newBlock\n        raiden.events$\n          .pipe(\n            filter(value => value.type === 'newBlock'),\n            exhaustMap(() =>\n              this.fetchTokenData(\n                this.store.getters.tokens.map((m: TokenModel) => m.address)\n              )\n            )\n          )\n          .subscribe();\n\n        raiden.events$\n          .pipe(filter(value => value.type === 'raidenShutdown'))\n          .subscribe(() => this.store.commit('reset'));\n\n        raiden.events$.subscribe(value => {\n          if (value.type === 'tokenMonitored') {\n            this.store.commit('updateTokens', {\n              [value.payload.token]: { address: value.payload.token }\n            });\n          }\n\n          // Update presences on matrix presence updates\n          if (value.type === 'matrix/presence/success') {\n            this.store.commit('updatePresence', {\n              [value.meta.address]: value.payload.available\n            });\n          }\n        });\n\n        raiden.channels$.subscribe(value => {\n          this.store.commit('updateChannels', value);\n        });\n\n        // Subscribe to our pending transfers\n        raiden.transfers$.subscribe(transfer => {\n          if (transfer.initiator === account) {\n            this.store.commit('updateTransfers', transfer);\n          }\n        });\n\n        this.store.commit('network', raiden.network);\n\n        window.addEventListener('beforeunload', () => this.raiden.stop());\n        raiden.start();\n        this.store.commit('balance', await this.getBalance());\n        if (subkey) {\n          this.store.commit(\n            'raidenAccountBalance',\n            await this.getBalance(raiden.address)\n          );\n        }\n      }\n    } catch (e) {\n      let deniedReason: DeniedReason;\n      if (e.message && e.message.indexOf('No deploy info provided') > -1) {\n        deniedReason = DeniedReason.UNSUPPORTED_NETWORK;\n      } else if (\n        e.message &&\n        e.message.indexOf('Could not replace stored state') > -1\n      ) {\n        deniedReason = DeniedReason.RDN_STATE_MIGRATION;\n      } else if (e instanceof RaidenInitializationFailed) {\n        deniedReason = DeniedReason.INITIALIZATION_FAILED;\n      } else {\n        deniedReason = DeniedReason.NO_ACCOUNT;\n      }\n      this.store.commit('accessDenied', deniedReason);\n    }\n\n    this.store.commit('loadComplete');\n  }\n\n  disconnect() {\n    this.raiden.stop();\n  }\n\n  async getAccount(): Promise<string> {\n    return this.raiden.address;\n  }\n\n  async getMainAccount(): Promise<string | undefined> {\n    return this.raiden.mainAddress;\n  }\n\n  async getBalance(address?: string): Promise<string> {\n    const balance = await this.raiden.getBalance(address);\n    return BalanceUtils.toEth(balance);\n  }\n\n  private async getToken(tokenAddress: string): Promise<Token | null> {\n    const raiden = this.raiden;\n    try {\n      const [balance, { decimals, symbol, name }] = await Promise.all([\n        raiden.getTokenBalance(tokenAddress),\n        raiden.getTokenInfo(tokenAddress)\n      ]);\n      return {\n        name: name,\n        symbol: symbol,\n        balance: balance,\n        decimals: decimals,\n        address: tokenAddress\n      };\n    } catch (e) {\n      return null;\n    }\n  }\n\n  async openChannel(\n    token: string,\n    partner: string,\n    amount: BigNumber,\n    progress?: (progress: Progress) => void\n  ): Promise<void> {\n    const progressUpdater = (current: number, total: number) => {\n      if (progress) {\n        progress({\n          current,\n          total\n        });\n      }\n    };\n\n    const raiden = this.raiden;\n    progressUpdater(1, 3);\n\n    try {\n      await raiden.openChannel(token, partner, { deposit: amount }, e =>\n        e.type === EventTypes.OPENED ? progressUpdater(2, 3) : ''\n      );\n    } catch (e) {\n      throw new ChannelOpenFailed(e);\n    }\n  }\n\n  async closeChannel(token: string, partner: string) {\n    try {\n      await this.raiden.closeChannel(token, partner);\n    } catch (e) {\n      throw new ChannelCloseFailed(e);\n    }\n  }\n\n  async deposit(token: string, partner: string, amount: BigNumber) {\n    try {\n      await this.raiden.depositChannel(token, partner, amount);\n    } catch (e) {\n      throw new ChannelDepositFailed(e);\n    }\n  }\n\n  async settleChannel(token: string, partner: string) {\n    try {\n      await this.raiden.settleChannel(token, partner);\n    } catch (e) {\n      throw new ChannelSettleFailed(e);\n    }\n  }\n\n  async fetchTokenData(tokens: string[]): Promise<void> {\n    if (!tokens.length) return;\n    const fetchToken = async (address: string): Promise<void> =>\n      this.getToken(address).then(token => {\n        if (!token) return;\n        this.store.commit('updateTokens', { [token.address]: token });\n      });\n\n    await asyncPool(6, tokens, fetchToken);\n  }\n\n  async transfer(\n    token: string,\n    target: string,\n    amount: BigNumber,\n    paths: RaidenPaths,\n    paymentId: BigNumber\n  ) {\n    try {\n      const secretHash = await this.raiden.transfer(token, target, amount, {\n        paymentId,\n        paths\n      });\n\n      // Wait for transaction to be completed\n      await this.raiden.waitTransfer(secretHash);\n    } catch (e) {\n      throw new TransferFailed(e);\n    }\n  }\n\n  async findRoutes(\n    token: string,\n    target: string,\n    amount: BigNumber,\n    raidenPFS?: RaidenPFS\n  ): Promise<RaidenPaths> {\n    let routes: RaidenPaths;\n\n    await this.raiden.getAvailability(target);\n    routes = await this.raiden.findRoutes(token, target, amount, {\n      pfs: raidenPFS\n    });\n\n    return routes;\n  }\n\n  async fetchServices(): Promise<RaidenPFS[]> {\n    let raidenPFS: RaidenPFS[];\n    raidenPFS = await this.raiden.findPFS();\n    return raidenPFS;\n  }\n\n  /* istanbul ignore next */\n  async directRoute(\n    token: string,\n    target: string,\n    value: BigNumberish\n  ): Promise<RaidenPaths | undefined> {\n    return await this.raiden.directRoute(token, target, value);\n  }\n\n  /* istanbul ignore next */\n  async mint(token: string, amount: BigNumber): Promise<string> {\n    return await this.raiden.mint(token, amount);\n  }\n\n  /* istanbul ignore next */\n  async depositToUDC(amount: BigNumber, depositing: () => void): Promise<void> {\n    await this.raiden.depositToUDC(\n      amount,\n      (event: ChangeEvent<EventTypes, { txHash: string }>) =>\n        event.type === EventTypes.APPROVED ? depositing() : null\n    );\n  }\n\n  /* istanbul ignore next */\n  async getUDCCapacity(): Promise<BigNumber> {\n    return this.raiden.getUDCCapacity();\n  }\n\n  async getAvailability(address: string): Promise<boolean> {\n    try {\n      const { available } = await this.raiden.getAvailability(address);\n      return available;\n    } catch (e) {\n      this.store.commit('updatePresence', { [address]: false });\n    }\n\n    return false;\n  }\n\n  /* istanbul ignore next */\n  async getState() {\n    this._raiden?.stop();\n    return await this._raiden?.state$.toPromise();\n  }\n\n  /* istanbul ignore next */\n  async transferToRaidenAccount(amount: string) {\n    await this.raiden.transferOnchainBalance(\n      this.raiden.address,\n      parseEther(amount)\n    );\n    await this.updateBalances();\n  }\n\n  /* istanbul ignore next */\n  async transferToMainAccount(amount: string) {\n    const { mainAddress } = this.raiden;\n    if (mainAddress) {\n      await this.raiden.transferOnchainBalance(\n        mainAddress,\n        parseEther(amount),\n        { subkey: true }\n      );\n      await this.updateBalances();\n    }\n  }\n}\n\nexport class ChannelSettleFailed extends Error {}\n\nexport class ChannelCloseFailed extends Error {}\n\nexport class ChannelOpenFailed extends Error {}\n\nexport class ChannelDepositFailed extends Error {}\n\nexport class EnsResolveFailed extends Error {}\n\nexport class TransferFailed extends Error {}\n\nexport class RaidenInitializationFailed extends Error {}\n","import _Vue from 'vue';\nimport RaidenService from '@/services/raiden-service';\nimport store from '@/store/index';\n\nexport function RaidenPlugin(Vue: typeof _Vue, _options?: any): void {\n  Vue.prototype.$raiden = new RaidenService(store);\n}\n\ndeclare module 'vue/types/vue' {\n  // 3. Declare augmentation for Vue\n  interface Vue {\n    $raiden: RaidenService;\n  }\n}\n","import makeBlockie from 'ethereum-blockies-base64';\n\nexport class IdenticonCache {\n  private cache: { [id: string]: string } = {};\n\n  constructor() {}\n\n  public getIdenticon(address: string): string {\n    const cached = this.cache[address];\n\n    if (!cached) {\n      const generated = makeBlockie(address);\n      this.cache[address] = generated;\n      return generated;\n    } else {\n      return cached;\n    }\n  }\n}\n","import _Vue from 'vue';\nimport { IdenticonCache } from '@/services/identicon-cache';\n\nexport function IdenticonPlugin(Vue: typeof _Vue, _options?: any): void {\n  Vue.prototype.$identicon = new IdenticonCache();\n}\n\ndeclare module 'vue/types/vue' {\n  // 3. Declare augmentation for Vue\n  interface Vue {\n    $identicon: IdenticonCache;\n  }\n}\n","/* istanbul ignore file */\nimport Vue from 'vue';\nimport VueI18n, { LocaleMessages } from 'vue-i18n';\n\nVue.use(VueI18n);\n\nfunction loadLocaleMessages(): LocaleMessages {\n  const locales = require.context(\n    './locales',\n    true,\n    /[A-Za-z0-9-_,\\s]+\\.json$/i\n  );\n  const messages: LocaleMessages = {};\n  locales.keys().forEach(key => {\n    const matched = key.match(/([A-Za-z0-9-_]+)\\./i);\n    if (matched && matched.length > 1) {\n      const locale = matched[1];\n      messages[locale] = locales(key);\n    }\n  });\n  return messages;\n}\n\nexport default new VueI18n({\n  locale: process.env.VUE_APP_I18N_LOCALE || 'en',\n  fallbackLocale: process.env.VUE_APP_I18N_FALLBACK_LOCALE || 'en',\n  messages: loadLocaleMessages()\n});\n","/* istanbul ignore file */\nimport '@mdi/font/css/materialdesignicons.css';\nimport Vue from 'vue';\nimport Vuetify from 'vuetify/lib';\n\nVue.use(Vuetify);\n\nexport default new Vuetify({\n  icons: {\n    iconfont: 'mdi'\n  },\n  theme: {\n    dark: true,\n    themes: {\n      dark: {\n        primary: '#28A5C8',\n        secondary: '#0A6E87'\n      }\n    }\n  }\n});\n","/* eslint-disable no-console */\n/* istanbul ignore file */\n\nimport { register } from 'register-service-worker';\n\nif (\n  process.env.NODE_ENV === 'production' &&\n  !process.env.VUE_APP_RAIDEN_PACKAGE\n) {\n  register(`${process.env.BASE_URL}service-worker.js`, {\n    ready() {\n      console.log(\n        'App is being served from cache by a service worker.\\n' +\n          'For more details, visit https://goo.gl/AFskqB'\n      );\n    },\n    registered(registration: ServiceWorkerRegistration) {\n      // Check periodically for updates every minute\n      setInterval(() => {\n        registration.update();\n      }, 1000 * 60);\n      console.log('Service worker has been registered.');\n    },\n    cached() {\n      console.log('Content has been cached for offline use.');\n    },\n    updatefound() {\n      console.log('New content is downloading.');\n    },\n    updated(registration: ServiceWorkerRegistration) {\n      document.dispatchEvent(\n        new CustomEvent('swUpdated', { detail: registration })\n      );\n      console.log('New content is available; please refresh.');\n    },\n    offline() {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    },\n    error(error) {\n      console.error('Error during service worker registration:', error);\n    }\n  });\n}\n","/* istanbul ignore file */\nimport Vue from 'vue';\nimport App from './App.vue';\nimport '@/plugins/class-component.hooks';\nimport '@/filters';\nimport router from './router/index';\nimport store from './store/index';\nimport { setupLogStore } from './utils/logstore';\nimport './class-component-hooks';\nimport { RaidenPlugin } from '@/plugins/raiden';\nimport { IdenticonPlugin } from '@/plugins/identicon-plugin';\nimport i18n from './i18n';\nimport vuetify from '@/plugins/vuetify';\nimport VueVirtualScroller from 'vue-virtual-scroller';\nimport 'vue-virtual-scroller/dist/vue-virtual-scroller.css';\nimport './registerServiceWorker';\n\nVue.config.productionTip = false;\n\nsetupLogStore();\n\nVue.use(RaidenPlugin);\nVue.use(IdenticonPlugin);\nVue.use(VueVirtualScroller);\n\nnew Vue({\n  vuetify,\n  router,\n  store,\n  i18n,\n  render: h => h(App)\n}).$mount('#app');\n","export class Web3Provider {\n  static async provider(config?: { INFURA_ENDPOINT: string }) {\n    const ethereum = window.ethereum;\n    let provider = null;\n\n    if (config) {\n      provider = `https://${config.INFURA_ENDPOINT}`;\n    } else if (typeof ethereum !== 'undefined') {\n      await ethereum.enable();\n      provider = ethereum;\n    } else if (window.web3) {\n      provider = window.web3.currentProvider;\n    }\n\n    /* istanbul ignore next */\n    if (provider && provider.isMetaMask) {\n      provider.autoRefreshOnNetworkChange = false;\n      provider.on('networkChanged', () =>\n        window.location.replace(window.location.origin)\n      );\n    }\n\n    return provider;\n  }\n\n  static injectedWeb3Available = (): boolean => window.ethereum || window.web3;\n}\n","import 'symbol-observable';\nimport 'isomorphic-fetch';\nimport 'abort-controller/polyfill';\n// matrix-js-sdk monkey-patch root methodFactory\nimport logging from 'loglevel';\nconst methodFactory = logging.methodFactory;\nimport { logger as matrixLogger } from 'matrix-js-sdk/lib/logger';\nObject.assign(logging, { methodFactory }); // revert\nmatrixLogger.setLevel(logging.levels.DEBUG); // apply\n// request.abort() is called when shutting down matrix; this patch clears some timeouts left behind\nimport { getRequest, request } from 'matrix-js-sdk';\nconst origRequest = getRequest();\n// 'request' replaces matrix's request\nrequest((opts, cb) => {\n    const req = origRequest(opts, cb);\n    const origAbort = req.abort.bind(req);\n    return Object.assign(req, {\n        abort: function () {\n            origAbort();\n            cb(new Error('aborted!')); // also call callback when aborting, to clear pending timeouts\n        },\n    });\n});\nif (!('RTCPeerConnection' in globalThis)) {\n    Object.assign(globalThis, require('wrtc')); // eslint-disable-line @typescript-eslint/no-var-requires\n}\n// patch createNewMatrixCall to prevent matrix-js-sdk from hooking WebRTC events in browser;\n// ugly, but there's no option to prevent MatrixClient to handle m.call.* events\nimport * as call from 'matrix-js-sdk/lib/webrtc/call';\nObject.assign(call, { createNewMatrixCall: () => null });\n//# sourceMappingURL=polyfills.js.map","/* Generated by ts-generator ver. 0.0.8 */\n/* tslint:disable */\n\nimport { Contract, Signer } from \"ethers\";\nimport { Provider } from \"ethers/providers\";\n\nimport { TokenNetworkRegistry } from \"./TokenNetworkRegistry\";\n\nexport class TokenNetworkRegistryFactory {\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): TokenNetworkRegistry {\n    return new Contract(\n      address,\n      _abi,\n      signerOrProvider\n    ) as TokenNetworkRegistry;\n  }\n}\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_secret_registry_address\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_chain_id\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_settlement_timeout_min\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_settlement_timeout_max\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_max_token_networks\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"token_address\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"token_network_address\",\n        type: \"address\"\n      }\n    ],\n    name: \"TokenNetworkCreated\",\n    type: \"event\"\n  },\n  {\n    inputs: [],\n    name: \"chain_id\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"contract_address\",\n        type: \"address\"\n      }\n    ],\n    name: \"contractExists\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_token_address\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_channel_participant_deposit_limit\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_token_network_deposit_limit\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"createERC20TokenNetwork\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"token_network_address\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"deprecation_executor\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"max_token_networks\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"secret_registry_address\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"settlement_timeout_max\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"settlement_timeout_min\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"token_network_created\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"token_to_token_networks\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n];\n","/* Generated by ts-generator ver. 0.0.8 */\n/* tslint:disable */\n\nimport { Contract, Signer } from \"ethers\";\nimport { Provider } from \"ethers/providers\";\n\nimport { TokenNetwork } from \"./TokenNetwork\";\n\nexport class TokenNetworkFactory {\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): TokenNetwork {\n    return new Contract(address, _abi, signerOrProvider) as TokenNetwork;\n  }\n}\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_token_address\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"_secret_registry\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_chain_id\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_settlement_timeout_min\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_settlement_timeout_max\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"_deprecation_executor\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_channel_participant_deposit_limit\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_token_network_deposit_limit\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"closing_participant\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"nonce\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"balance_hash\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"ChannelClosed\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"participant\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"total_deposit\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"ChannelNewDeposit\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"participant1\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"participant2\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"settle_timeout\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"ChannelOpened\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"participant1_amount\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"participant1_locksroot\",\n        type: \"bytes32\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"participant2_amount\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"participant2_locksroot\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"ChannelSettled\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"locksroot\",\n        type: \"bytes32\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"unlocked_amount\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"returned_tokens\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"ChannelUnlocked\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"participant\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"total_withdraw\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"ChannelWithdraw\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"bool\",\n        name: \"new_value\",\n        type: \"bool\"\n      }\n    ],\n    name: \"DeprecationSwitch\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"closing_participant\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"nonce\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"balance_hash\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"NonClosingBalanceProofUpdated\",\n    type: \"event\"\n  },\n  {\n    inputs: [],\n    name: \"MAX_SAFE_UINT256\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"chain_id\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"channel_counter\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"channel_participant_deposit_limit\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"channels\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"settle_block_number\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"enum TokenNetwork.ChannelState\",\n        name: \"state\",\n        type: \"uint8\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"non_closing_participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"closing_participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"balance_hash\",\n        type: \"bytes32\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"nonce\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"additional_hash\",\n        type: \"bytes32\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"non_closing_signature\",\n        type: \"bytes\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"closing_signature\",\n        type: \"bytes\"\n      }\n    ],\n    name: \"closeChannel\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"contract_address\",\n        type: \"address\"\n      }\n    ],\n    name: \"contractExists\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"deprecate\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"deprecation_executor\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"partner\",\n        type: \"address\"\n      }\n    ],\n    name: \"getChannelIdentifier\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"participant1\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"participant2\",\n        type: \"address\"\n      }\n    ],\n    name: \"getChannelInfo\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"enum TokenNetwork.ChannelState\",\n        name: \"\",\n        type: \"uint8\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"partner\",\n        type: \"address\"\n      }\n    ],\n    name: \"getChannelParticipantInfo\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"partner\",\n        type: \"address\"\n      }\n    ],\n    name: \"getParticipantsHash\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\"\n      }\n    ],\n    stateMutability: \"pure\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\"\n      }\n    ],\n    name: \"getUnlockIdentifier\",\n    outputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\"\n      }\n    ],\n    stateMutability: \"pure\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"participant1\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"participant2\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"settle_timeout\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"openChannel\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"participants_hash_to_channel_identifier\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"safety_deprecation_switch\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"secret_registry\",\n    outputs: [\n      {\n        internalType: \"contract SecretRegistry\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"total_deposit\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"partner\",\n        type: \"address\"\n      }\n    ],\n    name: \"setTotalDeposit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"total_withdraw\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"expiration_block\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"participant_signature\",\n        type: \"bytes\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"partner_signature\",\n        type: \"bytes\"\n      }\n    ],\n    name: \"setTotalWithdraw\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"participant1\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"participant1_transferred_amount\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"participant1_locked_amount\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"participant1_locksroot\",\n        type: \"bytes32\"\n      },\n      {\n        internalType: \"address\",\n        name: \"participant2\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"participant2_transferred_amount\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"participant2_locked_amount\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"participant2_locksroot\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"settleChannel\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"settlement_timeout_max\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"settlement_timeout_min\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"signature_prefix\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"token\",\n    outputs: [\n      {\n        internalType: \"contract Token\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"token_network_deposit_limit\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"locks\",\n        type: \"bytes\"\n      }\n    ],\n    name: \"unlock\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"channel_identifier\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"closing_participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"non_closing_participant\",\n        type: \"address\"\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"balance_hash\",\n        type: \"bytes32\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"nonce\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes32\",\n        name: \"additional_hash\",\n        type: \"bytes32\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"closing_signature\",\n        type: \"bytes\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"non_closing_signature\",\n        type: \"bytes\"\n      }\n    ],\n    name: \"updateNonClosingBalanceProof\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  }\n];\n","/* Generated by ts-generator ver. 0.0.8 */\n/* tslint:disable */\n\nimport { Contract, Signer } from \"ethers\";\nimport { Provider } from \"ethers/providers\";\n\nimport { HumanStandardToken } from \"./HumanStandardToken\";\n\nexport class HumanStandardTokenFactory {\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): HumanStandardToken {\n    return new Contract(address, _abi, signerOrProvider) as HumanStandardToken;\n  }\n}\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_initialAmount\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint8\",\n        name: \"_decimalUnits\",\n        type: \"uint8\"\n      },\n      {\n        internalType: \"string\",\n        name: \"_tokenName\",\n        type: \"string\"\n      },\n      {\n        internalType: \"string\",\n        name: \"_tokenSymbol\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_owner\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_spender\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Approval\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_from\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_to\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Transfer\",\n    type: \"event\"\n  },\n  {\n    stateMutability: \"nonpayable\",\n    type: \"fallback\"\n  },\n  {\n    inputs: [],\n    name: \"_decimals\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"\",\n        type: \"uint8\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_owner\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"_spender\",\n        type: \"address\"\n      }\n    ],\n    name: \"allowance\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"remaining\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_spender\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"approve\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_spender\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"bytes\",\n        name: \"_extraData\",\n        type: \"bytes\"\n      }\n    ],\n    name: \"approveAndCall\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_owner\",\n        type: \"address\"\n      }\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"balance\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"balances\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"decimals\",\n        type: \"uint8\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"supply\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"transfer\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_from\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"_to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"transferFrom\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n];\n","/* Generated by ts-generator ver. 0.0.8 */\n/* tslint:disable */\n\nimport { Contract, Signer } from \"ethers\";\nimport { Provider } from \"ethers/providers\";\n\nimport { ServiceRegistry } from \"./ServiceRegistry\";\n\nexport class ServiceRegistryFactory {\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): ServiceRegistry {\n    return new Contract(address, _abi, signerOrProvider) as ServiceRegistry;\n  }\n}\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_token_for_registration\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"_controller\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_initial_price\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_price_bump_numerator\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_price_bump_denominator\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_decay_constant\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_min_price\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_registration_duration\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"service\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"valid_till\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"deposit_amount\",\n        type: \"uint256\"\n      },\n      {\n        indexed: false,\n        internalType: \"contract Deposit\",\n        name: \"deposit_contract\",\n        type: \"address\"\n      }\n    ],\n    name: \"RegisteredService\",\n    type: \"event\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_price_bump_numerator\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_price_bump_denominator\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_decay_constant\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_min_price\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_registration_duration\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"changeParameters\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"_success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"contract_address\",\n        type: \"address\"\n      }\n    ],\n    name: \"contractExists\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"controller\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"currentPrice\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"decay_constant\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_set_price\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_seconds_passed\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"decayedPrice\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_limit_amount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"deposit\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"_success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"deprecated\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"everMadeDepositsLen\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"_len\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"ever_made_deposits\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_address\",\n        type: \"address\"\n      }\n    ],\n    name: \"hasValidRegistration\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"_has_registration\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"min_price\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"price_bump_denominator\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"price_bump_numerator\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"registration_duration\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"service_valid_till\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"setDeprecationSwitch\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"_success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"string\",\n        name: \"new_url\",\n        type: \"string\"\n      }\n    ],\n    name: \"setURL\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"_success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"set_price\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"set_price_at\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"token\",\n    outputs: [\n      {\n        internalType: \"contract Token\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"urls\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n];\n","/* Generated by ts-generator ver. 0.0.8 */\n/* tslint:disable */\n\nimport { Contract, Signer } from \"ethers\";\nimport { Provider } from \"ethers/providers\";\n\nimport { CustomToken } from \"./CustomToken\";\n\nexport class CustomTokenFactory {\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): CustomToken {\n    return new Contract(address, _abi, signerOrProvider) as CustomToken;\n  }\n}\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"initial_supply\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint8\",\n        name: \"decimal_units\",\n        type: \"uint8\"\n      },\n      {\n        internalType: \"string\",\n        name: \"token_name\",\n        type: \"string\"\n      },\n      {\n        internalType: \"string\",\n        name: \"token_symbol\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_owner\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_spender\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Approval\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_to\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"uint256\",\n        name: \"_num\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Minted\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_from\",\n        type: \"address\"\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_to\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"Transfer\",\n    type: \"event\"\n  },\n  {\n    inputs: [],\n    name: \"_decimals\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"\",\n        type: \"uint8\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_owner\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"_spender\",\n        type: \"address\"\n      }\n    ],\n    name: \"allowance\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"remaining\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_spender\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"approve\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_owner\",\n        type: \"address\"\n      }\n    ],\n    name: \"balanceOf\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"balance\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"balances\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [\n      {\n        internalType: \"uint8\",\n        name: \"decimals\",\n        type: \"uint8\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"num\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"mint\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"num\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"address\",\n        name: \"target\",\n        type: \"address\"\n      }\n    ],\n    name: \"mintFor\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"multiplier\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"owner_address\",\n    outputs: [\n      {\n        internalType: \"address payable\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"supply\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"transfer\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_from\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"_to\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_value\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"transferFrom\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"transferFunds\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [\n      {\n        internalType: \"string\",\n        name: \"\",\n        type: \"string\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n];\n","/* Generated by ts-generator ver. 0.0.8 */\n/* tslint:disable */\n\nimport { Contract, Signer } from \"ethers\";\nimport { Provider } from \"ethers/providers\";\n\nimport { UserDeposit } from \"./UserDeposit\";\n\nexport class UserDepositFactory {\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): UserDeposit {\n    return new Contract(address, _abi, signerOrProvider) as UserDeposit;\n  }\n}\n\nconst _abi = [\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_token_address\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"_whole_balance_limit\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"constructor\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"newBalance\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"BalanceReduced\",\n    type: \"event\"\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"withdrawer\",\n        type: \"address\"\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"plannedBalance\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"WithdrawPlanned\",\n    type: \"event\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"balances\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"contract_address\",\n        type: \"address\"\n      }\n    ],\n    name: \"contractExists\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"beneficiary\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"new_total_deposit\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"deposit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\"\n      }\n    ],\n    name: \"effectiveBalance\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"remaining_balance\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"_msc_address\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"_one_to_n_address\",\n        type: \"address\"\n      }\n    ],\n    name: \"init\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"msc_address\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"one_to_n_address\",\n    outputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"planWithdraw\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"token\",\n    outputs: [\n      {\n        internalType: \"contract Token\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"total_deposit\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"sender\",\n        type: \"address\"\n      },\n      {\n        internalType: \"address\",\n        name: \"receiver\",\n        type: \"address\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"transfer\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"success\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"whole_balance\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"whole_balance_limit\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      }\n    ],\n    name: \"withdraw\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [],\n    name: \"withdraw_delay\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address\",\n        name: \"\",\n        type: \"address\"\n      }\n    ],\n    name: \"withdraw_plans\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\"\n      },\n      {\n        internalType: \"uint256\",\n        name: \"withdraw_block\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  }\n];\n","/* Generated by ts-generator ver. 0.0.8 */\n/* tslint:disable */\n\nimport { Contract, Signer } from \"ethers\";\nimport { Provider } from \"ethers/providers\";\n\nimport { SecretRegistry } from \"./SecretRegistry\";\n\nexport class SecretRegistryFactory {\n  static connect(\n    address: string,\n    signerOrProvider: Signer | Provider\n  ): SecretRegistry {\n    return new Contract(address, _abi, signerOrProvider) as SecretRegistry;\n  }\n}\n\nconst _abi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"secrethash\",\n        type: \"bytes32\"\n      },\n      {\n        indexed: false,\n        internalType: \"bytes32\",\n        name: \"secret\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"SecretRevealed\",\n    type: \"event\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"secrethash\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"getSecretRevealBlockHeight\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\"\n      }\n    ],\n    stateMutability: \"view\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"secret\",\n        type: \"bytes32\"\n      }\n    ],\n    name: \"registerSecret\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32[]\",\n        name: \"secrets\",\n        type: \"bytes32[]\"\n      }\n    ],\n    name: \"registerSecretBatch\",\n    outputs: [\n      {\n        internalType: \"bool\",\n        name: \"\",\n        type: \"bool\"\n      }\n    ],\n    stateMutability: \"nonpayable\",\n    type: \"function\"\n  }\n];\n","export var EventTypes;\n(function (EventTypes) {\n    EventTypes[\"OPENED\"] = \"OPENED\";\n    EventTypes[\"APPROVED\"] = \"APPROVED\";\n    EventTypes[\"DEPOSITED\"] = \"DEPOSITED\";\n    EventTypes[\"CONFIRMED\"] = \"CONFIRMED\";\n})(EventTypes || (EventTypes = {}));\n//# sourceMappingURL=types.js.map","import { padZeros } from 'ethers/utils';\nexport const SignatureZero = padZeros([], 65);\nexport var ShutdownReason;\n(function (ShutdownReason) {\n    ShutdownReason[\"STOP\"] = \"raidenStopped\";\n    ShutdownReason[\"ACCOUNT_CHANGED\"] = \"providerAccountChanged\";\n    ShutdownReason[\"NETWORK_CHANGED\"] = \"providerNetworkChanged\";\n})(ShutdownReason || (ShutdownReason = {}));\nexport var Capabilities;\n(function (Capabilities) {\n    // opt-out capabilities, for backwards compatibility\n    Capabilities[\"NO_RECEIVE\"] = \"noReceive\";\n    Capabilities[\"NO_MEDIATE\"] = \"noMediate\";\n    Capabilities[\"NO_DELIVERY\"] = \"noDelivery\";\n    Capabilities[\"WEBRTC\"] = \"webRTC\";\n})(Capabilities || (Capabilities = {}));\n//# sourceMappingURL=constants.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as t from 'io-ts';\nimport { BigNumber, bigNumberify, getAddress, isHexString, hexDataLength } from 'ethers/utils';\nimport { Two, Zero } from 'ethers/constants';\nimport { ThrowReporter } from 'io-ts/lib/ThrowReporter';\nimport memoize from 'lodash/memoize';\n/**\n * Error for assertion functions/type guards\n */\nexport class AssertionError extends Error {\n}\n/**\n * Type-safe assertion function (TS3.7)\n *\n * @param condition - Condition to validate as truthy\n * @param msg - Message to throw if condition is falsy\n * @param log - Logger to log error to\n */\nexport function assert(condition, msg, log) {\n    if (!condition) {\n        log === null || log === void 0 ? void 0 : log('AssertionError', condition, msg);\n        throw new AssertionError(msg !== null && msg !== void 0 ? msg : 'AssertionError');\n    }\n}\nfunction reporterAssert(value) {\n    ThrowReporter.report(value);\n}\n/**\n * Decode/validate like codec.decode, but throw or return right instead of Either\n *\n * @param codec - io-ts codec to be used for decoding/validation\n * @param data - data to decode/validate\n * @returns Decoded value of codec type\n */\nexport function decode(codec, data) {\n    const decoded = codec.decode(data);\n    reporterAssert(decoded);\n    return decoded.right;\n}\n/**\n * Test for value's non-nulliness\n * Like lodash's negate(isNil), but also works as type guard (e.g. useful for filters)\n *\n * @param value - to be tested\n * @returns true if value is not null nor undefined\n */\nexport function isntNil(value) {\n    return value != null;\n}\n/**\n * Codec of ethers.utils.BigNumber objects\n *\n * Input can be anything bigNumberify-able: number, string, LosslessNumber or BigNumber\n * Output is string, so we can JSON-serialize with 'number's types bigger than JS VM limits\n * of 2^53, as Raiden python client stdlib json encode longs as string.\n */\nexport const BigNumberC = new t.Type('BigNumber', BigNumber.isBigNumber, (u, c) => {\n    var _a, _b;\n    if (BigNumber.isBigNumber(u))\n        return t.success(u);\n    try {\n        // decode by trying to bigNumberify string representation of anything\n        return t.success(bigNumberify(((_b = (_a = u) === null || _a === void 0 ? void 0 : _a._hex) !== null && _b !== void 0 ? _b : u).toString()));\n    }\n    catch (err) {\n        return t.failure(u, c);\n    }\n}, (a) => a.toString());\n/**\n * Helper function to create codecs to validate an arbitrary or variable-sized hex bytestring\n * A branded codec to indicate validated hex-strings\n *\n * @param size - Required number of bytes. Pass undefined or zero to have a variable-sized type\n * @returns branded codec for hex-encoded bytestrings\n */\nexport const HexString = memoize(function (size) {\n    return t.brand(t.string, (n) => typeof n === 'string' && (size ? hexDataLength(n) === size : isHexString(n)), 'HexString');\n});\n/**\n * Helper function to create codecs to validate an arbitrary or variable-sized BigNumbers\n * A branded codec/type to indicate size-validated BigNumbers\n *\n * @param size - Required number of bytes. Pass undefined to have a variable-sized type\n * @returns branded codec for hex-encoded bytestrings\n */\nexport const Int = memoize(function (size) {\n    const min = size ? Zero.sub(Two.pow(size * 8 - 1)) : undefined, max = size ? Two.pow(size * 8 - 1) : undefined;\n    return t.brand(BigNumberC, (n) => BigNumberC.is(n) && (!min || !max || (n.gte(min) && n.lt(max))), 'Int');\n});\n/**\n * Helper function to create codecs to validate an arbitrary or variable-sized BigNumbers\n * A branded codec/type to indicate size-validated BigNumbers\n *\n * @param size - Required number of bytes. Pass undefined to have a variable-sized type\n * @returns branded codec for hex-encoded bytestrings\n */\nexport const UInt = memoize(function (size) {\n    const min = size ? Zero : undefined, max = size ? Two.pow(size * 8) : undefined;\n    return t.brand(BigNumberC, (n) => BigNumberC.is(n) && (!min || !max || (n.gte(min) && n.lt(max))), 'UInt');\n});\n// specific types\n// strig brand: ECDSA signature as an hex-string\nexport const Signature = HexString(65);\n// string brand: 256-bit hash, usually keccak256 or sha256\nexport const Hash = HexString(32);\n// string brand: a secret bytearray, 32 bytes\nexport const Secret = HexString(32);\n// string brand: ECDSA private key, 32 bytes\nexport const PrivateKey = HexString(32);\nexport const Address = new t.Type('Address', (u) => {\n    try {\n        return HexString(20).is(u) && getAddress(u) === u;\n    }\n    catch (e) {\n        return false;\n    }\n}, (u, c) => {\n    if (!HexString(20).is(u))\n        return t.failure(u, c);\n    let addr;\n    try {\n        addr = getAddress(u);\n    }\n    catch (e) {\n        return t.failure(u, c);\n    }\n    if (!addr)\n        return t.failure(u, c);\n    return t.success(addr);\n}, t.identity);\n/**\n * Helper function to create codecs to validate [timestamp, value] tuples\n *\n * @param codec - Codec to compose with a timestamp in a tuple\n * @returns Codec of a tuple of timestamp and codec type\n */\nexport const Timed = memoize((codec) => t.tuple([t.number, codec]));\n/**\n * Given a value of type T, returns a Timed<T> tuple with current time as first value\n *\n * @param v - Value to return with time\n * @returns Tuple of call timestamp as first elemtn and value passed as parameter as second\n */\nexport function timed(v) {\n    return [Date.now(), v];\n}\n// generic type codec for messages that must be signed\n// use it like: Codec = Signed(Message)\n// The t.TypeOf<typeof codec> will be Signed<Message>, defined later\nexport const Signed = memoize((codec) => t.intersection([codec, t.readonly(t.type({ signature: Signature }))]));\n/**\n * Memoized factory to create codecs validating an arbitrary class C\n *\n * @param C - Class to create a codec for\n * @returns Codec validating class C\n */\nexport const instanceOf = memoize((C) => new t.Type(`instanceOf(${C.name})`, (v) => v instanceof C, (i, c) => (i instanceof C ? t.success(i) : t.failure(i, c)), t.identity));\n//# sourceMappingURL=types.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getNetwork as parseNetwork } from 'ethers/utils/networks';\nimport { fromEventPattern, merge, from, of, EMPTY, combineLatest, defer } from 'rxjs';\nimport { filter, first, map, switchMap, mergeMap, share } from 'rxjs/operators';\nimport flatten from 'lodash/flatten';\nimport sortBy from 'lodash/sortBy';\nimport { isntNil } from './types';\n/**\n * Like rxjs' fromEvent, but event can be an EventFilter\n *\n * @param target - Object to hook event listener, maybe a Provider or Contract\n * @param event - EventFilter or string representing the event to listen to\n * @param resultSelector - A map of events arguments to output parameters\n *      Default is to pass only first parameter\n * @returns Observable of target.on(event) events\n */\nexport function fromEthersEvent(target, event, resultSelector) {\n    return fromEventPattern((handler) => target.on(event, handler), (handler) => target.removeListener(event, handler), resultSelector);\n}\n/**\n * getEventsStream returns a stream of T-type tuples (arrays) from Contract's\n * events from filters. These events are polled since provider's [re]setEventsBlock to newest\n * polled block. If both 'fromBlock$' and 'lastSeenBlock$' are specified, also fetch past events\n * since fromBlock up to lastSeenBlock$ === provider.resetEventsBlock - 1\n * T must be a tuple-like type receiving all filters arguments plus the respective Event in the end\n *\n * @param contract - Contract source instance for filters, connected to a provider\n * @param filters - array of OR filters from tokenNetwork\n * @param fromBlock$ - Observable of a past blockNumber since when to fetch past events\n *                     If not provided, last resetEventsBlock is automatically used.\n * @returns Observable of contract's events\n */\nexport function getEventsStream(contract, filters, fromBlock$) {\n    const provider = contract.provider;\n    const logToEvent = (log) => {\n        // parse log into [...args, event: Event] array,\n        // the same that contract.on events/callbacks\n        const parsed = contract.interface.parseLog(log);\n        // ignore removed (reorg'd) events (reorgs are handled by ConfirmableActions logic)\n        // and parse errors (shouldn't happen)\n        if (log.removed === true || !parsed)\n            return;\n        const args = Array.prototype.slice.call(parsed.values);\n        // not all parameters quite needed right now, but let's comply with the interface\n        const event = Object.assign(Object.assign(Object.assign({}, log), parsed), { args, removeListener: () => {\n                /* getLogs don't install filter */\n            }, getBlock: () => provider.getBlock(log.blockHash), getTransaction: () => provider.getTransaction(log.transactionHash), getTransactionReceipt: () => provider.getTransactionReceipt(log.transactionHash), decode: (data, topics) => parsed.decode(data, topics || log.topics) });\n        return [...args, event];\n    };\n    // past events (in the closed-interval=[fromBlock, lastSeenBlock]),\n    // fetch once, sort by blockNumber, emit all, complete\n    let pastEvents$ = EMPTY, \n    // of(constant) ensures newEvents$ is registered immediately if fromBlock$ not provided\n    nextBlock$ = of(-1);\n    if (fromBlock$) {\n        // if fetching pastEvents$, nextBlock$ is used to sync/avoid intersection between Events$\n        // pastEvents$ => [fromBlock$, nextBlock$], newEvents$ => ]nextBlock$, ...latest]\n        nextBlock$ = defer(() => provider.blockNumber\n            ? of(provider.blockNumber)\n            : fromEthersEvent(provider, 'block').pipe(first(), map((b) => { var _a; return (_a = provider.blockNumber) !== null && _a !== void 0 ? _a : b; }))).pipe(share());\n        pastEvents$ = combineLatest(fromBlock$, nextBlock$).pipe(first(), switchMap(([fromBlock, toBlock]) => Promise.all(filters.map((filter) => provider.getLogs(Object.assign(Object.assign({}, filter), { fromBlock, toBlock }))))), \n        // flatten array of each getLogs query response and sort them\n        // emit log array elements as separate logs into stream (unwind)\n        mergeMap((logs) => from(sortBy(flatten(logs), ['blockNumber']))), map(logToEvent), filter(isntNil));\n    }\n    // new events (in open-interval=]lastSeenBlock, latest])\n    // where lastSeenBlock is the currentBlock at call time\n    // doesn't complete, keep emitting events for each new block (if any) until unsubscription\n    const newEvents$ = nextBlock$.pipe(switchMap(() => from(filters)), mergeMap((filter) => fromEthersEvent(provider, filter)), map(logToEvent), filter(isntNil));\n    return merge(pastEvents$, newEvents$);\n}\n/**\n * Like Provider.getNetwork, but fetches every time instead of using cached property\n *\n * @param provider - Provider to fetch data from\n * @returns Promise of Network info\n */\nexport function getNetwork(provider) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return parseNetwork(parseInt(yield provider.send('net_version', [])));\n    });\n}\n/**\n * Patch JsonRpcProvider.send to try personal_sign first, and fallback to eth_sign if it fails\n * Call it once on the provider instance\n *\n * @param provider - A JsonRpcProvider instance to patch\n */\nexport function patchSignSend(provider) {\n    const origSend = provider.send;\n    provider.send = function (method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (method === 'eth_sign') {\n                // try 'personal_sign' by default instead of 'eth_sign'\n                return origSend.apply(this, ['personal_sign', [params[1], params[0]]]).catch((err) => {\n                    // on first error, if personal_sign isn't available\n                    if (err instanceof Error &&\n                        (err.message.includes('The method personal_sign does not exist') ||\n                            err.message.includes('Method personal_sign not supported'))) {\n                        provider.send = origSend; // un-patch\n                        return provider.send(method, params); // and retry with eth_sign\n                    }\n                    throw err; // else, re-raise\n                });\n            }\n            return origSend.apply(this, [method, params]);\n        });\n    };\n}\n/**\n * Return a network name, if known, or stringified chainId otherwise\n *\n * @param network - Network to get name from\n * @returns name or chainId as string\n */\nexport function getNetworkName(network) {\n    return network.name !== 'unknown' ? network.name : network.chainId.toString();\n}\n//# sourceMappingURL=ethers.js.map","import * as t from 'io-ts';\nimport { Capabilities } from './constants';\nimport { Address } from './utils/types';\nimport { getNetworkName } from './utils/ethers';\nconst RTCIceServer = t.type({ urls: t.union([t.string, t.array(t.string)]) });\n/**\n * A Raiden configuration object with required and optional params from [[PartialRaidenConfig]].\n *\n * Notice partial/undefined values are special: when a raidenConfigUpdate is called with an\n * undefined value, it won't be set, as they can't be [re]stored in the JSON state, but instead\n * means it'll be *reset* to the default value; therefore, if a partial value has a defined\n * default, it can't be unset; if you want to support \"empty\" values, use null, empty string or\n * other falsy serializable types, and/or ensure it never gets a default\n *\n * - matrixServerLookup - Matrix server URL to fetch existing matrix servers from.\n *      After intializing a [[Raiden]] instance, the matrix server can't be changed later on.\n * - revealTimeout - Timeout for secrets to be revealed\n * - settleTimeout - Timeout for channels to be settled\n * - httpTimeout - Used in http fetch requests\n * - discoveryRoom - Discovery Room to auto-join, use null to disable\n * - pfsRoom - PFS Room to auto-join and send PFSCapacityUpdate to, use null to disable\n * - pfs - Path Finding Service URL or Address. Set to null to disable, or empty string to enable\n *         automatic fetching from ServiceRegistry.\n * - pfsSafetyMargin - Safety margin to be added to fees received from PFS. Use `1.1` to add a 10%\n *                     safety margin.\n * - matrixExcessRooms - Keep this much rooms for a single user of interest (partner, target).\n *                       Leave LRU beyond this threshold.\n * - confirmationBlocks - How many blocks to wait before considering a transaction as confirmed\n * - logger - String specifying the console log level of redux-logger. Use '' to silence.\n * - caps - Own transport capabilities\n * - matrixServer? - Specify a matrix server to use.\n * - subkey? - When using subkey, this sets the behavior when { subkey } option isn't explicitly\n *             set in on-chain method calls. false (default) = use main key; true = use subkey\n */\nexport const RaidenConfig = t.readonly(t.intersection([\n    t.type({\n        matrixServerLookup: t.string,\n        revealTimeout: t.number,\n        settleTimeout: t.number,\n        httpTimeout: t.number,\n        discoveryRoom: t.union([t.string, t.null]),\n        pfsRoom: t.union([t.string, t.null]),\n        pfs: t.union([Address, t.string, t.null]),\n        pfsSafetyMargin: t.number,\n        matrixExcessRooms: t.number,\n        confirmationBlocks: t.number,\n        logger: t.keyof({\n            ['']: null,\n            trace: null,\n            debug: null,\n            info: null,\n            warn: null,\n            error: null,\n        }),\n        caps: t.readonly(t.record(t.string /* Capabilities */, t.any)),\n        fallbackIceServers: t.array(RTCIceServer),\n    }),\n    t.partial({\n        matrixServer: t.string,\n        subkey: t.boolean,\n    }),\n]));\nexport const PartialRaidenConfig = t.readonly(t.partial(Object.assign(Object.assign({}, RaidenConfig.type.types['0'].props), RaidenConfig.type.types['1'].props)));\n/**\n * Create a RaidenConfig from some common options\n *\n * @param obj - Object containing common parameters for config\n * @param obj.network - ether's Network object for the current blockchain\n * @param overwrites - Overwrites values from default config\n * @returns A full config object\n */\nexport function makeDefaultConfig({ network }, overwrites) {\n    return Object.assign({ matrixServerLookup: 'https://raw.githubusercontent.com/raiden-network/raiden-transport/master/known_servers.test.yaml', settleTimeout: 500, revealTimeout: 50, httpTimeout: 30e3, discoveryRoom: `raiden_${getNetworkName(network)}_discovery`, pfsRoom: `raiden_${getNetworkName(network)}_path_finding`, pfs: '', matrixExcessRooms: 3, pfsSafetyMargin: 1.0, confirmationBlocks: 5, logger: 'info', caps: {\n            [Capabilities.NO_DELIVERY]: true,\n            [Capabilities.NO_RECEIVE]: true,\n            [Capabilities.NO_MEDIATE]: true,\n            [Capabilities.WEBRTC]: true,\n        }, fallbackIceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }, overwrites);\n}\n//# sourceMappingURL=config.js.map","import * as t from 'io-ts';\nimport { map } from 'fp-ts/lib/Either';\nimport { pipe } from 'fp-ts/lib/pipeable';\nimport findKey from 'lodash/findKey';\nexport var ErrorCodes;\n(function (ErrorCodes) {\n    // Path errors\n    ErrorCodes[\"PFS_EMPTY_URL\"] = \"A registered Pathfinding Service returned an empty service URL.\";\n    ErrorCodes[\"PFS_INVALID_URL\"] = \"A registered Pathfinding Service returned an invalid service URL.\";\n    ErrorCodes[\"PFS_INVALID_INFO\"] = \"Could not find any valid Pathfinding service. Client and PFS versions are possibly out-of-sync.\";\n    ErrorCodes[\"PFS_NO_ROUTES_FOUND\"] = \"No valid routes found.\";\n    ErrorCodes[\"PFS_ERROR_RESPONSE\"] = \"Pathfinding Service request returned an error\";\n    ErrorCodes[\"PFS_DISABLED\"] = \"Pathfinding Service is disabled and no direct route is available.\";\n    ErrorCodes[\"PFS_UNKNOWN_TOKEN_NETWORK\"] = \"No open channels on this token network.\";\n    ErrorCodes[\"PFS_TARGET_OFFLINE\"] = \"The requested target is offline.\";\n    ErrorCodes[\"PFS_TARGET_NO_RECEIVE\"] = \"The requested target doesn't receive transfers.\";\n    ErrorCodes[\"PFS_LAST_IOU_REQUEST_FAILED\"] = \"The request for the last IOU has failed.\";\n    ErrorCodes[\"PFS_IOU_SIGNATURE_MISMATCH\"] = \"The signature of the last IOU did not match.\";\n    ErrorCodes[\"PFS_NO_ROUTES_BETWEEN_NODES\"] = \"No route between nodes found.\";\n    // Channel errors\n    ErrorCodes[\"CNL_INVALID_STATE\"] = \"Invalid channel state.\";\n    ErrorCodes[\"CNL_TOKEN_NOT_FOUND\"] = \"Could not find token for token network.\";\n    ErrorCodes[\"CNL_NO_OPEN_CHANNEL_FOUND\"] = \"No open channel has been found.\";\n    ErrorCodes[\"CNL_NO_OPEN_OR_CLOSING_CHANNEL_FOUND\"] = \"No open or closing channel has been found.\";\n    ErrorCodes[\"CNL_NO_SETTLEABLE_OR_SETTLING_CHANNEL_FOUND\"] = \"No settleable or settling channel has been found.\";\n    ErrorCodes[\"CNL_APPROVE_TRANSACTION_FAILED\"] = \"Token approve transaction failed.\";\n    ErrorCodes[\"CNL_OPENCHANNEL_FAILED\"] = \"Token networks openChannel transaction failed.\";\n    ErrorCodes[\"CNL_SETTOTALDEPOSIT_FAILED\"] = \"Token networks setTotalDeposit transaction failed.\";\n    ErrorCodes[\"CNL_CLOSECHANNEL_FAILED\"] = \"Token networks closeChannel transaction failed.\";\n    ErrorCodes[\"CNL_SETTLECHANNEL_FAILED\"] = \"Token networks settleChannel transaction failed.\";\n    ErrorCodes[\"CNL_UPDATE_NONCLOSING_BP_FAILED\"] = \"updateNonClosingBalanceProof transaction failed.\";\n    ErrorCodes[\"CNL_ONCHAIN_UNLOCK_FAILED\"] = \"on-chain unlock transaction failed.\";\n    // Transfer errors\n    ErrorCodes[\"XFER_EXPIRED\"] = \"Transfer expired.\";\n    ErrorCodes[\"XFER_CHANNEL_CLOSED_PREMATURELY\"] = \"Channel was closed before secret got reveiled or transfer unlocked.\";\n    ErrorCodes[\"XFER_REFUNDED\"] = \"Transfer has been refunded.\";\n    ErrorCodes[\"XFER_INVALID_SECRETREQUEST\"] = \"Invalid SecretRequest received\";\n    ErrorCodes[\"XFER_ALREADY_COMPLETED\"] = \"Not waiting for transfer, it's already completed.\";\n    ErrorCodes[\"XFER_REGISTERSECRET_TX_FAILED\"] = \"SecretRegistry.registerSecret transaction failed\";\n    // Transport errors\n    ErrorCodes[\"TRNS_NO_MATRIX_SERVERS\"] = \"Could not contact any Matrix servers.\";\n    ErrorCodes[\"TRNS_NO_VALID_USER\"] = \"Could not find a user with a valid signature.\";\n    ErrorCodes[\"TRNS_NO_SERVERNAME\"] = \"Could not get server name from Matrix server.\";\n    ErrorCodes[\"TRNS_MESSAGE_SIGNATURE_MISMATCH\"] = \"Unable to decode message due to signature mismatch.\";\n    // Raiden main class errors\n    ErrorCodes[\"RDN_GENERAL_ERROR\"] = \"An unknown error occured.\";\n    ErrorCodes[\"RDN_MINT_FAILED\"] = \"Failed to mint tokens.\";\n    ErrorCodes[\"RDN_APPROVE_TRANSACTION_FAILED\"] = \"Approve transaction has failed.\";\n    ErrorCodes[\"RDN_DEPOSIT_TRANSACTION_FAILED\"] = \"Deposit transaction has failed.\";\n    ErrorCodes[\"RDN_TRANSFER_ONCHAIN_BALANCE_FAILED\"] = \"Failed to transfer on-chain balance.\";\n    ErrorCodes[\"RDN_TRANSFER_ONCHAIN_TOKENS_FAILED\"] = \"Failed to transfer on-chain tokens.\";\n    ErrorCodes[\"RDN_UNRECOGNIZED_NETWORK\"] = \"No deploy info provided nor recognized network.\";\n    ErrorCodes[\"RDN_SIGNER_NOT_CONNECTED\"] = \"The signing account is not connected to the provider.\";\n    ErrorCodes[\"RDN_ACCOUNT_NOT_FOUND\"] = \"Account not found in provider.\";\n    ErrorCodes[\"RDN_STRING_ACCOUNT_INVALID\"] = \"String account must be either a 0x-encoded address or private key.\";\n    ErrorCodes[\"RDN_TRANSACTION_REORG\"] = \"Transaction has been mined but got removed by a reorg.\";\n    ErrorCodes[\"RDN_STATE_MIGRATION\"] = \"Could not replace stored state with older, provided state.\";\n    // Data errors\n    ErrorCodes[\"DTA_NEGATIVE_NUMBER\"] = \"Encountered negative number while encoding to HEX string.\";\n    ErrorCodes[\"DTA_NUMBER_TOO_LARGE\"] = \"Encountered a number that is too large to be encoded.\";\n    ErrorCodes[\"DTA_ARRAY_LENGTH_DIFFRENCE\"] = \"Expected length of HEX string differs from integer array input.\";\n    ErrorCodes[\"DTA_UNENCODABLE_DATA\"] = \"Passed data is not a HEX string nor integer array.\";\n})(ErrorCodes || (ErrorCodes = {}));\nexport const ErrorDetails = t.record(t.string, t.union([t.string, t.number, t.boolean, t.null]));\nexport class RaidenError extends Error {\n    constructor(message, details = {}) {\n        super(message !== null && message !== void 0 ? message : ErrorCodes.RDN_GENERAL_ERROR);\n        this.details = details;\n        this.name = 'RaidenError';\n        this._code = undefined;\n        Object.setPrototypeOf(this, RaidenError.prototype);\n    }\n    get code() {\n        var _a;\n        // to need to search for _code before first access\n        if (this._code === undefined)\n            this._code = (_a = findKey(ErrorCodes, (message) => message === this.message)) !== null && _a !== void 0 ? _a : 'RDN_GENERAL_ERROR';\n        return this._code;\n    }\n}\nconst serializedErr = t.intersection([\n    t.type({ name: t.string }),\n    t.partial({ message: t.string, stack: t.string, details: ErrorDetails }),\n]);\n/**\n * Simple Error codec\n *\n * This codec doesn't decode to an instance of the exact same error class object, but instead to\n * a generic Error, but assigning 'name', 'stack' & 'message' properties, more as an informative\n * object.\n */\nexport const ErrorCodec = new t.Type('Error', \n// if it quacks like a duck... without relying on instanceof\n(u) => typeof u === 'object' && !!u && 'name' in u && 'message' in u, (u) => pipe(serializedErr.decode(u), map((error) => {\n    if ('details' in error) {\n        return Object.assign(new RaidenError(error.message, error.details), {\n            name: error.name,\n            stack: error.stack,\n        });\n    }\n    else {\n        return Object.assign(new Error(error.message), { name: error.name, stack: error.stack });\n    }\n})), (error) => (Object.assign({ name: error.name, message: error.message, stack: error.stack }, ('details' in error ? { details: error.details } : {}))));\n//# sourceMappingURL=error.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/class-name-casing */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport * as t from 'io-ts';\nimport isMatchWith from 'lodash/isMatchWith';\nimport { first, map } from 'rxjs/operators';\nimport { RaidenError, ErrorCodes, ErrorCodec } from '../utils/error';\nimport { BigNumberC, assert } from './types';\n/**\n * Curried typeguard function (arity=2) which validates 2nd param is of type of some ActionCreators\n *\n * @param ac - Single or array of ActionCreators\n * @param args - if an object is passed, verify it, else returns a function which does\n * @returns boolean indicating object is of type of action, if passing 2nd argument,\n *      or typeguard function\n */\nexport function isActionOf(ac, ...args) {\n    const arr = Array.isArray(ac) ? ac : [ac];\n    function _isActionOf(action) {\n        return action != null && arr.some((a) => a.is(action));\n    }\n    if (args.length > 0)\n        return _isActionOf(args[0]);\n    return _isActionOf;\n}\n/**\n * Create a typesafe, serializable ActionCreator from type, payload codec, meta codec & error flag\n *\n * Pass undefined for indermediary arguments if they aren't needed\n * e.g. action with meta and without payload:\n *   const addTodo = createAction('ADD_TODO', undefined, t.type({ folder: t.string }));\n *\n * @param args - typesafe args tuple\n * @param args.0 - type literal string tag for action\n * @param args.1 - payload codec, optional\n * @param args.2 - meta codec, optional\n * @param args.3 - error flag, will only be present if defined (either false or true)\n * @returns ActionCreator factory function with useful properties. See [[ActionCreatorMembers]]\n */\nexport function createAction(...args) {\n    const [type, payloadC, metaC, error] = args;\n    // action codec\n    const codec = t.type(Object.assign(Object.assign(Object.assign({ type: t.literal(type) }, (payloadC ? { payload: payloadC } : null)), (metaC ? { meta: metaC } : null)), (error ? { error: t.literal(error) } : null)));\n    // member typeguard\n    // like codec.is, but on production, switches to more performant check of 'type' tag only\n    const is = process.env.NODE_ENV === 'development'\n        ? (action) => codec.is(action)\n        : (action) => { var _a; return ((_a = action) === null || _a === void 0 ? void 0 : _a['type']) === type; };\n    return Object.assign((payload, meta) => (Object.assign(Object.assign(Object.assign({ type }, (payloadC ? { payload } : null)), (metaC ? { meta } : null)), (error !== undefined ? { error } : null))), { codec, type, is }, error !== undefined ? { error } : null);\n}\n/**\n * Create a set of async actions\n *\n * Here, meta is first class citizen, as it's required and what links a request with its responses\n * (success or failure).\n * An 'isResponseOf' member function is provided which accepts 'meta' (e.g. from request) and\n * returns a type guard function/filter which returns true only if passed a respective deep-equal\n * 'meta' success|failure action.\n *\n * @param meta - Meta object common to these async actions\n * @param rtype - Request literal string tag\n * @param stype - Success literal string tag\n * @param ftype - Failure literal string tag\n * @param rpayload - Request payload codec\n * @param spayload - Success payload codec\n * @param args - Optional fpayload - Failure payload codec, defaults to ErrorCodec\n * @returns Async actions\n */\nexport function createAsyncAction(meta, rtype, stype, ftype, rpayload, spayload, ...args) {\n    const fpayload = args.length ? args[0] : ErrorCodec;\n    const request = createAction(rtype, rpayload, meta);\n    const success = createAction(stype, spayload, meta);\n    const failure = createAction(ftype, fpayload, meta, true);\n    return { request, success, failure };\n}\n/**\n * Match a passed meta with an action if returns true if metas are from corresponding actions\n *\n * curried (arity=2) for action passed as 2nd param.\n *\n * @param meta - meta base for comparison\n * @param args - curried args array\n * @param args.0 - action to test meta against the 1st param\n * @returns true if metas are compatible, false otherwise\n */\nfunction matchMeta(meta, ...args) {\n    const _match = (action) => \n    // like isEqual, but for BigNumbers, use .eq\n    isMatchWith(action.meta, meta, (objVal, othVal) => \n    // any is to avoid lodash's issue with undefined-returning isMatchWithCustomizer cb type\n    BigNumberC.is(objVal) && BigNumberC.is(othVal) ? objVal.eq(othVal) : undefined);\n    if (args.length)\n        return _match(args[0]);\n    return _match;\n}\n/**\n * Given an AsyncActionCreator and a respective 'meta' object, returns a type guard function for\n * responses actions (success|failure) matching given 'meta'\n *\n * This function receives 2-3 params. If it receives 2, it returns the type guard function, to be\n * used for filtering. Otherwise, it performs the check on the 3rd param.\n *\n * @param asyncAction - AsyncActionCreator object\n * @param meta - meta object to filter matching actions\n * @param args - curried last param\n * @returns type guard function to filter deep-equal meta success|failure actions\n */\nexport function isResponseOf(asyncAction, meta, ...args) {\n    const _isResponseOf = (action) => isActionOf([asyncAction.success, asyncAction.failure], action) && matchMeta(meta, action);\n    if (args.length)\n        return _isResponseOf(args[0]);\n    return _isResponseOf;\n}\n/**\n * Like isResponseOf, but ignores non-confirmed (or removed by a reorg) success action\n *\n * Confirmable success actions are emitted twice: first with payload.confirmed=undefined, then with\n * either confirmed=true, if tx still present after confirmation blocks, or confirmed=false, if tx\n * was removed from blockchain by a reorg.\n * This curied helper filter function ensures only one of the later causes a positive filter.\n *\n * @param asyncAction - AsyncActionCreator object\n * @param meta - meta object to filter matching actions\n * @param args - curried last param\n * @returns type guard function to filter deep-equal meta success|failure actions\n */\nexport function isConfirmationResponseOf(asyncAction, meta, ...args) {\n    function _isConfirmation(action) {\n        var _a, _b;\n        return typeof ((_b = (_a = action) === null || _a === void 0 ? void 0 : _a['payload']) === null || _b === void 0 ? void 0 : _b['confirmed']) === 'boolean';\n    }\n    const _isResponseOf = (action) => isResponseOf(asyncAction, meta, action) &&\n        (asyncAction.failure.is(action) || _isConfirmation(action));\n    if (args.length)\n        return _isResponseOf(args[0]);\n    return _isResponseOf;\n}\n/**\n * Watch a stream of actions and resolves on meta-matching success or rejects on failure\n *\n * @param asyncAction - async actions object to wait for\n * @param meta - meta object of a request to wait for the respective response\n * @param action$ - actions stream to watch for responses\n * @param confirmed - set if should ignore non-confirmed success response\n * @returns Promise which rejects with payload in case of failure, or resolves payload otherwise\n */\nexport function asyncActionToPromise(asyncAction, meta, action$, confirmed = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return action$\n            .pipe(first(confirmed\n            ? isConfirmationResponseOf(asyncAction, meta)\n            : isResponseOf(asyncAction, meta)), map((action) => {\n            if (asyncAction.failure.is(action))\n                throw action.payload;\n            else if (action.payload.confirmed === false)\n                throw new RaidenError(ErrorCodes.RDN_TRANSACTION_REORG, {\n                    transactionHash: action.payload.txHash,\n                });\n            return action.payload;\n        }))\n            .toPromise();\n    });\n}\n/**\n * Create a reducer which can be extended with additional actions handlers\n *\n * Usage:\n *   const reducer = createReducer(State)\n *      .handle(action, (s, a): State => ...)\n *      .handle(...)\n *      .handle(...);\n *\n * @param initialState - state for initialization (if no state is passed on reducer call)\n * @returns A reducer function, extended with a handle method to extend it\n */\nexport function createReducer(initialState) {\n    // make a reducer function for given handlers\n    function makeReducer(handlers) {\n        const reducer = (state = initialState, action) => {\n            if (action.type in handlers && handlers[action.type][0].is(action))\n                return handlers[action.type][1](state, action); // calls registered handler\n            return state; // fallback returns unchanged state\n        };\n        // circular dependency on generic params forbids an already handled action from being accepted\n        function handle(ac, handler) {\n            const arr = Array.isArray(ac) ? ac : [ac];\n            assert(!arr.some((a) => a.type in handlers), 'Already handled');\n            return makeReducer(Object.assign({}, handlers, ...arr.map((ac) => ({ [ac.type]: [ac, handler] }))));\n        }\n        // grow reducer function with our `handle` extender\n        return Object.assign(reducer, { handle });\n    }\n    // initially makes a reducer which doesn't handle anything (just returns unchanged state)\n    return makeReducer({});\n}\n//# sourceMappingURL=actions.js.map","import * as t from 'io-ts';\nimport { Address, Hash, Signature, UInt } from '../utils/types';\n// Represents a HashTime-Locked amount in a channel\nexport const Lock = t.type({\n    amount: UInt(32),\n    expiration: UInt(32),\n    secrethash: Hash,\n}, 'Lock');\n/**\n * Balance Proof constructed from an EnvelopeMessage\n * Either produced by us or received from the partner, the BPs are generated from the messages\n * because BP signature requires the hash of the message, for authentication of data not included\n * nor relevant for the smartcontract/BP itself, but so for the peers (e.g. payment_id)\n */\nexport const SignedBalanceProof = t.type({\n    // channel data\n    chainId: UInt(32),\n    tokenNetworkAddress: Address,\n    channelId: UInt(32),\n    // balance proof data\n    nonce: UInt(8),\n    transferredAmount: UInt(32),\n    lockedAmount: UInt(32),\n    locksroot: Hash,\n    messageHash: Hash,\n    signature: Signature,\n    sender: Address,\n});\n//# sourceMappingURL=types.js.map","/* istanbul ignore file */\n/* eslint-disable @typescript-eslint/camelcase */\n/**\n * These io-ts codecs validate and decode JSON Raiden messages\n * They include BigNumber strings validation, enum validation (if needed), Address checksum\n * validation, etc, and converting everything to its respective object, where needed.\n */\nimport * as t from 'io-ts';\nimport { Address, Hash, Secret, UInt, Int } from '../utils/types';\nimport { Lock } from '../channels/types';\n// types\nexport var MessageType;\n(function (MessageType) {\n    MessageType[\"DELIVERED\"] = \"Delivered\";\n    MessageType[\"PROCESSED\"] = \"Processed\";\n    MessageType[\"SECRET_REQUEST\"] = \"SecretRequest\";\n    MessageType[\"SECRET_REVEAL\"] = \"RevealSecret\";\n    MessageType[\"LOCKED_TRANSFER\"] = \"LockedTransfer\";\n    MessageType[\"REFUND_TRANSFER\"] = \"RefundTransfer\";\n    MessageType[\"UNLOCK\"] = \"Unlock\";\n    MessageType[\"LOCK_EXPIRED\"] = \"LockExpired\";\n    MessageType[\"WITHDRAW_REQUEST\"] = \"WithdrawRequest\";\n    MessageType[\"WITHDRAW_CONFIRMATION\"] = \"WithdrawConfirmation\";\n    MessageType[\"WITHDRAW_EXPIRED\"] = \"WithdrawExpired\";\n    MessageType[\"PFS_CAPACITY_UPDATE\"] = \"PFSCapacityUpdate\";\n    MessageType[\"PFS_FEE_UPDATE\"] = \"PFSFeeUpdate\";\n})(MessageType || (MessageType = {}));\n// Mixin of a message that contains an identifier and should be ack'ed with a respective Delivered\nconst RetrieableMessage = t.readonly(t.type({ message_identifier: UInt(8) }));\n// Acknowledges to the sender that a RetrieableMessage was received\nexport const Delivered = t.readonly(t.type({\n    type: t.literal(MessageType.DELIVERED),\n    delivered_message_identifier: UInt(8),\n}));\n// Confirms some message that required state validation was successfuly processed\nexport const Processed = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.PROCESSED),\n    }),\n    RetrieableMessage,\n]));\n// Requests the initiator to reveal the secret for a LockedTransfer targeted to us\nexport const SecretRequest = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.SECRET_REQUEST),\n        payment_identifier: UInt(8),\n        secrethash: Hash,\n        amount: UInt(32),\n        expiration: UInt(32),\n    }),\n    RetrieableMessage,\n]));\n// Reveal to the target or the previous hop a secret we just learned off-chain\nexport const SecretReveal = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.SECRET_REVEAL),\n        secret: Secret,\n    }),\n    RetrieableMessage,\n]));\n// Mixin for messages containing a balance proof\nexport const EnvelopeMessage = t.readonly(t.intersection([\n    t.type({\n        chain_id: UInt(32),\n        token_network_address: Address,\n        channel_identifier: UInt(32),\n        nonce: UInt(8),\n        transferred_amount: UInt(32),\n        locked_amount: UInt(32),\n        locksroot: Hash,\n    }),\n    RetrieableMessage,\n]));\nexport const RouteMetadata = t.readonly(t.type({\n    route: t.readonlyArray(Address),\n}));\nexport const Metadata = t.readonly(t.type({\n    routes: t.readonlyArray(RouteMetadata),\n}));\n// base for locked and refund transfer, they differentiate only on the type tag\nconst LockedTransferBase = t.readonly(t.intersection([\n    t.type({\n        payment_identifier: UInt(8),\n        token: Address,\n        recipient: Address,\n        lock: Lock,\n        target: Address,\n        initiator: Address,\n        metadata: Metadata,\n    }),\n    EnvelopeMessage,\n]));\n// a mediated transfer containing a locked amount\nexport const LockedTransfer = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.LOCKED_TRANSFER),\n    }),\n    LockedTransferBase,\n]));\n// if a mediated transfer didn't succeed, mediator can refund the amount with the same secrethash\n// so the previous hop can retry it with another neighbor\nexport const RefundTransfer = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.REFUND_TRANSFER),\n    }),\n    LockedTransferBase,\n]));\n// when the secret is revealed, unlock sends a new balance proof without the lock and increasing\n// the total transfered to finish the offchain transfer\nexport const Unlock = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.UNLOCK),\n        payment_identifier: UInt(8),\n        secret: Secret,\n    }),\n    EnvelopeMessage,\n]));\n// after mediated transfer fails and the lock expire, clean it from the locks tree\nexport const LockExpired = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.LOCK_EXPIRED),\n        recipient: Address,\n        secrethash: Hash,\n    }),\n    EnvelopeMessage,\n]));\nexport const WithdrawBase = t.readonly(t.type({\n    chain_id: UInt(32),\n    token_network_address: Address,\n    channel_identifier: UInt(32),\n    participant: Address,\n    total_withdraw: UInt(32),\n    nonce: UInt(8),\n    expiration: UInt(32),\n}));\nexport const WithdrawRequest = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.WITHDRAW_REQUEST),\n    }),\n    WithdrawBase,\n    RetrieableMessage,\n]));\nexport const WithdrawConfirmation = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.WITHDRAW_CONFIRMATION),\n    }),\n    WithdrawBase,\n    RetrieableMessage,\n]));\nexport const WithdrawExpired = t.readonly(t.intersection([\n    t.type({\n        type: t.literal(MessageType.WITHDRAW_EXPIRED),\n    }),\n    WithdrawBase,\n    RetrieableMessage,\n]));\nexport const PFSCapacityUpdate = t.readonly(t.type({\n    type: t.literal(MessageType.PFS_CAPACITY_UPDATE),\n    canonical_identifier: t.readonly(t.type({\n        chain_identifier: UInt(32),\n        token_network_address: Address,\n        channel_identifier: UInt(32),\n    })),\n    updating_participant: Address,\n    other_participant: Address,\n    updating_nonce: UInt(8),\n    other_nonce: UInt(8),\n    updating_capacity: UInt(32),\n    other_capacity: UInt(32),\n    reveal_timeout: UInt(32),\n}));\nexport const PFSFeeUpdate = t.readonly(t.type({\n    type: t.literal(MessageType.PFS_FEE_UPDATE),\n    canonical_identifier: t.readonly(t.type({\n        chain_identifier: UInt(32),\n        token_network_address: Address,\n        channel_identifier: UInt(32),\n    })),\n    updating_participant: Address,\n    timestamp: t.string,\n    fee_schedule: t.type({\n        cap_fees: t.boolean,\n        // if not null, it should be an array of [tokenAmount, fee] tuples\n        imbalance_penalty: t.union([t.null, t.array(t.tuple([UInt(32), Int(32)]))]),\n        proportional: Int(32),\n        flat: Int(32),\n    }),\n}));\nexport const Message = t.union([\n    Delivered,\n    Processed,\n    SecretRequest,\n    SecretReveal,\n    LockedTransfer,\n    RefundTransfer,\n    Unlock,\n    LockExpired,\n    WithdrawRequest,\n    WithdrawConfirmation,\n    WithdrawExpired,\n    PFSCapacityUpdate,\n    PFSFeeUpdate,\n]);\n//# sourceMappingURL=types.js.map","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/class-name-casing */\nimport * as t from 'io-ts';\nimport { createAction, createAsyncAction } from '../utils/actions';\nimport { Address, Hash, UInt } from '../utils/types';\nimport { Lock } from './types';\n// interfaces need to be exported, and we need/want to support `import * as RaidenActions`\nconst ChannelId = t.type({\n    tokenNetwork: Address,\n    partner: Address,\n});\n/* A new head in the blockchain is detected by provider */\nexport const newBlock = createAction('newBlock', t.type({ blockNumber: t.number }));\n/**\n * A new token network is detected in the TokenNetworkRegistry instance\n * fromBlock is only set on the first time, to fetch and handle past events\n */\nexport const tokenMonitored = createAction('tokenMonitored', t.intersection([\n    t.type({\n        token: Address,\n        tokenNetwork: Address,\n    }),\n    t.partial({\n        fromBlock: t.number,\n    }),\n]));\n/**\n * Channel actions receive ChannelId as 'meta' action property\n * This way, 'meta' can be used equally for request, success and error actions\n */\nexport const channelOpen = createAsyncAction(ChannelId, 'channel/open/request', 'channel/open/success', 'channel/open/failed', t.partial({ settleTimeout: t.number, subkey: t.boolean, deposit: UInt(32) }), t.type({\n    id: t.number,\n    settleTimeout: t.number,\n    isFirstParticipant: t.boolean,\n    txHash: Hash,\n    txBlock: t.number,\n    confirmed: t.union([t.undefined, t.boolean]),\n}));\n/* Channel with meta:ChannelId + payload.id should be monitored */\nexport const channelMonitor = createAction('channel/monitor', t.intersection([t.type({ id: t.number }), t.partial({ fromBlock: t.number })]), ChannelId);\nexport const channelDeposit = createAsyncAction(ChannelId, 'channel/deposit/request', 'channel/deposit/success', 'channel/deposit/failure', t.intersection([t.type({ deposit: UInt(32) }), t.partial({ subkey: t.boolean })]), t.type({\n    id: t.number,\n    participant: Address,\n    totalDeposit: UInt(32),\n    txHash: Hash,\n    txBlock: t.number,\n    confirmed: t.union([t.undefined, t.boolean]),\n}));\n/* A withdraw is detected on-chain */\nexport const channelWithdrawn = createAction('channel/withdraw/success', t.type({\n    id: t.number,\n    participant: Address,\n    totalWithdraw: UInt(32),\n    txHash: Hash,\n    txBlock: t.number,\n    confirmed: t.union([t.undefined, t.boolean]),\n}), ChannelId);\nexport const channelClose = createAsyncAction(ChannelId, 'channel/close/request', 'channel/close/success', 'channel/close/failure', t.union([t.partial({ subkey: t.boolean }), t.undefined]), t.type({\n    id: t.number,\n    participant: Address,\n    txHash: Hash,\n    txBlock: t.number,\n    confirmed: t.union([t.undefined, t.boolean]),\n}));\n/* A channel meta:ChannelId becomes settleable, starting from payload.settleableBlock */\nexport const channelSettleable = createAction('channel/settleable', t.type({ settleableBlock: t.number }), ChannelId);\nexport const channelSettle = createAsyncAction(ChannelId, 'channel/settle/request', 'channel/settle/success', 'channel/settle/failure', t.union([t.partial({ subkey: t.boolean }), t.undefined]), t.intersection([\n    t.type({\n        id: t.number,\n        txHash: Hash,\n        txBlock: t.number,\n        confirmed: t.union([t.undefined, t.boolean]),\n    }),\n    t.partial({ locks: t.readonlyArray(Lock) }),\n]));\n//# sourceMappingURL=actions.js.map","import * as t from 'io-ts';\nexport const RaidenMatrixSetup = t.readonly(t.type({\n    userId: t.string,\n    accessToken: t.string,\n    deviceId: t.string,\n    displayName: t.string,\n}));\n//# sourceMappingURL=state.js.map","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/class-name-casing */\nimport * as t from 'io-ts';\nimport { createAction, createAsyncAction } from '../utils/actions';\nimport { Address, instanceOf } from '../utils/types';\nimport { RaidenMatrixSetup } from './state';\nconst NodeId = t.type({ address: Address });\n/* MatrixClient instance is ready and logged in to payload.server with credentials payload.setup */\nexport const matrixSetup = createAction('matrixSetup', t.type({\n    server: t.string,\n    setup: RaidenMatrixSetup,\n}));\nexport const matrixPresence = createAsyncAction(NodeId, 'matrix/presence/request', 'matrix/presence/success', 'matrix/presence/failure', undefined, t.intersection([\n    t.type({ userId: t.string, available: t.boolean, ts: t.number }),\n    t.partial({ caps: t.record(t.string, t.any) }),\n]));\n/* payload.roomId must go front on meta.address's room queue */\nexport const matrixRoom = createAction('matrixRoom', t.type({ roomId: t.string }), NodeId);\n/* payload.roomId must be excluded from meta.address room queue, if present */\nexport const matrixRoomLeave = createAction('matrixRoomLeave', t.type({ roomId: t.string }), NodeId);\nexport const rtcChannel = createAction('rtcChannel', t.union([t.undefined, instanceOf(RTCDataChannel)]), NodeId);\n//# sourceMappingURL=actions.js.map","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/class-name-casing */\nimport * as t from 'io-ts';\nimport { createAction, createAsyncAction } from '../utils/actions';\nimport { Address, Signed } from '../utils/types';\nimport { Message } from './types';\n/** One-shot send payload.message to meta.address user in transport */\nexport const messageSend = createAsyncAction(t.type({ address: Address, msgId: t.string }), 'message/send/request', 'message/send/success', 'message/send/failure', t.type({ message: t.union([t.string, Signed(Message)]) }), undefined);\n/** One-shot send payload.message to a global room in transport */\nexport const messageGlobalSend = createAction('messageGlobalSend', t.type({ message: t.union([t.string, Signed(Message)]) }), t.type({ roomName: t.string }));\n/**\n * payload.message was received on payload.ts (timestamp) from meta.address\n * payload.userId and payload.roomId are optional and specific to matrix transport, as sender info\n */\nexport const messageReceived = createAction('messageReceived', t.intersection([\n    t.type({\n        text: t.string,\n        ts: t.number,\n    }),\n    t.partial({\n        message: t.union([Message, Signed(Message)]),\n        userId: t.string,\n        roomId: t.string,\n    }),\n]), t.type({ address: Address }));\n//# sourceMappingURL=actions.js.map","import * as t from 'io-ts';\nimport { Address, Int, Signed, UInt } from '../utils/types';\n/**\n * Codec for PFS API returned data\n */\nexport const PathResults = t.readonly(t.intersection([\n    t.type({\n        result: t.array(t.readonly(t.type({\n            path: t.readonlyArray(Address),\n            /* eslint-disable-next-line @typescript-eslint/camelcase */\n            estimated_fee: Int(32),\n        }))),\n    }),\n    t.partial({\n        /* eslint-disable-next-line @typescript-eslint/camelcase */\n        feedback_token: t.string,\n    }),\n]));\n/**\n * Codec for raiden-ts internal representation of a PFS result/routes\n */\nexport const Paths = t.array(t.readonly(t.type({\n    path: t.readonlyArray(Address),\n    fee: Int(32),\n})));\n/**\n * A PFS server/service instance info\n */\nexport const PFS = t.readonly(t.type({\n    address: Address,\n    url: t.string,\n    rtt: t.number,\n    price: UInt(32),\n    token: Address,\n}));\n/**\n * An IOU used to pay the services\n */\nexport const IOU = t.readonly(t.type({\n    sender: Address,\n    receiver: Address,\n    amount: UInt(32),\n    // eslint-disable-next-line @typescript-eslint/camelcase\n    expiration_block: UInt(32),\n    // eslint-disable-next-line @typescript-eslint/camelcase\n    one_to_n_address: Address,\n    // eslint-disable-next-line @typescript-eslint/camelcase\n    chain_id: UInt(32),\n}));\nexport const LastIOUResults = t.readonly(t.type({\n    // eslint-disable-next-line @typescript-eslint/camelcase\n    last_iou: Signed(IOU),\n}));\n//# sourceMappingURL=types.js.map","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/class-name-casing */\nimport * as t from 'io-ts';\nimport { Address, UInt, Int, Secret, Hash, Signed } from '../utils/types';\nimport { createAction, createAsyncAction } from '../utils/actions';\nimport { SignedBalanceProof } from '../channels/types';\nimport { LockedTransfer, Processed, SecretRequest, SecretReveal, Unlock, LockExpired, RefundTransfer, WithdrawRequest, WithdrawConfirmation, } from '../messages/types';\nimport { Paths } from '../services/types';\nconst TransferId = t.type({\n    secrethash: Hash,\n    direction: t.keyof({ sent: null, received: null }),\n});\n/**\n * A transfer async action set\n *\n * A transfer is considered as having succeeded from the time the secret is revealed to the target,\n * as from there, target and mediators can claim the payment down to us. But the full off-chain\n * happy case completes only after partner/neighbor acknowledges receiving the Unlock.\n * So, we usually only emits this action in the end of the happy case, and it'll then contain the\n * unlock's balanceProof, which indicates the full off-chain path succeeded.\n * It'll be emitted without a balanceProof if something forces the transfer to complete\n * (e.g.  channel closed), the secret was revealed (so target was paid) but for any reason the\n * unlock didn't happen yet.\n *\n * transfer.failure is emitted as soon as we know the transfer failed definitely, like when a\n * RefundTransfer is received or the lock expires before revealing the secret. It notifies the user\n * (e.g. pending Promises) that the transfer failed and won't be paid (eventually, locked amount\n * will be recovered by expiring the lock).\n */\nexport const transfer = createAsyncAction(TransferId, 'transfer/request', 'transfer/success', 'transfer/failure', t.intersection([\n    t.type({\n        tokenNetwork: Address,\n        target: Address,\n        value: UInt(32),\n        paths: Paths,\n        paymentId: UInt(8),\n    }),\n    t.partial({\n        secret: Secret,\n        expiration: t.number,\n        initiator: Address,\n    }),\n]), t.partial({ balanceProof: SignedBalanceProof }));\n/** A LockedTransfer was signed and should be sent to partner */\nexport const transferSigned = createAction('transferSigned', t.type({ message: Signed(LockedTransfer), fee: Int(32) }), TransferId);\n/** Partner acknowledge they received and processed our LockedTransfer */\nexport const transferProcessed = createAction('transferProcessed', t.type({ message: Signed(Processed) }), TransferId);\n/** Register a secret */\nexport const transferSecret = createAction('transferSecret', t.type({ secret: Secret }), TransferId);\nexport const transferSecretRegister = createAsyncAction(TransferId, 'transferSecret/register/request', 'transferSecret/register/success', 'transferSecret/register/failure', t.intersection([t.type({ secret: Secret }), t.partial({ subkey: t.boolean })]), t.type({\n    secret: Secret,\n    txHash: Hash,\n    txBlock: t.number,\n    // ConfirmableAction\n    confirmed: t.union([t.undefined, t.boolean]),\n}));\n/** A valid SecretRequest received from target */\nexport const transferSecretRequest = createAction('transferSecretRequest', t.type({ message: Signed(SecretRequest) }), TransferId);\n/** A SecretReveal sent to target */\nexport const transferSecretReveal = createAction('transferSecretReveal', t.type({ message: Signed(SecretReveal) }), TransferId);\nexport const transferUnlock = createAsyncAction(TransferId, 'transfer/unlock/request', 'transfer/unlock/success', 'transfer/unlock/failure', undefined, t.type({ message: Signed(Unlock) }));\n/** Partner acknowledge they received and processed our Unlock */\nexport const transferUnlockProcessed = createAction('transferUnlockProcessed', t.type({ message: Signed(Processed) }), TransferId);\n/**\n * A request to expire a given transfer\n *\n * A transfer expiration request may fail for any reason\n * e.g. user rejected sign promopt. It should eventually get prompted again, on a future newBlock\n * action which sees this transfer should be expired but sent.lockExpired didn't get set yet.\n */\nexport const transferExpire = createAsyncAction(TransferId, 'transfer/expire/request', 'transfer/expire/success', 'transfer/expire/failure', undefined, t.type({ message: Signed(LockExpired) }));\n/** Partner acknowledge they received and processed our LockExpired */\nexport const transferExpireProcessed = createAction('transferExpireProcessed', t.type({ message: Signed(Processed) }), TransferId);\n/** A transfer was refunded */\nexport const transferRefunded = createAction('transferRefunded', t.type({ message: Signed(RefundTransfer) }), TransferId);\n/** A pending transfer isn't needed anymore and should be cleared from state */\nexport const transferClear = createAction('transferClear', undefined, TransferId);\n// Withdraw actions\nconst WithdrawId = t.type({\n    tokenNetwork: Address,\n    partner: Address,\n    totalWithdraw: UInt(32),\n    expiration: t.number,\n});\n/** A WithdrawRequest was received from partner */\nexport const withdrawReceive = createAsyncAction(WithdrawId, 'withdraw/receive/request', 'withdraw/receive/success', 'withdraw/receive/failure', t.type({ message: Signed(WithdrawRequest) }), t.type({ message: Signed(WithdrawConfirmation) }));\n//# sourceMappingURL=actions.js.map","/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/class-name-casing */\nimport * as t from 'io-ts';\nimport { createAction, createAsyncAction } from '../utils/actions';\nimport { Address, UInt, Signed } from '../utils/types';\nimport { Paths, PFS, IOU } from './types';\nconst PathId = t.type({\n    tokenNetwork: Address,\n    target: Address,\n    value: UInt(32),\n});\nconst ServiceId = t.type({\n    tokenNetwork: Address,\n    serviceAddress: Address,\n});\nexport const pathFind = createAsyncAction(PathId, 'path/find/request', 'path/find/success', 'path/find/failure', t.partial({ paths: Paths, pfs: t.union([PFS, t.null]) }), t.type({ paths: Paths }));\nexport const pfsListUpdated = createAction('pfsListUpdated', t.type({ pfsList: t.readonlyArray(Address) }));\nexport const iouPersist = createAction('iouPersist', t.type({ iou: Signed(IOU) }), ServiceId);\nexport const iouClear = createAction('iouClear', undefined, ServiceId);\n//# sourceMappingURL=actions.js.map","/* eslint-disable @typescript-eslint/class-name-casing */\n/**\n * Aggregate types and exported properties from actions from all modules\n */\nimport * as t from 'io-ts';\nimport { ShutdownReason } from './constants';\nimport { PartialRaidenConfig } from './config';\nimport { createAction } from './utils/actions';\nimport { ErrorCodec } from './utils/error';\nimport * as ChannelsActions from './channels/actions';\nimport * as TransportActions from './transport/actions';\nimport * as MessagesActions from './messages/actions';\nimport * as TransfersActions from './transfers/actions';\nimport * as ServicesActions from './services/actions';\nexport const raidenShutdown = createAction('raidenShutdown', t.type({\n    reason: t.union([\n        t.literal(ShutdownReason.STOP),\n        t.literal(ShutdownReason.ACCOUNT_CHANGED),\n        t.literal(ShutdownReason.NETWORK_CHANGED),\n        ErrorCodec,\n    ]),\n}));\nexport const raidenConfigUpdate = createAction('raidenConfigUpdate', PartialRaidenConfig);\nconst RaidenActions = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ raidenShutdown,\n    raidenConfigUpdate }, ChannelsActions), TransportActions), MessagesActions), TransfersActions), ServicesActions);\n/* Mapping { [type: string]: Action } of a subset of RaidenActions exposed as events */\nexport const RaidenEvents = [\n    RaidenActions.raidenShutdown,\n    RaidenActions.newBlock,\n    RaidenActions.matrixPresence.success,\n    RaidenActions.tokenMonitored,\n];\n/**\n * Set of [serializable] actions which are first emitted with\n * payload.confirmed=undefined, then, after confirmation blocks, either with confirmed=true if tx\n * is still present on blockchain, or confirmed=false if it got removed by a reorg.\n *\n * These actions must comply with the following type:\n * {\n *   payload: {\n *     txHash: Hash;\n *     txBlock: number;\n *     confirmed: undefined | boolean;\n *   };\n *   meta: any;\n * }\n */\nexport const ConfirmableActions = [\n    ChannelsActions.channelOpen.success,\n    ChannelsActions.channelDeposit.success,\n    ChannelsActions.channelWithdrawn,\n    ChannelsActions.channelClose.success,\n    ChannelsActions.channelSettle.success,\n    TransfersActions.transferSecretRegister.success,\n];\n/**\n * Union of codecs of actions above\n */\nexport const ConfirmableAction = t.union([\n    ChannelsActions.channelOpen.success.codec,\n    ChannelsActions.channelDeposit.success.codec,\n    ChannelsActions.channelWithdrawn.codec,\n    ChannelsActions.channelClose.success.codec,\n    ChannelsActions.channelSettle.success.codec,\n    TransfersActions.transferSecretRegister.success.codec,\n]);\n//# sourceMappingURL=actions.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Migrate previous state to version 0\n *\n * @param state - RaidenState version -1\n * @returns State version 0\n */\nexport default function migrate0(state) {\n    return Object.assign(Object.assign({}, state), { version: 0 });\n}\n//# sourceMappingURL=0.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Move secrets to 'secret' member of the respective TransferState\n *\n * @param state - RaidenState version 0\n * @returns State version 1\n */\nexport default function migrate1(state) {\n    var _a, _b, _c;\n    const sent = state.sent;\n    for (const [h, t] of Object.entries(sent)) {\n        if (state.secrets[h]) {\n            Object.assign(t, {\n                secret: [\n                    (_b = (_a = t.secretReveal) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : t.transfer[0],\n                    { value: state.secrets[h].secret, registerBlock: (_c = state.secrets[h].registerBlock) !== null && _c !== void 0 ? _c : 0 },\n                ],\n            });\n        }\n    }\n    delete state['secrets'];\n    return state;\n}\n//# sourceMappingURL=1.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Adds: Channel.closeParticipant, TransferState.partner & RaidenState.received\n *\n * @param state - RaidenState version 1\n * @returns State version 2\n */\nexport default function migrate2(state) {\n    for (const partnerChannels of Object.values(state.channels)) {\n        for (const channel of Object.values(partnerChannels)) {\n            if (channel.closeBlock) {\n                // assume we were the ones closing the channel\n                Object.assign(channel, { closeParticipant: state.address });\n            }\n        }\n    }\n    const sent = state.sent;\n    for (const t of Object.values(sent)) {\n        Object.assign(t, { partner: t.transfer[1].recipient });\n    }\n    Object.assign(state, { received: {} });\n    return state;\n}\n//# sourceMappingURL=2.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport logging from 'loglevel';\nimport { assert } from '../utils/types';\nimport m0 from './0';\nimport m1 from './1';\nimport m2 from './2';\n// import above and populate this dict with new migrator functions\n// must be ordered, continuous, and last one MUST be state.CURRENT_STATE_VERSION\nconst migrations = { 0: m0, 1: m1, 2: m2 };\n/**\n * Migrate a RaidenState from any previous version to latest one\n *\n * @param state - Previous raiden state\n * @param toVersion - Migrate up to this version\n * @returns A current RaidenState (hopefully), to be validated\n */\nexport default function migrateState(state, toVersion, { log } = { log: logging }) {\n    var _a;\n    for (let v = 0; v <= toVersion; v++)\n        assert(v in migrations, `missing migration for ${v}`);\n    for (const [key, migrate] of Object.entries(migrations)) {\n        const version = +key;\n        if (((_a = state === null || state === void 0 ? void 0 : state.version) !== null && _a !== void 0 ? _a : -1) !== version - 1)\n            continue;\n        if (version > toVersion)\n            continue;\n        try {\n            state = Object.assign(migrate(state), { version });\n        }\n        catch (err) {\n            log.error(`Error migrating state from version ${version - 1} to ${version}`, state, err);\n            throw err;\n        }\n    }\n    // this must be validated as RaidenState, but is done in decodeRaidenState to avoid cyclic import\n    return state;\n}\n//# sourceMappingURL=index.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Zero, One, Two } from 'ethers/constants';\nimport { BigNumber, bigNumberify, toUtf8Bytes } from 'ethers/utils';\nimport { hexlify, isArrayish, hexZeroPad, hexDataLength, isHexString, } from 'ethers/utils/bytes';\nimport * as LosslessJSON from 'lossless-json';\nimport { BigNumberC } from './types';\nimport { RaidenError, ErrorCodes } from './error';\n/**\n * Encode data to hex string of exactly length size (in bytes)\n * Throw if data can't be made to fit in length.\n *\n * @param data - May be of multiple types:\n *      - number|BigNumber: Encoded in the big-endian byte-order and left-zero-padded to length\n *      - string: Must be hex-encoded string of length bytes\n *      - number[] Must be of exactly of length size (left/right-pad it before if needed)\n * @param length - The expected length of the hex string, in bytes\n * @returns HexString byte-array of length\n */\nexport function encode(data, length) {\n    let hex;\n    if (typeof data === 'boolean')\n        data = data ? One : Zero;\n    else if (typeof data === 'number')\n        data = bigNumberify(data);\n    if (typeof data === 'string' && !isHexString(data))\n        data = toUtf8Bytes(data);\n    if (isArrayish(data))\n        data = hexlify(data);\n    if (BigNumberC.is(data)) {\n        if (data.lt(0))\n            throw new RaidenError(ErrorCodes.DTA_NEGATIVE_NUMBER);\n        if (data.gte(Two.pow(length * 8)))\n            throw new RaidenError(ErrorCodes.DTA_NUMBER_TOO_LARGE);\n        hex = hexZeroPad(hexlify(data), length);\n    }\n    else if (typeof data === 'string') {\n        if (hexDataLength(data) !== length)\n            throw new RaidenError(ErrorCodes.DTA_ARRAY_LENGTH_DIFFRENCE);\n        hex = data;\n    }\n    else {\n        throw new RaidenError(ErrorCodes.DTA_UNENCODABLE_DATA);\n    }\n    return hex;\n}\nconst isLosslessNumber = (u) => \n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nu != null && u['isLosslessNumber'];\n/**\n * Opportunistic JSON.parse regarding numbers\n * If possible to decode a JSON number as JS number (i.e. value < 2^53) and return 'number',\n * otherwise returns BigNumber object\n * Throws if handled invalid JSON\n *\n * @param text - JSON string to parse\n * @returns Decoded object\n */\nexport function losslessParse(text) {\n    return LosslessJSON.parse(text, ({}, value) => {\n        if (isLosslessNumber(value)) {\n            try {\n                return value.valueOf(); // return number, if possible, or throw if > 2^53\n            }\n            catch (e) {\n                // else, convert early to BigNumber\n                return bigNumberify(value.toString());\n            }\n        }\n        return value;\n    });\n}\n/**\n * Stringify object losslessly, by converting BigNumbers to 'string's\n *\n * @param value - Object to be serialized as a string\n * @param replacer - Replacer function. Leave default to stringify BigNumbers\n * @param space - indentation spaces\n * @returns serialized representation of value\n */\nexport function losslessStringify(value, replacer = ({}, value) => BigNumber.isBigNumber(value) ? value.toString() : value, space) {\n    return LosslessJSON.stringify(value, replacer, space);\n}\n//# sourceMappingURL=data.js.map","import * as t from 'io-ts';\nimport { UInt, Address } from '../utils/types';\nimport { Lock, SignedBalanceProof } from './types';\nexport var ChannelState;\n(function (ChannelState) {\n    ChannelState[\"opening\"] = \"opening\";\n    ChannelState[\"open\"] = \"open\";\n    ChannelState[\"closing\"] = \"closing\";\n    ChannelState[\"closed\"] = \"closed\";\n    ChannelState[\"settleable\"] = \"settleable\";\n    ChannelState[\"settling\"] = \"settling\";\n    ChannelState[\"settled\"] = \"settled\";\n})(ChannelState || (ChannelState = {}));\n/**\n * Contains info of each side of a channel\n */\nexport const ChannelEnd = t.readonly(t.intersection([\n    t.type({\n        deposit: UInt(32),\n    }),\n    t.partial({\n        locks: t.readonlyArray(Lock),\n        balanceProof: SignedBalanceProof,\n        withdraw: UInt(32),\n    }),\n]));\nexport const Channel = t.intersection([\n    t.readonly(t.type({\n        own: ChannelEnd,\n        partner: ChannelEnd,\n    })),\n    t.union([\n        /* union of types with literals intersection allows narrowing other props presence. e.g.:\n         * if (channel.state === ChannelState.open) {\n         *   id = channel.id; // <- id can't be undefined\n         *   closeBlock = channel.closeBlock; // error: closeBlock only exist on states closed|settling\n         * }\n         */\n        t.readonly(t.type({ state: t.literal(ChannelState.opening) })),\n        t.readonly(t.type({\n            state: t.union([t.literal(ChannelState.open), t.literal(ChannelState.closing)]),\n            id: t.number,\n            settleTimeout: t.number,\n            openBlock: t.number,\n            isFirstParticipant: t.boolean,\n        })),\n        t.readonly(t.type({\n            state: t.union([\n                t.literal(ChannelState.closed),\n                t.literal(ChannelState.settleable),\n                t.literal(ChannelState.settling),\n            ]),\n            id: t.number,\n            settleTimeout: t.number,\n            openBlock: t.number,\n            isFirstParticipant: t.boolean,\n            closeBlock: t.number,\n            closeParticipant: Address,\n        })),\n    ]),\n]);\n//# sourceMappingURL=state.js.map","import * as t from 'io-ts';\nimport { LockedTransfer, Processed, SecretReveal, Unlock, LockExpired, RefundTransfer, SecretRequest, } from '../messages/types';\nimport { Address, Timed, Hash, Int, Signed, Secret } from '../utils/types';\nexport var Direction;\n(function (Direction) {\n    Direction[\"SENT\"] = \"sent\";\n    Direction[\"RECEIVED\"] = \"received\";\n})(Direction || (Direction = {}));\n/**\n * This struct holds the relevant messages exchanged in a transfer\n * The transfer state is defined by the exchanged messages\n */\nexport const TransferState = t.readonly(t.intersection([\n    t.type({\n        /** -> outgoing locked transfer */\n        transfer: Timed(Signed(LockedTransfer)),\n        fee: Int(32),\n        partner: Address,\n    }),\n    t.partial({\n        /**\n         * Transfer secret, if known\n         * registerBlock is 0 if not yet registered on-chain\n         * */\n        secret: Timed(t.type({ value: Secret, registerBlock: t.number })),\n        /** <- incoming processed for locked transfer */\n        transferProcessed: Timed(Signed(Processed)),\n        /**\n         * <- incoming refund transfer (if so)\n         * If this is set, transfer failed and partner tried refunding the transfer to us. We don't\n         * handle receiving transfers, but just store it here to mark this transfer as failed with a\n         * refund, until the lock expires normally\n         */\n        refund: Timed(Signed(RefundTransfer)),\n        /**\n         * !! channel was closed !!\n         * In the case a channel is closed (possibly middle transfer), this will be the txHash of the\n         * CloseChannel transaction. No further actions are possible after it's set.\n         */\n        channelClosed: Timed(Hash),\n        /**\n         * <- incoming secret request from target\n         * If this is set, it means the target requested the secret, not necessarily with a valid\n         * amount (an invalid amount < value == lock - fee, means transfer failed)\n         */\n        secretRequest: Timed(Signed(SecretRequest)),\n        /**\n         * -> outgoing secret reveal to target\n         * If this is set, it means the secret was revealed (so transfer succeeded, even if it didn't\n         * complete yet)\n         */\n        secretReveal: Timed(Signed(SecretReveal)),\n        /**\n         * -> outgoing unlock to recipient\n         * If this is set, it means the Unlock was sent (even if partner didn't acknowledge it yet)\n         */\n        unlock: Timed(Signed(Unlock)),\n        /**\n         * -> outgoing lock expired (if so)\n         * If this is set, transfer failed, and we expired the lock (retrieving the locked amount).\n         * Transfer failed may not have completed yet, e.g. waiting for LockExpired's Processed reply\n         */\n        lockExpired: Timed(Signed(LockExpired)),\n        /**\n         * <- incoming processed for Unlock message\n         * If this is set, the protocol completed by the transfer succeeding and partner\n         * acknowledging validity of our off-chain unlock\n         */\n        unlockProcessed: Timed(Signed(Processed)),\n        /**\n         * <- incoming processed for LockExpired message\n         * If this is set, the protocol completed by the transfer failing and partner acknowledging\n         * this transfer can't be claimed anymore\n         */\n        lockExpiredProcessed: Timed(Signed(Processed)),\n    }),\n]));\n/**\n * Mapping of outgoing transfers, indexed by the secrethash\n */\nexport const TransfersState = t.readonly(t.record(t.string /* secrethash: Hash */, TransferState));\nexport var RaidenTransferStatus;\n(function (RaidenTransferStatus) {\n    RaidenTransferStatus[\"pending\"] = \"PENDING\";\n    RaidenTransferStatus[\"received\"] = \"RECEIVED\";\n    RaidenTransferStatus[\"refunded\"] = \"REFUNDED\";\n    RaidenTransferStatus[\"closed\"] = \"CLOSED\";\n    RaidenTransferStatus[\"requested\"] = \"REQUESTED\";\n    RaidenTransferStatus[\"revealed\"] = \"REVEALED\";\n    RaidenTransferStatus[\"registered\"] = \"REGISTERED\";\n    RaidenTransferStatus[\"unlocking\"] = \"UNLOCKING\";\n    RaidenTransferStatus[\"expiring\"] = \"EXPIRING\";\n    RaidenTransferStatus[\"unlocked\"] = \"UNLOCKED\";\n    RaidenTransferStatus[\"expired\"] = \"EXPIRED\";\n})(RaidenTransferStatus || (RaidenTransferStatus = {}));\n//# sourceMappingURL=state.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/camelcase */\nimport * as t from 'io-ts';\nimport { AddressZero } from 'ethers/constants';\nimport { getNetwork } from 'ethers/utils';\nimport debounce from 'lodash/debounce';\nimport logging from 'loglevel';\nimport { PartialRaidenConfig, makeDefaultConfig } from './config';\nimport { ConfirmableAction } from './actions';\nimport migrateState from './migration';\nimport { losslessParse, losslessStringify } from './utils/data';\nimport { Address, Signed, decode } from './utils/types';\nimport { Channel } from './channels/state';\nimport { RaidenMatrixSetup } from './transport/state';\nimport { TransfersState } from './transfers/state';\nimport { IOU } from './services/types';\nimport { getNetworkName } from './utils/ethers';\nimport { RaidenError, ErrorCodes } from './utils/error';\n// same as highest migrator function in migration.index.migrators\nexport const CURRENT_STATE_VERSION = 2;\n// types\nexport const RaidenState = t.readonly(t.type({\n    address: Address,\n    version: t.literal(CURRENT_STATE_VERSION),\n    chainId: t.number,\n    registry: Address,\n    blockNumber: t.number,\n    config: PartialRaidenConfig,\n    channels: t.readonly(t.record(t.string /* tokenNetwork: Address */, t.readonly(t.record(t.string /* partner: Address */, Channel)))),\n    tokens: t.readonly(t.record(t.string /* token: Address */, Address)),\n    transport: t.readonly(t.partial({\n        matrix: t.readonly(t.intersection([\n            t.type({\n                server: t.string,\n            }),\n            t.partial({\n                setup: RaidenMatrixSetup,\n                rooms: t.readonly(t.record(t.string /* partner: Address */, t.array(t.string))),\n            }),\n        ])),\n    })),\n    sent: TransfersState,\n    received: TransfersState,\n    path: t.type({\n        iou: t.readonly(t.record(t.string /* tokenNetwork: Address */, t.record(t.string /* service: Address */, Signed(IOU)))),\n    }),\n    pendingTxs: t.readonlyArray(ConfirmableAction),\n}));\n// helpers, utils & constants\n/**\n * Encode RaidenState to a JSON string\n * For Raiden client compliance, this JSON encodes BigNumbers as 'number' (using lossless-json lib)\n * which is valid json though not very common as common JS implementations lose precision when\n * decoding through JSON.parse. This is solved in SDK by both encoding and decoding BigNumbers\n * using lossless-json, without going through the intermediary JS-number form.\n *\n * @param state - RaidenState object\n * @returns JSON encoded string\n */\nexport function encodeRaidenState(state) {\n    return losslessStringify(RaidenState.encode(state), undefined, 2);\n}\n/**\n * Try to migrate & decode data as RaidenState.\n * If handled a string, will parse it with lossless-json, to preserve BigNumbers encoded as JSON\n * 'number'. The data may be migrated from previous versions, then validated as current RaidenState\n *\n * @param data - string | any which may be decoded as RaidenState\n * @returns RaidenState parsed, migrated and validated\n */\nexport function decodeRaidenState(data, { log } = { log: logging }) {\n    if (typeof data === 'string')\n        data = losslessParse(data);\n    const state = migrateState(data, CURRENT_STATE_VERSION, { log });\n    // validates and returns as current state\n    try {\n        return decode(RaidenState, state);\n    }\n    catch (err) {\n        log.error(`Error validating migrated state version=${state === null || state === void 0 ? void 0 : state.version}`, state);\n        throw err;\n    }\n}\n/**\n * Create an initial RaidenState from common parameters (including default config)\n *\n * @param obj - Object containing common parameters for state\n * @param obj.network - ether's Network object for the current blockchain\n * @param obj.address - current account's address\n * @param overwrites - A partial object to overwrite top-level properties of the returned config\n * @returns A full config object\n */\nexport function makeInitialState({ network, address, contractsInfo, }, overwrites = {}) {\n    var _a;\n    return {\n        address,\n        version: CURRENT_STATE_VERSION,\n        chainId: network.chainId,\n        registry: contractsInfo.TokenNetworkRegistry.address,\n        blockNumber: contractsInfo.TokenNetworkRegistry.block_number,\n        config: (_a = overwrites.config) !== null && _a !== void 0 ? _a : {},\n        channels: {},\n        tokens: {},\n        transport: {},\n        sent: {},\n        received: {},\n        path: {\n            iou: {},\n        },\n        pendingTxs: [],\n    };\n}\n/**\n * state constant used as default state reducer parameter only.\n * To build an actual initial state at runtime, use [[makeInitialState]] instead.\n */\nexport const initialState = makeInitialState({\n    network: getNetwork('unspecified'),\n    address: AddressZero,\n    contractsInfo: {\n        TokenNetworkRegistry: { address: AddressZero, block_number: 0 },\n        ServiceRegistry: { address: AddressZero, block_number: 0 },\n        UserDeposit: { address: AddressZero, block_number: 0 },\n        SecretRegistry: { address: AddressZero, block_number: 0 },\n    },\n});\n/**\n * Checks whether `storageOrState` is [[Storage]]\n *\n * @param storage - either state or [[Storage]]\n * @returns true if storageOrState is [[Storage]]\n */\nconst isStorage = (storage) => storage && typeof storage.getItem === 'function';\n/**\n * Loads state from `storageOrState`. Returns the initial [[RaidenState]] if\n * `storageOrState` does not exist.\n *\n * @param network - current network\n * @param contracts - current contracts\n * @param address - current address of the signer\n * @param storageOrState - either [[Storage]] or [[RaidenState]] or\n *        { storage: [[Storage]]; state?: [[RaidenState]] }\n * @param config - raiden config\n * @returns true if storageOrState is [[Storage]]\n */\nexport const getState = (network, contracts, address, storageOrState, config) => __awaiter(void 0, void 0, void 0, function* () {\n    const log = logging.getLogger(`raiden:${address}`);\n    let onState;\n    let onStateComplete;\n    let storage;\n    let providedState;\n    if (isStorage(storageOrState)) {\n        // stateOrStorage is storage\n        storage = storageOrState;\n        providedState = undefined;\n    }\n    else if (isStorage(storageOrState === null || storageOrState === void 0 ? void 0 : storageOrState.storage)) {\n        // stateOrStorage is in the format { storage: Storage; state?: RaidenState | unknown }\n        storage = storageOrState.storage;\n        providedState = storageOrState.state;\n    }\n    else {\n        // stateOrStorage is state, no storage provided\n        storage = undefined;\n        providedState = storageOrState;\n    }\n    let state = undefined;\n    if (providedState) {\n        state = decodeRaidenState(providedState, { log });\n    }\n    if (storage) {\n        const ns = `raiden_${getNetworkName(network)}_${contracts.TokenNetworkRegistry.address}_${address}`;\n        const storedData = yield storage.getItem(ns);\n        if (storedData) {\n            const storedState = decodeRaidenState(storedData, { log });\n            if (state /* provided */) {\n                // if both stored & provided state, ensure we weren't handed an older one!\n                if (state.blockNumber < storedState.blockNumber) {\n                    throw new RaidenError(ErrorCodes.RDN_STATE_MIGRATION, {\n                        storedStateBlockNumber: storedState.blockNumber,\n                        providedStateBlockNumber: state.blockNumber,\n                    });\n                }\n                else {\n                    log.warn(`Replacing stored state @blockNumber=${storedState.blockNumber} with newer provided state @blockNumber=${state.blockNumber}`);\n                }\n            }\n            else {\n                // no provided state but there's a stored one, use it\n                state = storedState;\n            }\n        } // else, no stored state, initialize a new one below, if needed\n        // to be subscribed on raiden.state$\n        const debouncedState = debounce((state) => {\n            storage.setItem(ns, encodeRaidenState(state));\n        }, 1000, { maxWait: 5000 });\n        onState = debouncedState;\n        onStateComplete = () => debouncedState.flush();\n    }\n    // if no provided nor stored state, initialize a pristine one\n    if (!state)\n        state = makeInitialState({ network, address, contractsInfo: contracts });\n    const defaultConfig = makeDefaultConfig({ network }, config);\n    return { state, onState, onStateComplete, defaultConfig };\n});\n//# sourceMappingURL=state.js.map","/**\n * Like redux's combineReducers, but allows passing only a partial reducer mapping\n * redux's combineReducers output state must be exactly the mapping passed as parameter,\n * which doesn't allow to only provide a partial set of reducers and passthrough the other state's\n * keys. This function allows that, also preserving state/object reference when reducers don't\n * change state value.\n *\n * @param reducers - A mapping of a subset of state's key to nested reducers functions\n * @param initialState - global initial state, required when initializing first object with partial\n *                      reducers\n * @returns Full reducer for state S and actions A\n */\nexport function partialCombineReducers(reducers, initialState) {\n    return function (state = initialState, action) {\n        var _a;\n        for (const key in reducers) {\n            const reducer = reducers[key];\n            if (!reducer)\n                continue; // shouldn't happen, only here for type safety below\n            const subState = (_a = state[key]) !== null && _a !== void 0 ? _a : initialState[key];\n            const newSubState = reducer(subState, action);\n            if (newSubState !== subState) {\n                state = Object.assign(Object.assign({}, state), { [key]: newSubState });\n            }\n        }\n        return state;\n    };\n}\n//# sourceMappingURL=redux.js.map","import get from 'lodash/fp/get';\nimport set from 'lodash/fp/set';\nimport unset from 'lodash/fp/unset';\nimport getOr from 'lodash/fp/getOr';\nimport { Zero } from 'ethers/constants';\nimport { createReducer, isActionOf } from '../utils/actions';\nimport { partialCombineReducers } from '../utils/redux';\nimport { initialState } from '../state';\nimport { ConfirmableActions } from '../actions';\nimport { channelClose, channelDeposit, channelOpen, channelSettle, channelSettleable, newBlock, tokenMonitored, channelWithdrawn, } from './actions';\nimport { ChannelState } from './state';\n// state.blockNumber specific reducer, handles only newBlock action\nconst blockNumber = createReducer(initialState.blockNumber).handle(newBlock, ({}, { payload }) => payload.blockNumber);\n// state.tokens specific reducer, handles only tokenMonitored action\nconst tokens = createReducer(initialState.tokens).handle(tokenMonitored, (state, { payload: { token, tokenNetwork } }) => (Object.assign(Object.assign({}, state), { [token]: tokenNetwork })));\n// Reducers for different actions\nfunction channelOpenRequestReducer(state, action) {\n    const path = [action.meta.tokenNetwork, action.meta.partner];\n    if (get(path, state))\n        return state; // there's already a channel with partner\n    const channel = {\n        state: ChannelState.opening,\n        own: { deposit: Zero },\n        partner: { deposit: Zero },\n    };\n    return set(path, channel, state);\n}\nfunction channelOpenSuccessReducer(state, action) {\n    const path = [action.meta.tokenNetwork, action.meta.partner];\n    // ignore if older than currently set channel, or unconfirmed or removed\n    if (getOr(0, [...path, 'openBlock'], state) >= action.payload.txBlock ||\n        !action.payload.confirmed)\n        return state;\n    const channel = {\n        state: ChannelState.open,\n        own: { deposit: Zero },\n        partner: { deposit: Zero },\n        id: action.payload.id,\n        settleTimeout: action.payload.settleTimeout,\n        isFirstParticipant: action.payload.isFirstParticipant,\n        openBlock: action.payload.txBlock,\n    };\n    return set(path, channel, state);\n}\nfunction channelOpenFailureReducer(state, action) {\n    const path = [action.meta.tokenNetwork, action.meta.partner];\n    if (get([...path, 'state'], state) !== ChannelState.opening)\n        return state;\n    return unset(path, state);\n}\nfunction channelUpdateOnchainBalanceStateReducer(state, action) {\n    // ignore event if unconfirmed or removed\n    if (!action.payload.confirmed)\n        return state;\n    const path = [action.meta.tokenNetwork, action.meta.partner];\n    let channel = get(path, state);\n    if (!channel || channel.state !== ChannelState.open || channel.id !== action.payload.id)\n        return state;\n    const key = channelWithdrawn.is(action) ? 'withdraw' : 'deposit';\n    const total = channelWithdrawn.is(action)\n        ? action.payload.totalWithdraw\n        : action.payload.totalDeposit;\n    const isPartner = action.payload.participant === action.meta.partner;\n    const channelSide = isPartner ? 'partner' : 'own';\n    const channelEndData = isPartner ? channel.partner : channel.own;\n    channel = Object.assign(Object.assign({}, channel), { [channelSide]: Object.assign(Object.assign({}, channelEndData), { [key]: total }) });\n    return set(path, channel, state);\n}\nfunction channelCloseSuccessReducer(state, action) {\n    const path = [action.meta.tokenNetwork, action.meta.partner];\n    let channel = get(path, state);\n    if (!channel ||\n        !(channel.state === ChannelState.open || channel.state === ChannelState.closing) ||\n        channel.id !== action.payload.id)\n        return state;\n    // even on non-confirmed action, already set channel state as closing, so it can't be used for new transfers\n    if (action.payload.confirmed === undefined && channel.state === ChannelState.open)\n        channel = Object.assign(Object.assign({}, channel), { state: ChannelState.closing });\n    else if (action.payload.confirmed)\n        channel = Object.assign(Object.assign({}, channel), { state: ChannelState.closed, closeBlock: action.payload.txBlock, closeParticipant: action.payload.participant });\n    else\n        return state;\n    return set(path, channel, state);\n}\nfunction channelUpdateStateReducer(state, action) {\n    const path = [action.meta.tokenNetwork, action.meta.partner];\n    let channel = get(path, state);\n    if (!channel)\n        return state;\n    if (channelClose.request.is(action) && channel.state === ChannelState.open) {\n        channel = Object.assign(Object.assign({}, channel), { state: ChannelState.closing });\n    }\n    else if (channelSettle.request.is(action) && channel.state === ChannelState.settleable) {\n        channel = Object.assign(Object.assign({}, channel), { state: ChannelState.settling });\n    }\n    else if (channelSettleable.is(action) && channel.state === ChannelState.closed) {\n        channel = Object.assign(Object.assign({}, channel), { state: ChannelState.settleable });\n    }\n    else {\n        return state;\n    }\n    return set(path, channel, state);\n}\nfunction channelSettleSuccessReducer(state, action) {\n    const path = [action.meta.tokenNetwork, action.meta.partner];\n    const channel = get(path, state);\n    if (!channel ||\n        channel.state === ChannelState.opening ||\n        channel.state === ChannelState.open ||\n        channel.state === ChannelState.closing ||\n        channel.id !== action.payload.id)\n        return state;\n    // even on non-confirmed action, already set channel as settling\n    if (action.payload.confirmed === undefined && channel.state !== ChannelState.settling)\n        return set(path, Object.assign(Object.assign({}, channel), { state: ChannelState.settling }), state);\n    else if (action.payload.confirmed)\n        return unset(path, state);\n    else\n        return state;\n}\n// handles all channel actions and requests\nconst channels = createReducer(initialState.channels)\n    .handle(channelOpen.request, channelOpenRequestReducer)\n    .handle(channelOpen.success, channelOpenSuccessReducer)\n    .handle(channelOpen.failure, channelOpenFailureReducer)\n    .handle([channelDeposit.success, channelWithdrawn], channelUpdateOnchainBalanceStateReducer)\n    .handle([channelClose.request, channelSettleable, channelSettle.request], channelUpdateStateReducer)\n    .handle(channelClose.success, channelCloseSuccessReducer)\n    .handle(channelSettle.success, channelSettleSuccessReducer);\nconst pendingTxs = (state = initialState.pendingTxs, action) => {\n    // filter out non-ConfirmableActions's\n    if (!isActionOf(ConfirmableActions, action))\n        return state;\n    // if confirmed==undefined, add action to state\n    else if (action.payload.confirmed === undefined)\n        return [...state, action];\n    // else (either confirmed or removed), remove from state\n    else {\n        const newState = state.filter((a) => a.type !== action.type || action.payload.txHash !== a.payload.txHash);\n        if (newState.length !== state.length)\n            return newState;\n        return state;\n    }\n};\n/**\n * Nested/combined reducer for channels\n * blockNumber, tokens & channels reducers get its own slice of the state, corresponding to the\n * name of the reducer. channels root reducer instead must be handled the complete state instead,\n * so it compose the output with each key/nested/combined state.\n */\nconst channelsReducer = partialCombineReducers({ blockNumber, tokens, channels, pendingTxs }, initialState);\nexport default channelsReducer;\n//# sourceMappingURL=reducer.js.map","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport get from 'lodash/fp/get';\nimport getOr from 'lodash/fp/getOr';\nimport isEmpty from 'lodash/fp/isEmpty';\nimport set from 'lodash/fp/set';\nimport unset from 'lodash/fp/unset';\nimport { partialCombineReducers } from '../utils/redux';\nimport { createReducer } from '../utils/actions';\nimport { initialState } from '../state';\nimport { matrixSetup, matrixRoom, matrixRoomLeave } from './actions';\n/**\n * state.transport reducer\n * Handles all transport actions and requests\n *\n * @param state - Current RaidenState['transport'] slice\n * @param action - RaidenAction to handle\n * @returns New RaidenState['transport'] slice\n */\nconst transport = createReducer(initialState.transport)\n    .handle(matrixSetup, (state, action) => {\n    var _a;\n    // immutably remove rooms from state.matrix\n    const _b = Object.assign({}, state.matrix), { rooms: _ } = _b, noRooms = __rest(_b, [\"rooms\"]);\n    return Object.assign(Object.assign({}, state), { matrix: Object.assign(Object.assign({}, (((_a = state.matrix) === null || _a === void 0 ? void 0 : _a.server) !== action.payload.server ? noRooms : state.matrix)), action.payload) });\n})\n    .handle(matrixRoom, (state, action) => {\n    const path = ['matrix', 'rooms', action.meta.address];\n    return set(path, [\n        action.payload.roomId,\n        ...getOr([], path, state).filter((room) => room !== action.payload.roomId),\n    ], state);\n})\n    .handle(matrixRoomLeave, (state, action) => {\n    const path = ['matrix', 'rooms', action.meta.address];\n    state = set(path, getOr([], path, state).filter((r) => r !== action.payload.roomId), state);\n    if (isEmpty(get(path, state)))\n        state = unset(path, state);\n    return state;\n});\n/**\n * Nested/combined reducer for transport\n * Currently only handles 'transport' substate\n */\nconst transportReducer = partialCombineReducers({ transport }, initialState);\nexport default transportReducer;\n//# sourceMappingURL=reducer.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as t from 'io-ts';\nimport { keccak256, RLP, verifyMessage } from 'ethers/utils';\nimport { arrayify, concat, hexlify } from 'ethers/utils/bytes';\nimport { encode as rlpEncode } from 'ethers/utils/rlp';\nimport { HashZero } from 'ethers/constants';\nimport logging from 'loglevel';\nimport { Signature, Signed, decode, assert } from '../utils/types';\nimport { encode, losslessParse, losslessStringify } from '../utils/data';\nimport { Message, MessageType } from './types';\nimport { messageReceived } from './actions';\nconst CMDIDs = {\n    [MessageType.DELIVERED]: 12,\n    [MessageType.PROCESSED]: 0,\n    [MessageType.SECRET_REQUEST]: 3,\n    [MessageType.SECRET_REVEAL]: 11,\n    [MessageType.LOCKED_TRANSFER]: 7,\n    [MessageType.REFUND_TRANSFER]: 8,\n    [MessageType.UNLOCK]: 4,\n    [MessageType.LOCK_EXPIRED]: 13,\n    [MessageType.WITHDRAW_REQUEST]: 15,\n    [MessageType.WITHDRAW_CONFIRMATION]: 16,\n    [MessageType.WITHDRAW_EXPIRED]: 17,\n    [MessageType.PFS_CAPACITY_UPDATE]: -1,\n    [MessageType.PFS_FEE_UPDATE]: -1,\n};\n// raiden_contracts.constants.MessageTypeId\nexport var MessageTypeId;\n(function (MessageTypeId) {\n    MessageTypeId[MessageTypeId[\"BALANCE_PROOF\"] = 1] = \"BALANCE_PROOF\";\n    MessageTypeId[MessageTypeId[\"WITHDRAW\"] = 3] = \"WITHDRAW\";\n    MessageTypeId[MessageTypeId[\"IOU\"] = 5] = \"IOU\";\n})(MessageTypeId || (MessageTypeId = {}));\n/**\n * Create the hash of Metadata structure.\n *\n * @param metadata - The LockedTransfer metadata\n * @returns Hash of the metadata.\n */\nexport function createMetadataHash(metadata) {\n    const routeHashes = metadata.routes.map((value) => keccak256(RLP.encode(value.route)));\n    return keccak256(RLP.encode(routeHashes));\n}\n/**\n * Returns a balance_hash from transferred&locked amounts & locksroot\n *\n * @param transferredAmount - EnvelopeMessage.transferred_amount\n * @param lockedAmount - EnvelopeMessage.locked_amount\n * @param locksroot - Hash of all current locks\n * @returns Hash of the balance\n */\nexport function createBalanceHash(transferredAmount, lockedAmount, locksroot) {\n    return (transferredAmount.isZero() && lockedAmount.isZero() && locksroot === HashZero\n        ? HashZero\n        : keccak256(concat([encode(transferredAmount, 32), encode(lockedAmount, 32), encode(locksroot, 32)])));\n}\n/**\n * Create the messageHash for a given EnvelopeMessage\n *\n * @param message - EnvelopeMessage to pack\n * @returns Hash of the message pack\n */\nexport function createMessageHash(message) {\n    switch (message.type) {\n        case MessageType.LOCKED_TRANSFER:\n        case MessageType.REFUND_TRANSFER:\n            // hash of packed representation of the whole message\n            let packed = concat([\n                encode(CMDIDs[message.type], 1),\n                encode(message.message_identifier, 8),\n                encode(message.payment_identifier, 8),\n                encode(message.lock.expiration, 32),\n                encode(message.token, 20),\n                encode(message.recipient, 20),\n                encode(message.target, 20),\n                encode(message.initiator, 20),\n                encode(message.lock.secrethash, 32),\n                encode(message.lock.amount, 32),\n            ]);\n            if (message.type === MessageType.LOCKED_TRANSFER)\n                packed = concat([packed, createMetadataHash(message.metadata)]);\n            return keccak256(packed);\n        case MessageType.UNLOCK:\n            return keccak256(concat([\n                encode(CMDIDs[message.type], 1),\n                encode(message.message_identifier, 8),\n                encode(message.payment_identifier, 8),\n                encode(message.secret, 32),\n            ]));\n        case MessageType.LOCK_EXPIRED:\n            return keccak256(concat([\n                encode(CMDIDs[message.type], 1),\n                encode(message.message_identifier, 8),\n                encode(message.recipient, 20),\n                encode(message.secrethash, 32),\n            ]));\n    }\n}\n/**\n * Pack a message in a hex-string format, **without** signature\n * This packed hex-byte-array can then be used for signing.\n * On Raiden python client, this is the output of `_data_to_sign` method of the messages, as the\n * actual packed encoding was once used for binary transport protocols, but nowadays is used only\n * for generating data to be signed, which is the purpose of our implementation.\n *\n * @param message - Message to be packed\n * @returns HexBytes hex-encoded string data representing message in binary format\n */\nexport function packMessage(message) {\n    var _a;\n    switch (message.type) {\n        case MessageType.DELIVERED:\n            return hexlify(concat([\n                encode(CMDIDs[message.type], 1),\n                encode(0, 3),\n                encode(message.delivered_message_identifier, 8),\n            ]));\n        case MessageType.PROCESSED:\n            return hexlify(concat([\n                encode(CMDIDs[message.type], 1),\n                encode(0, 3),\n                encode(message.message_identifier, 8),\n            ]));\n        case MessageType.LOCKED_TRANSFER:\n        case MessageType.REFUND_TRANSFER:\n        case MessageType.UNLOCK:\n        case MessageType.LOCK_EXPIRED: {\n            const messageHash = createMessageHash(message), balanceHash = createBalanceHash(message.transferred_amount, message.locked_amount, message.locksroot);\n            return hexlify(concat([\n                encode(message.token_network_address, 20),\n                encode(message.chain_id, 32),\n                encode(MessageTypeId.BALANCE_PROOF, 32),\n                encode(message.channel_identifier, 32),\n                encode(balanceHash, 32),\n                encode(message.nonce, 32),\n                encode(messageHash, 32),\n            ]));\n        }\n        case MessageType.SECRET_REQUEST:\n            return hexlify(concat([\n                encode(CMDIDs[message.type], 1),\n                encode(0, 3),\n                encode(message.message_identifier, 8),\n                encode(message.payment_identifier, 8),\n                encode(message.secrethash, 32),\n                encode(message.amount, 32),\n                encode(message.expiration, 32),\n            ]));\n        case MessageType.SECRET_REVEAL:\n            return hexlify(concat([\n                encode(CMDIDs[message.type], 1),\n                encode(0, 3),\n                encode(message.message_identifier, 8),\n                encode(message.secret, 32),\n            ]));\n        case MessageType.WITHDRAW_REQUEST:\n        case MessageType.WITHDRAW_CONFIRMATION:\n            return hexlify(concat([\n                encode(message.token_network_address, 20),\n                encode(message.chain_id, 32),\n                encode(MessageTypeId.WITHDRAW, 32),\n                encode(message.channel_identifier, 32),\n                encode(message.participant, 20),\n                encode(message.total_withdraw, 32),\n                encode(message.expiration, 32),\n            ]));\n        case MessageType.WITHDRAW_EXPIRED:\n            return hexlify(concat([\n                encode(CMDIDs[message.type], 1),\n                encode(0, 3),\n                encode(message.nonce, 32),\n                encode(message.message_identifier, 8),\n                encode(message.token_network_address, 20),\n                encode(message.chain_id, 32),\n                encode(MessageTypeId.WITHDRAW, 32),\n                encode(message.channel_identifier, 32),\n                encode(message.participant, 20),\n                encode(message.total_withdraw, 32),\n                encode(message.expiration, 32),\n            ]));\n        case MessageType.PFS_CAPACITY_UPDATE:\n            return hexlify(concat([\n                encode(message.canonical_identifier.chain_identifier, 32),\n                encode(message.canonical_identifier.token_network_address, 20),\n                encode(message.canonical_identifier.channel_identifier, 32),\n                encode(message.updating_participant, 20),\n                encode(message.other_participant, 20),\n                encode(message.updating_nonce, 8),\n                encode(message.other_nonce, 8),\n                encode(message.updating_capacity, 32),\n                encode(message.other_capacity, 32),\n                encode(message.reveal_timeout, 32),\n            ]));\n        case MessageType.PFS_FEE_UPDATE:\n            return hexlify(concat([\n                encode(message.canonical_identifier.chain_identifier, 32),\n                encode(message.canonical_identifier.token_network_address, 20),\n                encode(message.canonical_identifier.channel_identifier, 32),\n                encode(message.updating_participant, 20),\n                encode(message.fee_schedule.cap_fees, 1),\n                encode(message.fee_schedule.flat, 32),\n                encode(message.fee_schedule.proportional, 32),\n                rlpEncode((_a = message.fee_schedule.imbalance_penalty) !== null && _a !== void 0 ? _a : '0x'),\n                encode(message.timestamp, 19),\n            ])); // variable size of fee_schedule.imbalance_penalty rlpEncoding, when not null\n    }\n}\n/**\n * Typeguard to check if a message contains a valid signature\n *\n * @param message - May or may not be a signed message\n * @returns Boolean if message is signed\n */\nexport function isSigned(message) {\n    return Signature.is(message.signature);\n}\n/**\n * Requires a signed message and returns its signer address\n *\n * @param message - Signed message to retrieve signer address\n * @returns Address which signed message\n */\nexport function getMessageSigner(message) {\n    return verifyMessage(arrayify(packMessage(message)), message.signature);\n}\n/**\n * Get the SignedBalanceProof associated with an EnvelopeMessage\n *\n * @param message - Signed EnvelopeMessage\n * @returns SignedBalanceProof object for message\n */\nexport function getBalanceProofFromEnvelopeMessage(message) {\n    return {\n        chainId: message.chain_id,\n        tokenNetworkAddress: message.token_network_address,\n        channelId: message.channel_identifier,\n        nonce: message.nonce,\n        transferredAmount: message.transferred_amount,\n        lockedAmount: message.locked_amount,\n        locksroot: message.locksroot,\n        messageHash: createMessageHash(message),\n        signature: message.signature,\n        sender: getMessageSigner(message),\n    };\n}\n/**\n * Encode a Message as a JSON string\n * Uses lossless-json to encode BigNumbers as JSON 'string' type, as Raiden\n *\n * @param message - Message object to be serialized\n * @returns JSON string\n */\nexport function encodeJsonMessage(message) {\n    if ('signature' in message)\n        return losslessStringify(Signed(Message).encode(message));\n    return losslessStringify(Message.encode(message));\n}\n/**\n * Try to decode text as a Message, using lossless-json to decode BigNumbers\n * Throws if can't decode, or message is invalid regarding any of the encoded constraints\n *\n * @param text - JSON string to try to decode\n * @returns Message object\n */\nexport function decodeJsonMessage(text) {\n    const parsed = losslessParse(text);\n    assert(parsed &&\n        typeof parsed === 'object' &&\n        'type' in parsed &&\n        Object.values(MessageType).some((t) => t === parsed['type']), `Invalid message type: ${parsed === null || parsed === void 0 ? void 0 : parsed['type']}`);\n    if ('signature' in parsed)\n        return decode(Signed(Message), parsed);\n    return decode(Message, parsed);\n}\n/**\n * Pack message and request signer to sign it, and returns signed message\n *\n * @param signer - Signer instance\n * @param message - Unsigned message to pack and sign\n * @returns Promise to signed message\n */\nexport function signMessage(signer, message, { log } = { log: logging }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (isSigned(message))\n            return message;\n        log.debug(`Signing message \"${message.type}\"`, message);\n        const signature = (yield signer.signMessage(arrayify(packMessage(message))));\n        return Object.assign(Object.assign({}, message), { signature });\n    });\n}\n/**\n * Typeguard to ensure an action is a messageReceived of any of a set of Message types\n *\n * @param messageCodecs - Message codec to test action.payload.message against\n * @returns Typeguard intersecting messageReceived action and payload.message schemas\n */\nexport function isMessageReceivedOfType(messageCodecs) {\n    return (action) => messageReceived.is(action) &&\n        (Array.isArray(messageCodecs)\n            ? t.union(messageCodecs).is(action.payload.message)\n            : messageCodecs.is(action.payload.message));\n}\n//# sourceMappingURL=utils.js.map","import { concat, hexlify } from 'ethers/utils/bytes';\nimport { keccak256, randomBytes, bigNumberify, sha256 } from 'ethers/utils';\nimport { encode } from '../utils/data';\nimport { RaidenTransferStatus } from './state';\n/**\n * Get the locksroot of a given array of pending locks\n * On Alderaan, it's the keccak256 hash of the concatenation of the ordered locks data\n *\n * @param locks - Lock array to calculate the locksroot from\n * @returns hash of the locks array\n */\nexport function getLocksroot(locks) {\n    const encoded = [];\n    for (const lock of locks)\n        encoded.push(encode(lock.expiration, 32), encode(lock.amount, 32), lock.secrethash);\n    return keccak256(concat(encoded));\n}\n/**\n * Return the secrethash of a given secret\n * On Alderaan, the sha256 hash is used for the secret.\n *\n * @param secret - Secret to get the hash from\n * @returns hash of the secret\n */\nexport function getSecrethash(secret) {\n    return sha256(secret);\n}\n/**\n * Generates a random secret of given length, as an HexString<32>\n *\n * @param length - of the secret to generate\n * @returns HexString<32>\n */\nexport function makeSecret(length = 32) {\n    return hexlify(randomBytes(length));\n}\n/**\n * Generates a random payment identifier, as an UInt<8> (64 bits)\n *\n * @returns UInt<8>\n */\nexport function makePaymentId() {\n    return bigNumberify(Date.now());\n}\n/**\n * Generates a message identifier, as an UInt<8> (64 bits)\n *\n * @returns UInt<8>\n */\nexport function makeMessageId() {\n    return bigNumberify(Date.now());\n}\nfunction getTimeIfPresent(k) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (o) => (o[k] ? o[k][0] : undefined);\n}\nconst statusesMap = {\n    [RaidenTransferStatus.expired]: getTimeIfPresent('lockExpiredProcessed'),\n    [RaidenTransferStatus.unlocked]: getTimeIfPresent('unlockProcessed'),\n    [RaidenTransferStatus.expiring]: getTimeIfPresent('lockExpired'),\n    [RaidenTransferStatus.unlocking]: getTimeIfPresent('unlock'),\n    [RaidenTransferStatus.registered]: (sent) => { var _a, _b; \n    // only set status as registered if there's a valid registerBlock\n    return ((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) ? sent.secret[0] : undefined; },\n    [RaidenTransferStatus.revealed]: getTimeIfPresent('secretReveal'),\n    [RaidenTransferStatus.requested]: getTimeIfPresent('secretRequest'),\n    [RaidenTransferStatus.closed]: getTimeIfPresent('channelClosed'),\n    [RaidenTransferStatus.refunded]: getTimeIfPresent('refund'),\n    [RaidenTransferStatus.received]: getTimeIfPresent('transferProcessed'),\n    [RaidenTransferStatus.pending]: getTimeIfPresent('transfer'),\n};\n/**\n * Convert a state.sent: TransferState to a public RaidenTransfer object\n *\n * @param sent - RaidenState.sent value\n * @returns Public raiden sent transfer info object\n */\nexport function raidenSentTransfer(sent) {\n    var _a, _b, _c, _d;\n    const startedAt = new Date(sent.transfer[0]);\n    let changedAt = startedAt;\n    let status = RaidenTransferStatus.pending;\n    // order matters! from top to bottom priority, first match breaks loop\n    for (const [s, g] of Object.entries(statusesMap)) {\n        const ts = g(sent);\n        if (ts !== undefined) {\n            status = s;\n            changedAt = new Date(ts);\n            break;\n        }\n    }\n    const transfer = sent.transfer[1];\n    const value = transfer.lock.amount.sub(sent.fee);\n    const invalidSecretRequest = sent.secretRequest && sent.secretRequest[1].amount.lt(value);\n    const success = sent.secretReveal || sent.unlock || ((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock)\n        ? true\n        : invalidSecretRequest || sent.refund || sent.lockExpired || sent.channelClosed\n            ? false\n            : undefined;\n    const completed = !!(sent.unlockProcessed ||\n        sent.lockExpiredProcessed || ((_d = (_c = sent.secret) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.registerBlock) ||\n        sent.channelClosed);\n    return {\n        secrethash: transfer.lock.secrethash,\n        direction: 'sent',\n        status,\n        initiator: transfer.initiator,\n        partner: transfer.recipient,\n        target: transfer.target,\n        metadata: transfer.metadata,\n        paymentId: transfer.payment_identifier,\n        chainId: transfer.chain_id.toNumber(),\n        token: transfer.token,\n        tokenNetwork: transfer.token_network_address,\n        channelId: transfer.channel_identifier,\n        value,\n        fee: sent.fee,\n        amount: transfer.lock.amount,\n        expirationBlock: transfer.lock.expiration.toNumber(),\n        startedAt,\n        changedAt,\n        success,\n        completed,\n    };\n}\n//# sourceMappingURL=utils.js.map","import get from 'lodash/fp/get';\nimport set from 'lodash/fp/set';\nimport unset from 'lodash/fp/unset';\nimport { Zero, HashZero } from 'ethers/constants';\nimport { hexlify } from 'ethers/utils';\nimport { initialState } from '../state';\nimport { ChannelState } from '../channels/state';\nimport { channelClose } from '../channels/actions';\nimport { SignatureZero } from '../constants';\nimport { timed } from '../utils/types';\nimport { createReducer } from '../utils/actions';\nimport { getBalanceProofFromEnvelopeMessage, getMessageSigner } from '../messages/utils';\nimport { getLocksroot } from './utils';\nimport { Direction } from './state';\nimport { transferSigned, transferSecret, transferProcessed, transferUnlock, transferExpire, transferSecretReveal, transferRefunded, transferUnlockProcessed, transferExpireProcessed, transferClear, withdrawReceive, transferSecretRequest, transferSecretRegister, } from './actions';\nconst END = { [Direction.SENT]: 'own', [Direction.RECEIVED]: 'partner' };\n// Reducers for different actions\nfunction transferSecretReducer(state, action) {\n    var _a, _b, _c, _d, _e, _f;\n    const secrethash = action.meta.secrethash;\n    // store when seeing unconfirmed, but registerBlock only after confirmation\n    const registerBlock = transferSecretRegister.success.is(action) && action.payload.confirmed\n        ? action.payload.txBlock\n        : (_d = (_c = (_b = (_a = state[action.meta.direction][secrethash]) === null || _a === void 0 ? void 0 : _a.secret) === null || _b === void 0 ? void 0 : _b[1]) === null || _c === void 0 ? void 0 : _c.registerBlock) !== null && _d !== void 0 ? _d : 0;\n    // don't overwrite registerBlock if secret already stored with it\n    if (secrethash in state[action.meta.direction] &&\n        ((_f = (_e = state[action.meta.direction][secrethash].secret) === null || _e === void 0 ? void 0 : _e[1]) === null || _f === void 0 ? void 0 : _f.registerBlock) !== registerBlock)\n        state = Object.assign(Object.assign({}, state), { [action.meta.direction]: Object.assign(Object.assign({}, state[action.meta.direction]), { [secrethash]: Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), { secret: timed({ value: action.payload.secret, registerBlock }) }) }) });\n    return state;\n}\nfunction transferSignedReducer(state, action) {\n    var _a, _b, _c;\n    const transfer = action.payload.message;\n    const lock = transfer.lock;\n    const secrethash = lock.secrethash;\n    const partner = action.meta.direction === Direction.SENT ? transfer.recipient : getMessageSigner(transfer);\n    const end = END[action.meta.direction];\n    // transferSigned must be the first action, to init TransferState state\n    if (secrethash in state[action.meta.direction])\n        return state;\n    const channelPath = ['channels', transfer.token_network_address, partner];\n    let channel = get(channelPath, state);\n    if (!channel)\n        return state;\n    const locks = [...((_a = channel[end].locks) !== null && _a !== void 0 ? _a : []), lock]; // append lock\n    const locksroot = getLocksroot(locks);\n    if (transfer.locksroot !== locksroot ||\n        // nonce must be next\n        !transfer.nonce.eq((channel[end].balanceProof ? channel[end].balanceProof.nonce : Zero).add(1)) ||\n        !transfer.transferred_amount.eq(channel[end].balanceProof ? channel[end].balanceProof.transferredAmount : Zero) ||\n        !transfer.locked_amount.eq(((_c = (_b = channel[end].balanceProof) === null || _b === void 0 ? void 0 : _b.lockedAmount) !== null && _c !== void 0 ? _c : Zero).add(lock.amount)))\n        return state;\n    channel = Object.assign(Object.assign({}, channel), { [end]: Object.assign(Object.assign({}, channel[end]), { locks, \n            // set current/latest channel[end].balanceProof to LockedTransfer's\n            balanceProof: getBalanceProofFromEnvelopeMessage(transfer) }) });\n    const transferState = {\n        transfer: timed(transfer),\n        fee: action.payload.fee,\n        partner,\n    };\n    state = set(channelPath, channel, state);\n    state = set([action.meta.direction, secrethash], transferState, state);\n    return state;\n}\nfunction transferSecretRequestedReducer(state, action) {\n    const secrethash = action.meta.secrethash;\n    if (!(secrethash in state[action.meta.direction]))\n        return state;\n    return Object.assign(Object.assign({}, state), { [action.meta.direction]: Object.assign(Object.assign({}, state[action.meta.direction]), { [secrethash]: Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), { secretRequest: timed(action.payload.message) }) }) });\n}\nfunction transferSecretReveledReducer(state, action) {\n    const secrethash = action.meta.secrethash;\n    if (!(secrethash in state[action.meta.direction]) ||\n        state[action.meta.direction][secrethash].secretReveal)\n        return state;\n    return Object.assign(Object.assign({}, state), { [action.meta.direction]: Object.assign(Object.assign({}, state[action.meta.direction]), { [secrethash]: Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), { secretReveal: timed(action.payload.message) }) }) });\n}\nfunction transferUnlockSuccessReducer(state, action) {\n    const unlock = action.payload.message;\n    const secrethash = action.meta.secrethash;\n    if (!(secrethash in state[action.meta.direction]) ||\n        state[action.meta.direction][secrethash].unlock)\n        return state;\n    const transfer = state[action.meta.direction][secrethash].transfer[1];\n    const partner = state[action.meta.direction][secrethash].partner;\n    const end = END[action.meta.direction];\n    const lock = transfer.lock;\n    const channelPath = ['channels', transfer.token_network_address, partner];\n    let channel = get(channelPath, state);\n    if (!channel || !channel[end].locks || !channel[end].balanceProof)\n        return state;\n    const locks = channel[end].locks.filter((l) => l.secrethash !== secrethash);\n    const locksroot = getLocksroot(locks);\n    if (unlock.locksroot !== locksroot ||\n        !channel[end].balanceProof.nonce.add(1).eq(unlock.nonce) || // nonce must be next\n        !unlock.transferred_amount.eq(channel[end].balanceProof.transferredAmount.add(lock.amount)) ||\n        !unlock.locked_amount.eq(channel[end].balanceProof.lockedAmount.sub(lock.amount)))\n        return state;\n    channel = Object.assign(Object.assign({}, channel), { [end]: Object.assign(Object.assign({}, channel[end]), { locks, \n            // set current/latest channel[end].balanceProof to Unlock's\n            balanceProof: getBalanceProofFromEnvelopeMessage(unlock) }) });\n    const transferState = Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), { unlock: timed(unlock) });\n    state = set(channelPath, channel, state);\n    state = set([action.meta.direction, secrethash], transferState, state);\n    return state;\n}\nfunction transferExpireSuccessReducer(state, action) {\n    const expired = action.payload.message;\n    const secrethash = action.meta.secrethash;\n    if (!(secrethash in state[action.meta.direction]) ||\n        state[action.meta.direction][secrethash].unlock || // don't accept expire if already unlocked\n        state[action.meta.direction][secrethash].lockExpired // already expired\n    )\n        return state;\n    const transfer = state[action.meta.direction][secrethash].transfer[1];\n    const partner = state[action.meta.direction][secrethash].partner;\n    const end = END[action.meta.direction];\n    const lock = transfer.lock;\n    const channelPath = ['channels', transfer.token_network_address, partner];\n    let channel = get(channelPath, state);\n    if (!channel || !channel[end].locks || !channel[end].balanceProof)\n        return state;\n    const locks = channel[end].locks.filter((l) => l.secrethash !== secrethash);\n    const locksroot = getLocksroot(locks);\n    if (expired.locksroot !== locksroot ||\n        !channel[end].balanceProof.nonce.add(1).eq(expired.nonce) || // nonce must be next\n        !expired.transferred_amount.eq(channel[end].balanceProof.transferredAmount) ||\n        !expired.locked_amount.eq(channel[end].balanceProof.lockedAmount.sub(lock.amount)))\n        return state;\n    channel = Object.assign(Object.assign({}, channel), { [end]: Object.assign(Object.assign({}, channel[end]), { locks, \n            // set current/latest channel[end].balanceProof to LockExpired's\n            balanceProof: getBalanceProofFromEnvelopeMessage(expired) }) });\n    const transferState = Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), { lockExpired: timed(expired) });\n    state = set(channelPath, channel, state);\n    state = set([action.meta.direction, secrethash], transferState, state);\n    return state;\n}\nfunction transferStateReducer(state, action) {\n    const secrethash = action.meta.secrethash;\n    if (!(secrethash in state[action.meta.direction]))\n        return state;\n    let key;\n    if (transferProcessed.is(action)) {\n        key = 'transferProcessed';\n    }\n    else if (transferUnlockProcessed.is(action)) {\n        key = 'unlockProcessed';\n    }\n    else if (transferExpireProcessed.is(action)) {\n        key = 'lockExpiredProcessed';\n    }\n    else if (transferRefunded.is(action)) {\n        key = 'refund';\n    }\n    else {\n        return state;\n    }\n    if (state[action.meta.direction][secrethash][key])\n        return state;\n    return Object.assign(Object.assign({}, state), { [action.meta.direction]: Object.assign(Object.assign({}, state[action.meta.direction]), { [secrethash]: Object.assign(Object.assign({}, state[action.meta.direction][secrethash]), { [key]: timed(action.payload.message) }) }) });\n}\nfunction channelCloseSuccessReducer(state, action) {\n    let sent = state.sent;\n    for (const [secrethash, v] of Object.entries(sent)) {\n        const transfer = v.transfer[1];\n        if (!transfer.channel_identifier.eq(action.payload.id) ||\n            transfer.recipient !== action.meta.partner ||\n            transfer.token_network_address !== action.meta.tokenNetwork)\n            continue;\n        sent = Object.assign(Object.assign({}, sent), { [secrethash]: Object.assign(Object.assign({}, v), { channelClosed: timed(action.payload.txHash) }) });\n    }\n    if (sent !== state.sent)\n        state = Object.assign(Object.assign({}, state), { sent });\n    let received = state.received;\n    for (const [secrethash, v] of Object.entries(received)) {\n        const transfer = v.transfer[1];\n        if (!transfer.channel_identifier.eq(action.payload.id) ||\n            transfer.recipient !== action.meta.partner ||\n            transfer.token_network_address !== action.meta.tokenNetwork)\n            continue;\n        received = Object.assign(Object.assign({}, received), { [secrethash]: Object.assign(Object.assign({}, v), { channelClosed: timed(action.payload.txHash) }) });\n    }\n    if (received !== state.received)\n        state = Object.assign(Object.assign({}, state), { received });\n    return state;\n}\nfunction transferClearReducer(state, action) {\n    const secrethash = action.meta.secrethash;\n    if (!(secrethash in state[action.meta.direction]))\n        return state;\n    state = unset([action.meta.direction, secrethash], state);\n    return state;\n}\nfunction withdrawReceiveSuccessReducer(state, action) {\n    // TODO: subtract this pending withdraw request from partner's capacity (maybe some pending\n    // withdraws state), revert upon expiration or consolidate on confirmed channelWithdrawn\n    const message = action.payload.message;\n    const channelPath = ['channels', action.meta.tokenNetwork, action.meta.partner];\n    let channel = get(channelPath, state);\n    if (!channel || channel.state !== ChannelState.open)\n        return state;\n    // current own balanceProof, or zero balance proof, with some known fields filled\n    const balanceProof = channel.own.balanceProof || {\n        chainId: message.chain_id,\n        tokenNetworkAddress: action.meta.tokenNetwork,\n        channelId: message.channel_identifier,\n        // balance proof data\n        nonce: Zero,\n        transferredAmount: Zero,\n        lockedAmount: Zero,\n        locksroot: HashZero,\n        messageHash: HashZero,\n        signature: hexlify(SignatureZero),\n        sender: state.address,\n    };\n    // if it's the next nonce, update balance proof\n    if (message.nonce.eq(balanceProof.nonce.add(1)) && message.expiration.gt(state.blockNumber)) {\n        channel = Object.assign(Object.assign({}, channel), { own: Object.assign(Object.assign({}, channel.own), { balanceProof: Object.assign(Object.assign({}, balanceProof), { nonce: message.nonce }) }) });\n        state = set(channelPath, channel, state);\n    }\n    return state;\n}\n/**\n * Handles all transfers actions and requests\n */\nconst transfersReducer = createReducer(initialState)\n    .handle([transferSecret, transferSecretRegister.success], transferSecretReducer)\n    .handle(transferSigned, transferSignedReducer)\n    .handle([transferProcessed, transferUnlockProcessed, transferExpireProcessed, transferRefunded], transferStateReducer)\n    .handle(transferSecretRequest, transferSecretRequestedReducer)\n    .handle(transferSecretReveal, transferSecretReveledReducer)\n    .handle(transferUnlock.success, transferUnlockSuccessReducer)\n    .handle(transferExpire.success, transferExpireSuccessReducer)\n    .handle(channelClose.success, channelCloseSuccessReducer)\n    .handle(transferClear, transferClearReducer)\n    .handle(withdrawReceive.success, withdrawReceiveSuccessReducer);\nexport default transfersReducer;\n//# sourceMappingURL=reducer.js.map","/**\n * state.path reducer\n * Handles all path actions and requests\n *\n * @param state - Current RaidenState['path'] slice\n * @param action - RaidenAction to handle\n * @returns New RaidenState['path'] slice\n */\nimport set from 'lodash/fp/set';\nimport unset from 'lodash/fp/unset';\nimport { initialState } from '../state';\nimport { partialCombineReducers } from '../utils/redux';\nimport { createReducer } from '../utils/actions';\nimport { iouClear, iouPersist } from './actions';\nconst path = createReducer(initialState.path)\n    .handle(iouPersist, (state, action) => {\n    const path = ['iou', action.meta.tokenNetwork, action.meta.serviceAddress];\n    return set(path, action.payload.iou, state);\n})\n    .handle(iouClear, (state, action) => {\n    const path = ['iou', action.meta.tokenNetwork, action.meta.serviceAddress];\n    return unset(path, state);\n});\n/**\n * Nested combined reducer for path\n * Handles the 'path' substate.\n */\nconst servicesReducer = partialCombineReducers({ path }, initialState);\nexport default servicesReducer;\n//# sourceMappingURL=reducer.js.map","import unset from 'lodash/fp/unset';\nimport channelsReducer from './channels/reducer';\nimport transportReducer from './transport/reducer';\nimport transfersReducer from './transfers/reducer';\nimport servicesReducer from './services/reducer';\nimport { raidenConfigUpdate } from './actions';\nimport { initialState } from './state';\nimport { createReducer } from './utils/actions';\n// update state.config on raidenConfigUpdate action\n// resets key to default value if value is undefined, otherwise overwrites it\nconst configReducer = createReducer(initialState).handle(raidenConfigUpdate, (state, { payload }) => {\n    let config = state.config;\n    for (const [k, v] of Object.entries(payload)) {\n        if (v !== undefined)\n            config = Object.assign(Object.assign({}, config), { [k]: v });\n        else if (k in config)\n            config = unset(k, config);\n    }\n    if (config === state.config)\n        return state;\n    return Object.assign(Object.assign({}, state), { config });\n});\nconst raidenReducers = {\n    configReducer,\n    channelsReducer,\n    transportReducer,\n    transfersReducer,\n    servicesReducer,\n};\n/**\n * Raiden root reducer\n * Apply action over each submodule root reducer in a flattened manner (iteratively).\n * Notice the submodules reducers aren't handled only a partial/deep property of the state\n * (as combineReducers), but instead receive the whole state, so they can act on any part of the\n * state. This approach is similar to `reduce-reducers` util.\n * Each submodule root reducer may then choose to split its concerns into nested or flattened\n * reducers (like this one).\n *\n * @param state - Current RaidenState to reduce\n * @param action - RaidenAction to apply over state\n * @returns New RaidenState\n */\nexport const raidenReducer = (state = initialState, action) => Object.values(raidenReducers).reduce((s, reducer) => reducer(s, action), state);\n//# sourceMappingURL=reducer.js.map","import { pluck, distinctUntilChanged } from 'rxjs/operators';\n/**\n * Maps each source value (an object) to its specified nested property,\n * and emits only if the value changed since last emission\n *\n * It's a combination of `pluck` and `distinctUntilChanged` operators.\n \n * @param properties - The nested properties to pluck from each source value (an object).\n * @returns A new Observable of property values from the source values.\n */\nexport function pluckDistinct(...properties) {\n    return (source) => source.pipe(pluck(...properties), distinctUntilChanged());\n}\n//# sourceMappingURL=rx.js.map","import { filter, scan, startWith, share } from 'rxjs/operators';\nimport memoize from 'lodash/memoize';\nimport { matrixPresence } from './actions';\n/**\n * Helper to map/get an aggregated Presences observable from action$ bus\n * Known presences as { address: <last seen MatrixPresenceUpdateAction> } mapping\n * It's memoized and shared, so all subscriptions share the same mapped/output object, but the type\n * is explicitly set to avoid requiring the exported MemoizedFunction type\n *\n * @param action$ - Observable\n * @returns Observable of aggregated Presences from subscription to now\n */\nexport const getPresences$ = memoize((action$) => action$.pipe(filter(matrixPresence.success.is), scan(\n// scan all presence update actions and populate/output a per-address mapping\n(presences, update) => (Object.assign(Object.assign({}, presences), { [update.meta.address]: update })), {}), share(), startWith({})));\n//# sourceMappingURL=utils.js.map","import { from } from 'rxjs';\nimport { tap, mergeMap, map } from 'rxjs/operators';\nimport { Zero } from 'ethers/constants';\nimport { RaidenError } from '../utils/error';\nimport { ChannelState } from './state';\n/**\n * Calculates and returns partial and total amounts of given channel state\n *\n * @param channel - A Channel state to calculate amounts from\n * @returns An object holding own&partner's deposit, withdraw, transferred, locked, balance and\n *          capacity.\n */\nexport function channelAmounts(channel) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const Zero32 = Zero;\n    if (channel.state !== ChannelState.open)\n        return {\n            ownDeposit: Zero32,\n            ownWithdraw: Zero32,\n            ownTransferred: Zero32,\n            ownLocked: Zero32,\n            ownBalance: Zero32,\n            ownCapacity: Zero32,\n            partnerDeposit: Zero32,\n            partnerWithdraw: Zero32,\n            partnerTransferred: Zero32,\n            partnerLocked: Zero32,\n            partnerBalance: Zero32,\n            partnerCapacity: Zero32,\n        };\n    const ownWithdraw = (_a = channel.own.withdraw) !== null && _a !== void 0 ? _a : Zero32, partnerWithdraw = (_b = channel.partner.withdraw) !== null && _b !== void 0 ? _b : Zero32, ownTransferred = (_d = (_c = channel.own.balanceProof) === null || _c === void 0 ? void 0 : _c.transferredAmount) !== null && _d !== void 0 ? _d : Zero32, partnerTransferred = (_f = (_e = channel.partner.balanceProof) === null || _e === void 0 ? void 0 : _e.transferredAmount) !== null && _f !== void 0 ? _f : Zero32, ownLocked = (_h = (_g = channel.own.balanceProof) === null || _g === void 0 ? void 0 : _g.lockedAmount) !== null && _h !== void 0 ? _h : Zero32, partnerLocked = (_k = (_j = channel.partner.balanceProof) === null || _j === void 0 ? void 0 : _j.lockedAmount) !== null && _k !== void 0 ? _k : Zero32, ownBalance = partnerTransferred.sub(ownTransferred), partnerBalance = ownTransferred.sub(partnerTransferred), // == -ownBalance\n    ownCapacity = channel.own.deposit.sub(ownWithdraw).sub(ownLocked).add(ownBalance), partnerCapacity = channel.partner.deposit\n        .sub(partnerWithdraw)\n        .sub(partnerLocked)\n        .add(partnerBalance);\n    return {\n        ownDeposit: channel.own.deposit,\n        ownWithdraw,\n        ownTransferred,\n        ownLocked,\n        ownBalance,\n        ownCapacity,\n        partnerDeposit: channel.partner.deposit,\n        partnerWithdraw,\n        partnerTransferred,\n        partnerLocked,\n        partnerBalance,\n        partnerCapacity,\n    };\n}\n/**\n * Custom operator to wait & assert transaction success\n *\n * @param method - method name to use in logs\n * @param error - ErrorCode to throw if transaction fails\n * @param deps - object containing logger\n * @returns operator function to wait for transaction and output hash\n */\nexport function assertTx(method, error, { log }) {\n    return (tx) => tx.pipe(tap((tx) => log.debug(`sent ${method} tx \"${tx.hash}\" to \"${tx.to}\"`)), mergeMap((tx) => from(tx.wait()).pipe(map((receipt) => {\n        if (!receipt.status)\n            throw new RaidenError(error, { transactionHash: tx.hash });\n        log.debug(`${method} tx \"${tx.hash}\" successfuly mined!`);\n        return tx.hash;\n    }))));\n}\n//# sourceMappingURL=utils.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from 'ethers/abstract-signer';\nimport { Wallet } from 'ethers/wallet';\nimport { toUtf8Bytes, sha256 } from 'ethers/utils';\nimport { from, defer } from 'rxjs';\nimport { filter, map, scan, concatMap, pluck, withLatestFrom, first, exhaustMap, } from 'rxjs/operators';\nimport pick from 'lodash/pick';\nimport transform from 'lodash/transform';\nimport findKey from 'lodash/findKey';\nimport logging from 'loglevel';\nimport { raidenSentTransfer } from './transfers/utils';\nimport { channelAmounts } from './channels/utils';\nimport { pluckDistinct } from './utils/rx';\nimport { Address, PrivateKey, isntNil, assert } from './utils/types';\nimport { getNetworkName } from './utils/ethers';\nimport ropstenDeploy from './deployment/deployment_ropsten.json';\nimport rinkebyDeploy from './deployment/deployment_rinkeby.json';\nimport goerliDeploy from './deployment/deployment_goerli.json';\nimport ropstenServicesDeploy from './deployment/deployment_services_ropsten.json';\nimport rinkebyServicesDeploy from './deployment/deployment_services_rinkeby.json';\nimport goerliServicesDeploy from './deployment/deployment_services_goerli.json';\nimport { RaidenError, ErrorCodes } from './utils/error';\n/**\n * Returns contract information depending on the passed [[Network]]. Currently, only\n * `rinkeby`, `ropsten` and `goerli` are supported.\n * Throws an exception if called with another [[Network]].\n *\n * @param network - an account used for signing\n * @returns deployed contract information of the network\n */\nexport const getContracts = (network) => {\n    switch (network.name) {\n        case 'rinkeby':\n            return Object.assign(Object.assign({}, rinkebyDeploy.contracts), rinkebyServicesDeploy.contracts);\n        case 'ropsten':\n            return Object.assign(Object.assign({}, ropstenDeploy.contracts), ropstenServicesDeploy.contracts);\n        case 'goerli':\n            return Object.assign(Object.assign({}, goerliDeploy.contracts), goerliServicesDeploy.contracts);\n        default:\n            throw new RaidenError(ErrorCodes.RDN_UNRECOGNIZED_NETWORK, { network: network.name });\n    }\n};\n/**\n * Generate, sign and return a subkey from provided main account\n *\n * @param network - Network to include in message\n * @param main - Main signer to derive subkey from\n * @returns Subkey's signer & address\n */\nfunction genSubkey(network, main) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        const url = (_b = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.location) === null || _a === void 0 ? void 0 : _a.origin) !== null && _b !== void 0 ? _b : 'unknown';\n        const message = `=== RAIDEN SUBKEY GENERATION ===\n\nNetwork: ${getNetworkName(network).toUpperCase()}\nRaiden dApp URL: ${url}\n\nWARNING: ensure this signature is being requested from Raiden dApp running at URL above by comparing it to your browser's url bar.\nSigning this message at any other address WILL give it FULL control of this subkey's funds, tokens and Raiden channels!`;\n        const signature = yield main.signMessage(toUtf8Bytes(message));\n        const pk = sha256(signature);\n        const signer = new Wallet(pk, main.provider);\n        return { signer, address: signer.address };\n    });\n}\n/**\n * Returns a [[Signer]] based on the `account` and `provider`.\n * Throws an exception if the `account` is not a valid address or private key.\n *\n * @param account - an account used for signing\n * @param provider - a provider\n * @param subkey - Whether to generate a subkey\n * @returns a [[Signer]] or [[Wallet]] that can be used for signing\n */\nexport const getSigner = (account, provider, subkey) => __awaiter(void 0, void 0, void 0, function* () {\n    let signer;\n    let address;\n    let main;\n    if (Signer.isSigner(account)) {\n        if (account.provider === provider) {\n            signer = account;\n        }\n        else if (account instanceof Wallet) {\n            signer = account.connect(provider);\n        }\n        else {\n            throw new RaidenError(ErrorCodes.RDN_SIGNER_NOT_CONNECTED, {\n                account: account.toString(),\n                provider: provider.toString(),\n            });\n        }\n        address = (yield signer.getAddress());\n    }\n    else if (typeof account === 'number') {\n        // index of account in provider\n        signer = provider.getSigner(account);\n        address = (yield signer.getAddress());\n    }\n    else if (Address.is(account)) {\n        // address\n        const accounts = yield provider.listAccounts();\n        if (!accounts.includes(account)) {\n            throw new RaidenError(ErrorCodes.RDN_ACCOUNT_NOT_FOUND, {\n                account,\n                accounts: JSON.stringify(accounts),\n            });\n        }\n        signer = provider.getSigner(account);\n        address = account;\n    }\n    else if (PrivateKey.is(account)) {\n        // private key\n        signer = new Wallet(account, provider);\n        address = signer.address;\n    }\n    else {\n        throw new RaidenError(ErrorCodes.RDN_STRING_ACCOUNT_INVALID);\n    }\n    if (subkey) {\n        main = { signer, address };\n        ({ signer, address } = yield genSubkey(yield provider.getNetwork(), main.signer));\n    }\n    return { signer, address, main };\n});\n/**\n * Initializes the [[transfers$]] observable\n *\n * @param state$ - Observable of the current RaidenState\n * @returns observable of sent and completed Raiden transfers\n */\nexport const initTransfers$ = (state$) => state$.pipe(pluckDistinct('sent'), concatMap((sent) => from(Object.entries(sent))), \n/* this scan stores a reference to each [key,value] in 'acc', and emit as 'changed' iff it\n * changes from last time seen. It relies on value references changing only if needed */\nscan(({ acc }, [secrethash, sent]) => \n// if ref didn't change, emit previous accumulator, without 'changed' value\nacc[secrethash] === sent\n    ? { acc }\n    : // else, update ref in 'acc' and emit value in 'changed' prop\n        { acc: Object.assign(Object.assign({}, acc), { [secrethash]: sent }), changed: sent }, { acc: {} }), pluck('changed'), filter(isntNil), // filter out if reference didn't change from last emit\n// from here, we get TransferState objects which changed from previous state (all on first)\nmap(raidenSentTransfer));\n/**\n * Returns an object that maps partner addresses to their [[RaidenChannel]].\n *\n * @param partnerChannelMap - an object that maps partnerAddress to a channel\n * @param token - a token address\n * @param tokenNetwork - a token network\n * @returns raiden channel\n */\nconst mapPartnerToChannel = (partnerChannelMap, token, tokenNetwork) => transform(\n// transform Channel to RaidenChannel, with more info\npartnerChannelMap, (partner2raidenChannel, channel, partner) => {\n    const { ownDeposit, partnerDeposit, ownBalance: balance, ownCapacity: capacity, } = channelAmounts(channel);\n    partner2raidenChannel[partner] = Object.assign(Object.assign({ state: channel.state }, pick(channel, ['id', 'settleTimeout', 'openBlock', 'closeBlock'])), { token, tokenNetwork: tokenNetwork, partner: partner, ownDeposit,\n        partnerDeposit,\n        balance,\n        capacity });\n});\n/**\n * Transforms the redux channel state to [[RaidenChannels]]\n *\n * @param state - current state\n * @returns raiden channels\n */\nexport const mapTokenToPartner = (state) => transform(\n// transform state.channels to token-partner-raidenChannel map\nstate.channels, (result, partnerChannelMap, tokenNetwork) => {\n    const token = findKey(state.tokens, (tn) => tn === tokenNetwork);\n    if (!token)\n        return; // shouldn't happen, token mapping is always bi-directional\n    result[token] = mapPartnerToChannel(partnerChannelMap, token, tokenNetwork);\n});\n/**\n * Return signer & address to use for on-chain txs depending on subkey param\n *\n * @param deps - RaidenEpicDeps subset\n * @param subkey - Whether to prefer the subkey or the main key\n * @returns Signer & Address to use for on-chain operations\n */\nexport function chooseOnchainAccount({ signer, address, main, }, subkey) {\n    if (main && !subkey)\n        return main;\n    return { signer, address };\n}\n/**\n * Returns a contract instance with attached signer\n *\n * @param contract - Contract instance\n * @param signer - Signer to use on contract\n * @returns contract instance with signer\n */\nexport function getContractWithSigner(contract, signer) {\n    if (contract.signer === signer)\n        return contract;\n    return contract.connect(signer);\n}\n/**\n * Calls a contract method and wait for it to be mined successfuly, rejects otherwise\n *\n * @param contract - Contract instance\n * @param method - Method name\n * @param params - Params tuple to method\n * @param errorCode - ErrorCode to throw in case of failure\n * @returns Promise to successful receipt\n */\nexport function callAndWaitMined(contract, method, params, errorCode, { log } = { log: logging }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let tx;\n        try {\n            // 'as C' just to avoid error with unknown functions Bucket\n            tx = yield contract.functions[method](...params);\n        }\n        catch (err) {\n            log.error(`Error sending ${method} tx`, err);\n            throw new RaidenError(errorCode, { error: err.message });\n        }\n        log.debug(`sent ${method} tx \"${tx.hash}\" to \"${contract.address}\"`);\n        let receipt;\n        try {\n            receipt = yield tx.wait();\n            assert(receipt.status, `tx status: ${receipt.status}`);\n        }\n        catch (err) {\n            log.error(`Error mining ${method} tx`, err);\n            throw new RaidenError(errorCode, {\n                transactionHash: tx.hash,\n            });\n        }\n        log.debug(`${method} tx \"${tx.hash}\" successfuly mined!`);\n        return receipt;\n    });\n}\n/**\n * Waits for a given receipt to be confirmed; throws if it gets removed by a reorg instead\n *\n * @param receipt - Receipt to wait for confirmation\n * @param deps - RaidenEpicDeps\n * @param confBlocks - Overwrites config\n * @returns Promise final block of transaction\n */\nexport function waitConfirmation(receipt, { latest$, config$, provider }, confBlocks) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const txBlock = receipt.blockNumber;\n        const txHash = receipt.transactionHash;\n        return latest$\n            .pipe(pluckDistinct('state', 'blockNumber'), withLatestFrom(config$), filter(([blockNumber, { confirmationBlocks }]) => txBlock + (confBlocks !== null && confBlocks !== void 0 ? confBlocks : confirmationBlocks) <= blockNumber), exhaustMap(([blockNumber, { confirmationBlocks }]) => defer(() => provider.getTransactionReceipt(txHash)).pipe(map((receipt) => {\n            if ((receipt === null || receipt === void 0 ? void 0 : receipt.confirmations) &&\n                receipt.confirmations >= (confBlocks !== null && confBlocks !== void 0 ? confBlocks : confirmationBlocks))\n                return receipt.blockNumber;\n            else if (txBlock + 2 * (confBlocks !== null && confBlocks !== void 0 ? confBlocks : confirmationBlocks) < blockNumber)\n                throw new RaidenError(ErrorCodes.RDN_TRANSACTION_REORG, {\n                    transactionHash: txHash,\n                });\n        }))), first(isntNil))\n            .toPromise();\n    });\n}\n/*\n * Returns true if `url` is a valid URL or domain.\n * On production `https://` is required for URLs, otherwise `http://` matches as well.\n *\n * @param url - A URL or hostname\n * @returns true if valid URL or domain\n */\nexport const isValidUrl = (url) => {\n    const regex = process.env.NODE_ENV === 'production'\n        ? /^(?:https:\\/\\/)?[^\\s\\/$.?#&\"']+\\.[^\\s\\/$?#&\"']+$/\n        : /^(?:(http|https):\\/\\/)?([^\\s\\/$.?#&\"']+\\.)*[^\\s\\/$?#&\"']+(?:(\\d+))*$/;\n    return regex.test(url);\n};\n//# sourceMappingURL=helpers.js.map","import { from, of, EMPTY, merge, interval, defer, concat as concat$, combineLatest, timer, throwError, } from 'rxjs';\nimport { catchError, filter, map, mergeMap, tap, takeWhile, withLatestFrom, groupBy, exhaustMap, first, take, mapTo, pluck, publishReplay, ignoreElements, skip, startWith, retryWhen, } from 'rxjs/operators';\nimport findKey from 'lodash/findKey';\nimport isEmpty from 'lodash/isEmpty';\nimport negate from 'lodash/negate';\nimport { hexlify, concat, defaultAbiCoder } from 'ethers/utils';\nimport { HashZero, Zero } from 'ethers/constants';\nimport { raidenShutdown } from '../actions';\nimport { ChannelState } from '../channels';\nimport { SignatureZero, ShutdownReason } from '../constants';\nimport { chooseOnchainAccount, getContractWithSigner } from '../helpers';\nimport { isntNil, assert } from '../utils/types';\nimport { isActionOf } from '../utils/actions';\nimport { pluckDistinct } from '../utils/rx';\nimport { fromEthersEvent, getEventsStream, getNetwork } from '../utils/ethers';\nimport { encode } from '../utils/data';\nimport { RaidenError, ErrorCodes } from '../utils/error';\nimport { createBalanceHash } from '../messages/utils';\nimport { newBlock, tokenMonitored, channelMonitor, channelOpen, channelDeposit, channelClose, channelSettle, channelSettleable, channelWithdrawn, } from './actions';\nimport { assertTx } from './utils';\n/**\n * Receives an async function and returns an observable which will retry it every interval until it\n * resolves, or throw if it can't succeed after 10 retries.\n * It is needed e.g. on provider methods which perform RPC requests directly, as they can fail\n * temporarily due to network errors, so they need to be retried for a while.\n * JsonRpcProvider._doPoll also catches, suppresses & retry\n *\n * @param func - An async function (e.g. a Promise factory, like a defer callback)\n * @param interval - Interval to retry in case of rejection\n * @param retries - Max number of times to retry\n * @returns Observable version of async function, with retries\n */\nfunction retryAsync$(func, interval = 1e3, retries = 10) {\n    return defer(func).pipe(retryWhen((err$) => err$.pipe(mergeMap((err, i) => (i < retries ? timer(interval) : throwError(err))))));\n}\n/**\n * Fetch current blockNumber, register for new block events and emit newBlock actions\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param provider - RaidenEpicDeps members\n * @returns Observable of newBlock actions\n */\nexport const initNewBlockEpic = ({}, {}, { provider }) => retryAsync$(() => provider.getBlockNumber(), provider.pollingInterval).pipe(mergeMap((blockNumber) => merge(of(blockNumber), fromEthersEvent(provider, 'block'))), map((blockNumber) => newBlock({ blockNumber })));\n/**\n * On first run, scan registry and token networks for registered TokenNetworks of interest\n * (ones which has/had channels with us) and monitors them. On next runs, just monitors the\n * previously monitored ones.\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param registryContract,contractsInfo - RaidenEpicDeps members\n * @returns Observable of tokenMonitored actions\n */\nexport const initTokensRegistryEpic = ({}, state$, { address, provider, registryContract, contractsInfo }) => state$.pipe(take(1), mergeMap((state) => {\n    const encodedAddress = defaultAbiCoder.encode(['address'], [address]);\n    // if tokens are already initialized, use it\n    if (!isEmpty(state.tokens))\n        return from(Object.entries(state.tokens).map(([token, tokenNetwork]) => tokenMonitored({ token: token, tokenNetwork })));\n    // else, do an initial registry scan, from deploy to now\n    else\n        return retryAsync$(() => provider.getLogs(Object.assign(Object.assign({}, registryContract.filters.TokenNetworkCreated(null, null)), { fromBlock: contractsInfo.TokenNetworkRegistry.block_number, toBlock: 'latest' })), provider.pollingInterval).pipe(mergeMap((logs) => from(logs)), map((log) => ({ log, parsed: registryContract.interface.parseLog(log) })), filter(({ parsed }) => { var _a; return !!((_a = parsed.values) === null || _a === void 0 ? void 0 : _a.token_network_address); }), \n        // for each TokenNetwork found, scan for channels with us\n        mergeMap(({ log, parsed }) => concat$(\n        // concat channels opened by us and to us separately\n        // take(1) won't subscribe the later if something is found on former\n        retryAsync$(() => {\n            var _a;\n            return provider.getLogs({\n                address: parsed.values.token_network_address,\n                topics: [null, null, encodedAddress],\n                fromBlock: (_a = log.blockNumber) !== null && _a !== void 0 ? _a : contractsInfo.TokenNetworkRegistry.block_number,\n                toBlock: 'latest',\n            });\n        }, provider.pollingInterval).pipe(mergeMap(from)), retryAsync$(() => provider.getLogs({\n            address: parsed.values.token_network_address,\n            topics: [null, null, null, encodedAddress],\n            fromBlock: log.blockNumber,\n            toBlock: 'latest',\n        }), provider.pollingInterval).pipe(mergeMap(from))).pipe(\n        // if found at least one, register this TokenNetwork as of interest\n        // else, do nothing\n        take(1), mapTo(tokenMonitored({\n            token: parsed.values.token_address,\n            tokenNetwork: parsed.values.token_network_address,\n            fromBlock: log.blockNumber,\n        }))), 5));\n}));\n/**\n * Monitor channels previously already on state\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of channelMonitor actions\n */\nexport const initMonitorChannelsEpic = ({}, state$) => state$.pipe(first(), mergeMap(function* (state) {\n    for (const [tokenNetwork, obj] of Object.entries(state.channels)) {\n        for (const [partner, channel] of Object.entries(obj)) {\n            if (channel.state === ChannelState.opening)\n                continue;\n            yield channelMonitor({ id: channel.id }, { tokenNetwork: tokenNetwork, partner: partner });\n        }\n    }\n}));\n/**\n * Monitor provider to ensure account continues to be available and network stays the same\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param address,network,provider - RaidenEpicDeps members\n * @returns Observable of raidenShutdown actions\n */\nexport const initMonitorProviderEpic = ({}, {}, { address, network, provider }) => retryAsync$(() => provider.listAccounts(), provider.pollingInterval).pipe(\n// at init time, check if our address is in provider's accounts list\n// if not, it means Signer is a local Wallet or another non-provider-side account\n// if yes, poll accounts every 1s and monitors if address is still there\n// also, every 1s poll current provider network and monitors if it's the same\n// if any check fails, emits RaidenShutdownAction, nothing otherwise\n// Poll reason from: https://github.com/MetaMask/faq/blob/master/DEVELOPERS.md\n// first/init-time check\nmap((accounts) => accounts.includes(address)), mergeMap((isProviderAccount) => interval(provider.pollingInterval).pipe(exhaustMap(() => merge(\n// if isProviderAccount, also polls and monitors accounts list\nisProviderAccount\n    ? retryAsync$(() => provider.listAccounts(), provider.pollingInterval).pipe(mergeMap((accounts) => !accounts.includes(address)\n        ? of(raidenShutdown({ reason: ShutdownReason.ACCOUNT_CHANGED }))\n        : EMPTY))\n    : EMPTY, \n// unconditionally monitors network changes\nretryAsync$(() => getNetwork(provider), provider.pollingInterval).pipe(mergeMap((curNetwork) => curNetwork.chainId !== network.chainId\n    ? of(raidenShutdown({ reason: ShutdownReason.NETWORK_CHANGED }))\n    : EMPTY)))))));\n/**\n * Starts monitoring a token network for events\n * When this action goes through (because a former or new token registry event was deteceted),\n * subscribe to events and emit respective actions to the stream. Currently:\n * - ChannelOpened events with us or by us\n *\n * @param action$ - Observable of tokenMonitored actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of channelOpen.success actions\n */\nexport const tokenMonitoredEpic = (action$, {}, { address, getTokenNetworkContract }) => action$.pipe(filter(isActionOf(tokenMonitored)), groupBy((action) => action.payload.tokenNetwork), mergeMap((grouped$) => grouped$.pipe(exhaustMap((action) => {\n    const tokenNetworkContract = getTokenNetworkContract(action.payload.tokenNetwork);\n    // type of elements emitted by getEventsStream (past and new events coming from\n    // contract): [channelId, partner1, partner2, settleTimeout, Event]\n    return getEventsStream(tokenNetworkContract, \n    // it's cheaper for monitoring to fetch all channels and filter client-side,\n    // than to query/create/request 2 filters on every block (from and to us)\n    [tokenNetworkContract.filters.ChannelOpened(null, null, null, null)], \n    // if first time monitoring this token network,\n    // fetch TokenNetwork's pastEvents since registry deployment as fromBlock$\n    action.payload.fromBlock ? of(action.payload.fromBlock) : undefined).pipe(filter(([, p1, p2]) => p1 === address || p2 === address), map(([id, p1, p2, settleTimeout, event]) => channelOpen.success({\n        id: id.toNumber(),\n        settleTimeout: settleTimeout.toNumber(),\n        isFirstParticipant: address === p1,\n        txHash: event.transactionHash,\n        txBlock: event.blockNumber,\n        confirmed: undefined,\n    }, {\n        tokenNetwork: tokenNetworkContract.address,\n        partner: address === p1 ? p2 : p1,\n    })));\n}))));\n/**\n * When we see a new ChannelOpenedAction event, starts monitoring channel\n *\n * @param action$ - Observable of channelOpen.success actions\n * @returns Observable of channelMonitor actions\n */\nexport const channelOpenedEpic = (action$) => action$.pipe(filter(isActionOf(channelOpen.success)), filter((action) => !!action.payload.confirmed), map((action) => channelMonitor({\n    id: action.payload.id,\n    // fetch past events as well, if needed, including events before confirmation\n    fromBlock: action.payload.txBlock,\n}, action.meta)));\n/**\n * Monitors a channel for channel Events\n * Can be called either at initialization time (for previously known channels on previously\n * monitored TokenNetwork) or by a new detected ChannelOpenedAction. On the later case,\n * also fetches events since Channel.openBlock.\n * Currently monitored events:\n * - ChannelNewDeposit, fires a channelDeposit.success action\n * - ChannelClosedEvent, fires a channelClose.success action\n * - ChannelSettledEvent, fires a channelSettle.success action and completes that channel observable\n *\n * @param action$ - Observable of channelMonitor actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of channelDeposit.success,channelClose.success,channelSettle.success actions\n */\nexport const channelMonitoredEpic = (action$, state$, { getTokenNetworkContract }) => action$.pipe(filter(isActionOf(channelMonitor)), groupBy((action) => `${action.payload.id}#${action.meta.partner}@${action.meta.tokenNetwork}`), mergeMap((grouped$) => grouped$.pipe(exhaustMap((action) => {\n    const { tokenNetwork, partner } = action.meta;\n    const tokenNetworkContract = getTokenNetworkContract(tokenNetwork);\n    const depositFilter = tokenNetworkContract.filters.ChannelNewDeposit(action.payload.id, null, null), withdrawFilter = tokenNetworkContract.filters.ChannelWithdraw(action.payload.id, null, null), closedFilter = tokenNetworkContract.filters.ChannelClosed(action.payload.id, null, null, null), settledFilter = tokenNetworkContract.filters.ChannelSettled(action.payload.id, null, null, null, null), mergedFilter = {\n        address: tokenNetworkContract.address,\n        topics: [\n            [\n                depositFilter.topics[0],\n                withdrawFilter.topics[0],\n                closedFilter.topics[0],\n                settledFilter.topics[0],\n            ],\n            [settledFilter.topics[1]],\n        ],\n    };\n    /**\n     * Guards that an event data tuple matches the type of a given filter\n     *\n     * Type must be explicitly passed as generic type parameter, and a corresponding filter\n     * as first parameter\n     *\n     * @param filter - Filter of an event of type T\n     * @param data - event data tuple, where last element is the Event object\n     * @returns Truty if event data matches filter\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function isEvent(filter, data) {\n        const event = data[data.length - 1];\n        if (!event || !event.topics || !filter.topics)\n            return false;\n        const topic0 = filter.topics[0];\n        return Array.isArray(topic0)\n            ? topic0.includes(event.topics[0])\n            : topic0 === event.topics[0];\n    }\n    return getEventsStream(tokenNetworkContract, [mergedFilter], \n    // if channelMonitor triggered by channelOpen.success,\n    // fetch Channel's pastEvents since channelOpen.success blockNumber as fromBlock$\n    action.payload.fromBlock ? of(action.payload.fromBlock) : undefined).pipe(withLatestFrom(state$.pipe(pluck('channels'), startWith({}))), map(([data, channels]) => {\n        var _a, _b, _c;\n        if (isEvent(depositFilter, data)) {\n            const [id, participant, totalDeposit, event] = data;\n            return channelDeposit.success({\n                id: id.toNumber(),\n                participant,\n                totalDeposit,\n                txHash: event.transactionHash,\n                txBlock: event.blockNumber,\n                confirmed: undefined,\n            }, action.meta);\n        }\n        else if (isEvent(withdrawFilter, data)) {\n            const [id, participant, totalWithdraw, event] = data;\n            return channelWithdrawn({\n                id: id.toNumber(),\n                participant,\n                totalWithdraw,\n                txHash: event.transactionHash,\n                txBlock: event.blockNumber,\n                confirmed: undefined,\n            }, action.meta);\n        }\n        else if (isEvent(closedFilter, data)) {\n            const [id, participant, , , event] = data;\n            return channelClose.success({\n                id: id.toNumber(),\n                participant,\n                txHash: event.transactionHash,\n                txBlock: event.blockNumber,\n                confirmed: undefined,\n            }, action.meta);\n        }\n        else if (isEvent(settledFilter, data)) {\n            const [id, , , , , event] = data;\n            return channelSettle.success({\n                id: id.toNumber(),\n                txHash: event.transactionHash,\n                txBlock: event.blockNumber,\n                confirmed: undefined,\n                locks: (_c = (_b = (_a = channels[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[partner]) === null || _b === void 0 ? void 0 : _b.partner) === null || _c === void 0 ? void 0 : _c.locks,\n            }, action.meta);\n        }\n    }), filter(isntNil), \n    // takeWhile tends to broad input to generic Action. We need to narrow it explicitly\n    takeWhile(negate(channelSettle.success.is), true));\n}))));\n/**\n * A channelOpen action requested by user\n * Needs to be called on a previously monitored tokenNetwork. Calls TokenNetwork.openChannel\n * with given parameters. If tx goes through successfuly, stop as ChannelOpened success action\n * will instead be detected and fired by tokenMonitoredEpic. If anything detectable goes wrong,\n * fires a ChannnelOpenActionFailed instead\n *\n * @param action$ - Observable of channelOpen actions\n * @param state$ - Observable of RaidenStates\n * @param getTokenNetworkContract - RaidenEpicDeps members\n * @returns Observable of channelOpen.failure actions\n */\nexport const channelOpenEpic = (action$, state$, { log, signer, address, main, getTokenContract, getTokenNetworkContract, config$, }) => action$.pipe(filter(isActionOf(channelOpen.request)), withLatestFrom(state$, config$), mergeMap(([action, state, { settleTimeout, subkey: configSubkey }]) => {\n    var _a, _b, _c;\n    const { tokenNetwork, partner } = action.meta;\n    const channelState = (_b = (_a = state.channels[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[partner]) === null || _b === void 0 ? void 0 : _b.state;\n    // proceed only if channel is in 'opening' state, set by this action\n    if (channelState !== ChannelState.opening)\n        return of(channelOpen.failure(new RaidenError(ErrorCodes.CNL_INVALID_STATE, { state: channelState }), action.meta));\n    const { signer: onchainSigner } = chooseOnchainAccount({ signer, address, main }, (_c = action.payload.subkey) !== null && _c !== void 0 ? _c : configSubkey);\n    const tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    // if also requested deposit\n    const deposit = !action.payload.deposit || action.payload.deposit.isZero()\n        ? undefined\n        : action.payload.deposit;\n    const token = findKey(state.tokens, (tn) => tn === tokenNetwork);\n    const tokenContract = getContractWithSigner(getTokenContract(token), onchainSigner);\n    return action$.pipe(filter(channelOpen.success.is), filter((a) => a.meta.tokenNetwork === tokenNetwork && a.meta.partner === partner), \n    // opened$ will \"cache\" matching channelOpen.success, if needed\n    publishReplay(1, undefined, (opened$) => \n    // send openChannel transaction\n    defer(() => {\n        var _a;\n        return tokenNetworkContract.functions.openChannel(address, partner, (_a = action.payload.settleTimeout) !== null && _a !== void 0 ? _a : settleTimeout);\n    }).pipe(\n    // Wallet signer depends on fetching the 'pending' tx count to fill 'nonce'\n    // therefore we need to send open then approve, instead of doing them parallely\n    mergeMap((openTx) => deposit\n        ? from(tokenContract.functions.approve(tokenNetwork, deposit)).pipe(map((approveTx) => [openTx, approveTx]))\n        : of([openTx])), \n    // can't share logic with channelDepositEpic, because parallelism of txs needs to be\n    // strict, nor use assertTx for approve|openChannel parallel txs\n    tap(([tx]) => log.debug(`sent openChannel tx \"${tx.hash}\" to \"${tokenNetwork}\"`)), tap(([, tx]) => (tx ? log.debug(`sent approve tx \"${tx.hash}\" to \"${token}\"`) : 0)), mergeMap(([openTx, approveTx]) => combineLatest([\n        from(openTx.wait()).pipe(map((receipt) => ({ tx: openTx, receipt }))),\n        approveTx\n            ? from(approveTx.wait()).pipe(map((receipt) => ({ tx: approveTx, receipt })))\n            : of(undefined),\n    ])), mergeMap(([open, approve]) => {\n        if (!open.receipt.status)\n            throw new RaidenError(ErrorCodes.CNL_OPENCHANNEL_FAILED, Object.assign(Object.assign({}, action.meta), { transactionHash: open.tx.hash }));\n        log.debug(`openChannel tx \"${open.tx.hash}\" successfuly mined!`);\n        // now that channel is opened, check approve and proceed to setTotalDeposit\n        // if no deposit requested, EMPTY will skip rest of this chain\n        return (approve ? of(approve) : EMPTY).pipe(mergeMap(({ tx, receipt }) => {\n            if (!receipt.status)\n                throw new RaidenError(ErrorCodes.CNL_APPROVE_TRANSACTION_FAILED, {\n                    token,\n                    transactionHash: tx.hash,\n                });\n            log.debug(`approve tx \"${tx.hash}\" successfuly mined!`);\n            // wait or use cached channelOpen.success, unconfirmed\n            return opened$.pipe(first(), mergeMap(({ payload: { id } }) => tokenNetworkContract.functions.setTotalDeposit(id, address, deposit, partner)));\n        }), assertTx('setTotalDeposit', ErrorCodes.CNL_SETTOTALDEPOSIT_FAILED, { log }), \n        // ignore success so it's picked by channelMonitoredEpic\n        ignoreElements(), catchError((error) => of(channelDeposit.failure(error, action.meta))));\n    }), \n    // ignore success so it's picked by tokenMonitoredEpic\n    catchError((error) => of(channelOpen.failure(error, action.meta))))));\n}));\n/**\n * A ChannelDeposit action requested by user\n * Needs to be called on a previously monitored channel. Calls Token.approve for TokenNetwork\n * and then set respective setTotalDeposit. If all tx go through successfuly, stop as\n * ChannelDeposited success action will instead be detected and reacted by\n * channelMonitoredEpic. If anything detectable goes wrong, fires a ChannelDepositActionFailed\n * instead\n *\n * @param action$ - Observable of channelDeposit.request actions\n * @param state$ - Observable of RaidenStates\n * @param address,getTokenContract,getTokenNetworkContract - RaidenEpicDeps members\n * @returns Observable of channelDeposit.failure actions\n */\nexport const channelDepositEpic = (action$, state$, { log, signer, address, main, getTokenContract, getTokenNetworkContract, config$, }) => action$.pipe(filter(isActionOf(channelDeposit.request)), withLatestFrom(state$, config$), mergeMap(([action, state, { subkey: configSubkey }]) => {\n    var _a;\n    const { tokenNetwork, partner } = action.meta;\n    const token = findKey(state.tokens, (tn) => tn === tokenNetwork);\n    if (!token) {\n        const error = new RaidenError(ErrorCodes.CNL_TOKEN_NOT_FOUND, action.meta);\n        return of(channelDeposit.failure(error, action.meta));\n    }\n    const { signer: onchainSigner } = chooseOnchainAccount({ signer, address, main }, (_a = action.payload.subkey) !== null && _a !== void 0 ? _a : configSubkey);\n    const tokenContract = getContractWithSigner(getTokenContract(token), onchainSigner);\n    const tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    const channel = state.channels[tokenNetwork][partner];\n    if ((channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.open) {\n        const error = new RaidenError(ErrorCodes.CNL_NO_OPEN_CHANNEL_FOUND, action.meta);\n        return of(channelDeposit.failure(error, action.meta));\n    }\n    // send approve transaction\n    return from(tokenContract.functions.approve(tokenNetwork, action.payload.deposit)).pipe(assertTx('approve', ErrorCodes.CNL_APPROVE_TRANSACTION_FAILED, { log }), withLatestFrom(state$), mergeMap(([, state]) => \n    // send setTotalDeposit transaction\n    tokenNetworkContract.functions.setTotalDeposit(channel.id, address, state.channels[tokenNetwork][partner].own.deposit.add(action.payload.deposit), partner)), assertTx('setTotalDeposit', ErrorCodes.CNL_SETTOTALDEPOSIT_FAILED, { log }), \n    // if succeeded, return a empty/completed observable\n    // actual ChannelDepositedAction will be detected and handled by channelMonitoredEpic\n    // if any error happened on tx call/pipeline, mergeMap below won't be hit, and catchError\n    // will then emit the channelDeposit.failure action instead\n    ignoreElements(), catchError((error) => of(channelDeposit.failure(error, action.meta))));\n}));\n/**\n * A ChannelClose action requested by user\n * Needs to be called on an opened or closing (for retries) channel.\n * If tx goes through successfuly, stop as ChannelClosed success action will instead be\n * detected and reacted by channelMonitoredEpic. If anything detectable goes wrong, fires a\n * ChannelCloseActionFailed instead\n *\n * @param action$ - Observable of channelClose actions\n * @param state$ - Observable of RaidenStates\n * @param getTokenNetworkContract - RaidenEpicDeps members\n * @returns Observable of channelClose.failure actions\n */\nexport const channelCloseEpic = (action$, state$, { log, signer, address, main, network, getTokenNetworkContract, config$ }) => action$.pipe(filter(isActionOf(channelClose.request)), withLatestFrom(state$, config$), mergeMap(([action, state, { subkey: configSubkey }]) => {\n    var _a, _b, _c;\n    const { tokenNetwork, partner } = action.meta;\n    const { signer: onchainSigner } = chooseOnchainAccount({ signer, address, main }, (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.subkey) !== null && _b !== void 0 ? _b : configSubkey);\n    const tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    const channel = (_c = state.channels[tokenNetwork]) === null || _c === void 0 ? void 0 : _c[partner];\n    if ((channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.open && (channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.closing) {\n        const error = new RaidenError(ErrorCodes.CNL_NO_OPEN_OR_CLOSING_CHANNEL_FOUND, action.meta);\n        return of(channelClose.failure(error, action.meta));\n    }\n    let balanceHash = HashZero, nonce = Zero, additionalHash = HashZero, nonClosingSignature = hexlify(SignatureZero);\n    if (channel.partner.balanceProof) {\n        balanceHash = createBalanceHash(channel.partner.balanceProof.transferredAmount, channel.partner.balanceProof.lockedAmount, channel.partner.balanceProof.locksroot);\n        nonce = channel.partner.balanceProof.nonce;\n        additionalHash = channel.partner.balanceProof.messageHash;\n        nonClosingSignature = channel.partner.balanceProof.signature;\n    }\n    const closingMessage = concat([\n        encode(tokenNetwork, 20),\n        encode(network.chainId, 32),\n        encode(1, 32),\n        encode(channel.id, 32),\n        encode(balanceHash, 32),\n        encode(nonce, 32),\n        encode(additionalHash, 32),\n        encode(nonClosingSignature, 65),\n    ]); // UInt8Array of 277 bytes\n    // sign counter balance proof, then send closeChannel transaction with our signature\n    return from(signer.signMessage(closingMessage)).pipe(mergeMap((closingSignature) => tokenNetworkContract.functions.closeChannel(channel.id, partner, address, balanceHash, nonce, additionalHash, nonClosingSignature, closingSignature)), assertTx('closeChannel', ErrorCodes.CNL_CLOSECHANNEL_FAILED, { log }), \n    // if succeeded, return a empty/completed observable\n    // actual ChannelClosedAction will be detected and handled by channelMonitoredEpic\n    // if any error happened on tx call/pipeline, catchError will then emit the\n    // channelClose.failure action instead\n    ignoreElements(), catchError((error) => of(channelClose.failure(error, action.meta))));\n}));\n/**\n * When detecting a ChannelClosed event, calls updateNonClosingBalanceProof with partner's balance\n * proof, iff there's any\n * TODO: do it only if economically viable (and define what that means)\n *\n * @param action$ - Observable of channelClose.success|newBlock actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps members\n * @returns Empty observable\n */\nexport const channelUpdateEpic = (action$, state$, { log, signer, address, main, network, getTokenNetworkContract, config$ }) => action$.pipe(filter(isActionOf(channelClose.success)), filter((action) => !!action.payload.confirmed), \n// wait 2 newBlock actions go through after channelClose confirmation, to ensure any pending\n// channelSettle could have been processed\nmergeMap((action) => action$.pipe(filter(newBlock.is), skip(1), take(1), mapTo(action))), withLatestFrom(state$, config$), filter(([action, state]) => {\n    var _a;\n    const channel = (_a = state.channels[action.meta.tokenNetwork]) === null || _a === void 0 ? void 0 : _a[action.meta.partner];\n    return ((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.closed &&\n        channel.id === action.payload.id &&\n        !!channel.partner.balanceProof && // there's partners balanceProof (i.e. received transfers)\n        channel.closeParticipant !== address // we're not the closing end\n    );\n}), mergeMap(([action, state, { subkey }]) => {\n    const { tokenNetwork, partner } = action.meta;\n    const { signer: onchainSigner } = chooseOnchainAccount({ signer, address, main }, subkey);\n    const tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    const channel = state.channels[tokenNetwork][partner];\n    // should never happen because of filter, just here to narrow union\n    assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.closed);\n    assert(channel.partner.balanceProof);\n    const balanceHash = createBalanceHash(channel.partner.balanceProof.transferredAmount, channel.partner.balanceProof.lockedAmount, channel.partner.balanceProof.locksroot);\n    const nonce = channel.partner.balanceProof.nonce;\n    const additionalHash = channel.partner.balanceProof.messageHash;\n    const closingSignature = channel.partner.balanceProof.signature;\n    const nonClosingMessage = concat([\n        encode(tokenNetwork, 20),\n        encode(network.chainId, 32),\n        encode(2, 32),\n        encode(channel.id, 32),\n        encode(balanceHash, 32),\n        encode(nonce, 32),\n        encode(additionalHash, 32),\n        encode(closingSignature, 65),\n    ]); // UInt8Array of 277 bytes\n    // send updateNonClosingBalanceProof transaction\n    return from(signer.signMessage(nonClosingMessage)).pipe(mergeMap((nonClosingSignature) => tokenNetworkContract.functions.updateNonClosingBalanceProof(channel.id, partner, address, balanceHash, nonce, additionalHash, closingSignature, nonClosingSignature)), assertTx('updateNonClosingBalanceProof', ErrorCodes.CNL_UPDATE_NONCLOSING_BP_FAILED, {\n        log,\n    }), \n    // if succeeded, return a empty/completed observable\n    ignoreElements(), catchError((error) => {\n        log.error('Error updating non-closing balance-proof, ignoring', error);\n        return EMPTY;\n    }));\n}));\n/**\n * A ChannelSettle action requested by user\n * Needs to be called on an settleable or settling (for retries) channel.\n * If tx goes through successfuly, stop as ChannelSettled success action will instead be\n * detected and reacted by channelMonitoredEpic. If anything detectable goes wrong, fires a\n * ChannelSettleActionFailed instead\n *\n * @param action$ - Observable of channelSettle actions\n * @param state$ - Observable of RaidenStates\n * @param address,getTokenNetworkContract - RaidenEpicDeps members\n * @returns Observable of channelSettle.failure actions\n */\nexport const channelSettleEpic = (action$, state$, { log, signer, address, main, getTokenNetworkContract, config$ }) => action$.pipe(filter(isActionOf(channelSettle.request)), withLatestFrom(state$, config$), mergeMap(([action, state, { subkey: configSubkey }]) => {\n    var _a, _b, _c;\n    const { tokenNetwork, partner } = action.meta;\n    const { signer: onchainSigner } = chooseOnchainAccount({ signer, address, main }, (_b = (_a = action.payload) === null || _a === void 0 ? void 0 : _a.subkey) !== null && _b !== void 0 ? _b : configSubkey);\n    const tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), onchainSigner);\n    const channel = (_c = state.channels[tokenNetwork]) === null || _c === void 0 ? void 0 : _c[partner];\n    if ((channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.settleable && (channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.settling) {\n        const error = new RaidenError(ErrorCodes.CNL_NO_SETTLEABLE_OR_SETTLING_CHANNEL_FOUND, action.meta);\n        return of(channelSettle.failure(error, action.meta));\n    }\n    const zeroBalanceProof = {\n        transferredAmount: Zero,\n        lockedAmount: Zero,\n        locksroot: HashZero,\n    };\n    let part1 = Object.assign({ address: partner }, (channel.partner.balanceProof || zeroBalanceProof)), part2 = Object.assign({ address }, (channel.own.balanceProof || zeroBalanceProof));\n    if (channel.isFirstParticipant)\n        [part1, part2] = [part2, part1];\n    // send settleChannel transaction\n    return from(tokenNetworkContract.functions.settleChannel(channel.id, part1.address, part1.transferredAmount, part1.lockedAmount, part1.locksroot, part2.address, part2.transferredAmount, part2.lockedAmount, part2.locksroot)).pipe(assertTx('settleChannel', ErrorCodes.CNL_SETTLECHANNEL_FAILED, { log }), \n    // if succeeded, return a empty/completed observable\n    // actual ChannelSettledAction will be detected and handled by channelMonitoredEpic\n    // if any error happened on tx call/pipeline, mergeMap below won't be hit, and catchError\n    // will then emit the channelSettle.failure action instead\n    ignoreElements(), catchError((error) => of(channelSettle.failure(error, action.meta))));\n}));\n/**\n * Process newBlocks, emits ChannelSettleableAction if any closed channel is now settleable\n *\n * @param action$ - Observable of newBlock actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of channelSettleable actions\n */\nexport const channelSettleableEpic = (action$, state$) => action$.pipe(filter(isActionOf(newBlock)), withLatestFrom(state$), mergeMap(function* ([{ payload: { blockNumber }, }, state,]) {\n    for (const tokenNetwork in state.channels) {\n        for (const partner in state.channels[tokenNetwork]) {\n            const channel = state.channels[tokenNetwork][partner];\n            if (channel.state === ChannelState.closed &&\n                channel.settleTimeout && // closed channels always have settleTimeout & closeBlock set\n                channel.closeBlock &&\n                blockNumber > channel.closeBlock + channel.settleTimeout) {\n                yield channelSettleable({ settleableBlock: blockNumber }, { tokenNetwork: tokenNetwork, partner: partner });\n            }\n        }\n    }\n}));\n/**\n * When channel is settled, unlock any pending lock on-chain\n * TODO: check if it's worth it to also unlock partner's end\n * TODO: do it only if economically viable (and define what that means)\n *\n * @param action$ - Observable of channelSettle.success actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps members\n * @returns Empty observable\n */\nexport const channelUnlockEpic = (action$, state$, { log, signer, address, main, getTokenNetworkContract, config$ }) => action$.pipe(filter(isActionOf(channelSettle.success)), filter((action) => { var _a; return !!(action.payload.confirmed && ((_a = action.payload.locks) === null || _a === void 0 ? void 0 : _a.length)); }), withLatestFrom(state$, config$), filter(([action, state]) => {\n    var _a;\n    const channel = (_a = state.channels[action.meta.tokenNetwork]) === null || _a === void 0 ? void 0 : _a[action.meta.partner];\n    return !channel || !('id' in channel) || channel.id !== action.payload.id;\n}), mergeMap(([action, , { subkey }]) => {\n    const { tokenNetwork, partner } = action.meta;\n    const tokenNetworkContract = getContractWithSigner(getTokenNetworkContract(tokenNetwork), chooseOnchainAccount({ signer, address, main }, subkey).signer);\n    const locks = concat(action.payload.locks.reduce((acc, lock) => [\n        ...acc,\n        encode(lock.expiration, 32),\n        encode(lock.amount, 32),\n        lock.secrethash,\n    ], []));\n    // send unlock transaction\n    return from(tokenNetworkContract.functions.unlock(action.payload.id, address, partner, locks)).pipe(assertTx('unlock', ErrorCodes.CNL_ONCHAIN_UNLOCK_FAILED, { log }), ignoreElements(), catchError((error) => {\n        log.error('Error unlocking pending locks on-chain, ignoring', error);\n        return EMPTY;\n    }));\n}));\nfunction checkPendingAction(action, provider, blockNumber, confirmationBlocks) {\n    return retryAsync$(() => provider.getTransactionReceipt(action.payload.txHash), provider.pollingInterval).pipe(map((receipt) => {\n        if ((receipt === null || receipt === void 0 ? void 0 : receipt.confirmations) !== undefined && receipt.confirmations >= confirmationBlocks) {\n            return Object.assign(Object.assign({}, action), { \n                // beyond setting confirmed, also re-set blockNumber,\n                // which may have changed on a reorg\n                payload: Object.assign(Object.assign({}, action.payload), { txBlock: receipt.blockNumber, confirmed: true }) });\n        }\n        else if (action.payload.txBlock + 2 * confirmationBlocks < blockNumber) {\n            // if this txs didn't get confirmed for more than 2*confirmationBlocks, it was removed\n            return Object.assign(Object.assign({}, action), { payload: Object.assign(Object.assign({}, action.payload), { confirmed: false }) });\n        } // else, it seems removed, but give it twice confirmationBlocks to be picked up again\n    }), filter(isntNil));\n}\n/**\n * Process new blocks and re-emit confirmed or removed actions\n *\n * @param action$ - Observable of channelSettle actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @param deps.config$,deps.provider - RaidenEpicDeps members\n * @returns Observable of confirmed or removed actions\n */\nexport const confirmationEpic = ({}, state$, { config$, provider }) => combineLatest(state$.pipe(pluckDistinct('blockNumber')), state$.pipe(pluck('pendingTxs')), config$.pipe(pluckDistinct('confirmationBlocks'))).pipe(filter(([, pendingTxs]) => pendingTxs.length > 0), \n// exhaust will ignore blocks while concat$ is busy\nexhaustMap(([blockNumber, pendingTxs, confirmationBlocks]) => concat$(...pendingTxs\n    // only txs/confirmable actions which are more than confirmationBlocks in the past\n    .filter((a) => a.payload.txBlock + confirmationBlocks <= blockNumber)\n    .map((action) => checkPendingAction(action, provider, blockNumber, confirmationBlocks)))));\n//# sourceMappingURL=epics.js.map","import { encodeUri } from 'matrix-js-sdk/lib/utils';\n/**\n * Return server name without schema or path\n *\n * @param server - any URL\n * @returns server URL with domain and port (if present), without schema, paths or query params\n */\nexport function getServerName(server) {\n    const match = /^(?:\\w*:?\\/\\/)?([^/#?&]+)/.exec(server);\n    return match && match[1];\n}\n/**\n * MatrixClient doesn't expose this API, but it does exist, so we create it here\n *\n * @param matrix - an already setup and started MatrixClient\n * @param userId - to fetch status/presence from\n * @returns Promise to object containing status data\n */\nexport function getUserPresence(matrix, userId) {\n    const path = encodeUri('/presence/$userId/status', { $userId: userId });\n    return matrix._http.authedRequest(undefined, 'GET', path);\n}\n//# sourceMappingURL=matrix.js.map","/**\n * Simple Map-based LRU cache\n *\n * @param max - Maximum size of cache\n */\nexport class LruCache {\n    constructor(max) {\n        this.values = new Map();\n        this.max = max;\n    }\n    get(key) {\n        const entry = this.values.get(key);\n        if (entry) {\n            // peek the entry, re-insert for LRU strategy\n            this.values.delete(key);\n            this.values.set(key, entry);\n        }\n        return entry;\n    }\n    put(key, value) {\n        if (this.values.size >= this.max) {\n            // least-recently used cache eviction strategy\n            const keyToDelete = this.values.keys().next().value;\n            this.values.delete(keyToDelete);\n        }\n        this.values.set(key, value);\n    }\n}\n//# sourceMappingURL=lru.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/camelcase */\nimport { combineLatest, from, of, EMPTY, fromEvent, timer, throwError, merge, defer, concat, AsyncSubject, } from 'rxjs';\nimport { catchError, concatMap, delay, distinctUntilChanged, filter, groupBy, ignoreElements, map, mergeMap, withLatestFrom, scan, startWith, switchMap, take, takeUntil, tap, toArray, mapTo, finalize, first, timeout, pluck, repeatWhen, exhaustMap, throwIfEmpty, retryWhen, distinct, delayWhen, takeWhile, bufferTime, endWith, mergeMapTo, } from 'rxjs/operators';\nimport { fromFetch } from 'rxjs/fetch';\nimport find from 'lodash/find';\nimport minBy from 'lodash/minBy';\nimport sortBy from 'lodash/sortBy';\nimport curry from 'lodash/curry';\nimport { getAddress, verifyMessage } from 'ethers/utils';\nimport { createClient, MatrixEvent, } from 'matrix-js-sdk';\nimport { logger as matrixLogger } from 'matrix-js-sdk/lib/logger';\nimport { Capabilities } from '../constants';\nimport { RaidenError, ErrorCodes } from '../utils/error';\nimport { Signed, isntNil, assert, Signature } from '../utils/types';\nimport { isActionOf } from '../utils/actions';\nimport { raidenShutdown } from '../actions';\nimport { channelMonitor } from '../channels/actions';\nimport { MessageType, Processed, SecretRequest, SecretReveal, } from '../messages/types';\nimport { decodeJsonMessage, encodeJsonMessage, getMessageSigner, signMessage, isMessageReceivedOfType, } from '../messages/utils';\nimport { messageSend, messageReceived, messageGlobalSend } from '../messages/actions';\nimport { transferSigned } from '../transfers/actions';\nimport { getServerName, getUserPresence } from '../utils/matrix';\nimport { LruCache } from '../utils/lru';\nimport { pluckDistinct } from '../utils/rx';\nimport { matrixRoom, matrixRoomLeave, matrixSetup, matrixPresence, rtcChannel } from './actions';\n// unavailable just means the user didn't do anything over a certain amount of time, but they're\n// still there, so we consider the user as available/online then\nconst AVAILABLE = ['online', 'unavailable'];\nconst userRe = /^@(0x[0-9a-f]{40})[.:]/i;\nconst DEVICE_ID = 'RAIDEN';\n/**\n * Return the array of configured global rooms\n *\n * @param config - object to gather the list from\n * @returns Array of room names\n */\nfunction globalRoomNames(config) {\n    return [config.discoveryRoom, config.pfsRoom].filter(isntNil);\n}\n/**\n * Curried function (arity=2) which matches room passed as second argument based on roomId, name or\n * alias passed as first argument\n *\n * @param roomIdOrAlias - Room Id, name, canonical or normal alias for room\n * @param room - Room to test\n * @returns True if room matches term, false otherwise\n */\nconst roomMatch = curry((roomIdOrAlias, room) => roomIdOrAlias === room.roomId ||\n    roomIdOrAlias === room.name ||\n    roomIdOrAlias === room.getCanonicalAlias() ||\n    room.getAliases().includes(roomIdOrAlias));\n/**\n * Returns an observable to a (possibly pending) room matching roomId or some alias\n * This method doesn't try to join the room, just wait for it to show up in MatrixClient.\n *\n * @param matrix - Client instance to fetch room info from\n * @param roomIdOrAlias - room id or alias to look for\n * @returns Observable to populated room instance\n */\nfunction getRoom$(matrix, roomIdOrAlias) {\n    let room = matrix.getRoom(roomIdOrAlias);\n    if (!room)\n        room = matrix.getRooms().find(roomMatch(roomIdOrAlias));\n    if (room)\n        return of(room);\n    return fromEvent(matrix, 'Room').pipe(filter(roomMatch(roomIdOrAlias)), take(1));\n}\n/**\n * Joins the global broadcast rooms and returns the room ids.\n *\n * @param config - The {@link RaidenConfig} provides the broadcast room aliases for pfs and discovery.\n * @param matrix - The {@link MatrixClient} instance used to create the filter.\n * @returns Observable of the list of room ids for the the broadcast rooms.\n */\nfunction joinGlobalRooms(config, matrix) {\n    const serverName = getServerName(matrix.getHomeserverUrl());\n    return from(globalRoomNames(config)).pipe(map((globalRoom) => `#${globalRoom}:${serverName}`), mergeMap((alias) => matrix.joinRoom(alias).then((room) => {\n        // set alias in room state directly\n        // this trick is needed because global rooms aren't synced\n        room.currentState.setStateEvents([\n            new MatrixEvent({\n                type: 'm.room.aliases',\n                state_key: serverName,\n                content: { aliases: [alias] },\n                event_id: `$local_${Date.now()}`,\n                room_id: room.roomId,\n                sender: matrix.getUserId(),\n            }),\n        ]);\n        matrix.store.storeRoom(room);\n        return room;\n    })), pluck('roomId'), toArray());\n}\n/**\n * Creates and returns a matrix filter. The filter reduces the size of the initial sync by\n * filtering out broadcast rooms, emphemeral messages like receipts etc.\n *\n * @param matrix - The {@link MatrixClient} instance used to create the filter.\n * @param roomIds - The ids of the rooms to filter out during sync.\n * @returns Observable of the {@link Filter} that was created.\n */\nfunction createFilter(matrix, roomIds) {\n    return defer(() => {\n        const roomFilter = {\n            not_rooms: roomIds,\n            ephemeral: {\n                not_types: ['m.receipt', 'm.typing'],\n            },\n            timeline: {\n                limit: 0,\n                not_senders: [matrix.getUserId()],\n            },\n        };\n        const filterDefinition = {\n            room: roomFilter,\n        };\n        return matrix.createFilter(filterDefinition);\n    });\n}\nfunction startMatrixSync(action$, matrix, matrix$, config$) {\n    return action$.pipe(filter(matrixSetup.is), take(1), tap(() => {\n        matrix$.next(matrix);\n        matrix$.complete();\n    }), delay(1e3), // wait 1s before starting matrix, so event listeners can be registered\n    withLatestFrom(config$), mergeMap(([, config]) => joinGlobalRooms(config, matrix).pipe(mergeMap((roomIds) => createFilter(matrix, roomIds)), mergeMap((filter) => matrix.startClient({ filter })))), ignoreElements());\n}\n/**\n * Search user directory for valid users matching a given address and return latest\n *\n * @param matrix - Matrix client to search users from\n * @param address - Address of interest\n * @param log - Logger object\n * @returns Observable of user with most recent presence\n */\nfunction searchAddressPresence$(matrix, address, { log }) {\n    return defer(() => \n    // search for any user containing the address of interest in its userId\n    matrix.searchUserDirectory({ term: address.toLowerCase() })).pipe(\n    // for every result matches, verify displayName signature is address of interest\n    mergeMap(function* ({ results }) {\n        for (const user of results) {\n            if (!user.display_name)\n                continue;\n            try {\n                const match = userRe.exec(user.user_id);\n                if (!match || getAddress(match[1]) !== address)\n                    continue;\n                const recovered = verifyMessage(user.user_id, user.display_name);\n                if (!recovered || recovered !== address)\n                    continue;\n            }\n            catch (err) {\n                continue;\n            }\n            yield user;\n        }\n    }), mergeMap((user) => getUserPresence(matrix, user.user_id)\n        .then((presence) => (Object.assign(Object.assign({}, presence), user)))\n        .catch((err) => (log.info('Error fetching user presence, ignoring:', err), undefined))), filter(isntNil), toArray(), \n    // for all matched/verified users, get its presence through dedicated API\n    // it's required because, as the user events could already have been handled\n    // and filtered out by matrixPresenceUpdateEpic because it wasn't yet a\n    // user-of-interest, we could have missed presence updates, then we need to\n    // fetch it here directly, and from now on, that other epic will monitor its\n    // updates, and sort by most recently seen user\n    map((presences) => {\n        if (!presences.length)\n            throw new RaidenError(ErrorCodes.TRNS_NO_VALID_USER, { address });\n        return minBy(presences, 'last_active_ago');\n    }));\n}\n/**\n * Parse a caps string in the format 'k1,k2=v2,k3=\"v3\"' to { k1: true, k2: v2, k3: v3 } object\n *\n * @param caps - caps string\n * @returns Caps mapping object\n */\nfunction parseCaps(caps) {\n    var _a;\n    if (!caps)\n        return;\n    const result = {};\n    try {\n        // this regex splits by comma, but respecting strings inside double-quotes\n        for (const cap of caps.split(/,(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/g)) {\n            const match = cap.match(/^\\s*([^=]+)(?: ?= ?\"?(.*?)\"?\\s*)?$/);\n            if (match)\n                result[match[1]] = (_a = match[2]) !== null && _a !== void 0 ? _a : true;\n        }\n        return result;\n    }\n    catch (err) { }\n}\nfunction stringifyCaps(caps) {\n    return Object.entries(caps)\n        .filter(([, v]) => typeof v !== 'boolean' || v)\n        .map(([k, v]) => (typeof v === 'boolean' ? k : `${k}=\"${v}\"`))\n        .join(',');\n}\n/**\n * Returns an observable which keeps inviting userId to roomId while user doesn't join\n *\n * If user already joined, completes immediatelly.\n *\n * @param matrix - client instance\n * @param roomId - room to invite user to\n * @param userId - user to be invited\n * @param config$ - Observable of config object containing httpTimeout used as iteration delay\n * @returns Cold observable which keep inviting user if needed and then completes.\n */\nfunction inviteLoop$(matrix, roomId, userId, config$, { log }) {\n    return defer(() => {\n        const room = matrix.getRoom(roomId);\n        return room\n            ? // use room already present in matrix instance\n                of(room)\n            : // wait for room\n                fromEvent(matrix, 'Room').pipe(filter((room) => room.roomId === roomId), take(1));\n    }).pipe(\n    // stop if user already a room member\n    filter((room) => {\n        const member = room.getMember(userId);\n        return !member || member.membership !== 'join';\n    }), withLatestFrom(config$), mergeMap(([, { httpTimeout }]) => \n    // defer here ensures invite is re-done on repeat (re-subscription)\n    defer(() => matrix.invite(roomId, userId).catch(log.warn.bind(log, 'Error inviting'))).pipe(\n    // while shouldn't stop (by unsubscribe or takeUntil)\n    repeatWhen((completed$) => completed$.pipe(delay(httpTimeout))), takeUntil(\n    // stop repeat+defer loop above when user joins\n    fromEvent(matrix, 'RoomMember.membership', ({}, member) => member).pipe(filter((member) => member.roomId === roomId &&\n        member.userId === userId &&\n        member.membership === 'join'))))));\n}\n/**\n * From a yaml list string, return as Array\n * E.g. yamlListToArray(`\n * # comment\n *   - test1\n *   - test2\n *   - test3\n * `) === ['test1', 'test2', 'test3']\n *\n * @param yml - String containing only YAML list\n * @returns List of strings inside yml-encoded text\n */\nfunction yamlListToArray(yml) {\n    // match all strings starting with optional spaces followed by a dash + space\n    // capturing only the content of the list item, trimming spaces\n    const reg = /^\\s*-\\s*(.+?)\\s*$/gm;\n    const results = [];\n    let match;\n    while ((match = reg.exec(yml))) {\n        results.push(match[1]);\n    }\n    return results;\n}\n/**\n * Given a server name (schema defaults to https:// and is prepended if missing), returns HTTP GET\n * round trip time (time to response)\n *\n * @param server - Server name with or without schema\n * @param httpTimeout - Optional timeout for the HTTP request\n * @returns Promise to a { server, rtt } object, where `rtt` may be NaN\n */\nfunction matrixRTT$(server, httpTimeout) {\n    if (!server.includes('://'))\n        server = 'https://' + server;\n    return defer(() => {\n        const start = Date.now();\n        return fromFetch(server + '/_matrix/client/versions').pipe(timeout(httpTimeout), map(({ ok }) => (ok ? Date.now() : NaN)), catchError(() => of(NaN)), map((end) => ({ server, rtt: end - start })));\n    });\n}\n/**\n * Returns an observable of servers, sorted by response time\n *\n * @param matrixServerLookup - URL containing an YAML list of servers url\n * @param httpTimeout - httpTimeout to limit queries\n * @returns Observable of { server, rtt } objects, emitted in increasing rtt order\n */\nfunction fetchSortedMatrixServers$(matrixServerLookup, httpTimeout) {\n    return fromFetch(matrixServerLookup).pipe(mergeMap((response) => __awaiter(this, void 0, void 0, function* () {\n        assert(response.ok, `Could not fetch server list from \"${matrixServerLookup}\" => ${response.status}`);\n        return response.text();\n    })), timeout(httpTimeout), mergeMap((text) => yamlListToArray(text)), mergeMap((server) => matrixRTT$(server, httpTimeout)), toArray(), mergeMap((rtts) => sortBy(rtts, ['rtt'])), filter(({ rtt }) => !isNaN(rtt)), throwIfEmpty(() => new RaidenError(ErrorCodes.TRNS_NO_MATRIX_SERVERS)));\n}\n/**\n * Validate and setup a MatrixClient connected to server, possibly using previous 'setup' data\n * May error if anything goes wrong.\n *\n * @param server - server URL, with schema\n * @param setup - optional previous setup/credentials data\n * @param deps - RaidenEpicDeps-like/partial object\n * @param deps.address - Our address (to compose matrix user)\n * @param deps.signer - Signer to be used to sign password and displayName\n * @param caps - Transport capabilities to set in user's avatar_url\n * @returns Observable of one { matrix, server, setup } object\n */\nfunction setupMatrixClient$(server, setup, { address, signer }, caps) {\n    const serverName = getServerName(server);\n    if (!serverName)\n        throw new RaidenError(ErrorCodes.TRNS_NO_SERVERNAME, { server });\n    return defer(() => {\n        if (setup) {\n            // if matrixSetup was already issued before, and credentials are already in state\n            const matrix = createClient({\n                baseUrl: server,\n                userId: setup.userId,\n                accessToken: setup.accessToken,\n                deviceId: setup.deviceId,\n            });\n            return of({ matrix, server, setup });\n        }\n        else {\n            const matrix = createClient({ baseUrl: server });\n            const userName = address.toLowerCase(), userId = `@${userName}:${serverName}`;\n            // create password as signature of serverName, then try login or register\n            return from(signer.signMessage(serverName)).pipe(mergeMap((password) => from(matrix.login('m.login.password', { user: userName, password, device_id: DEVICE_ID })).pipe(catchError(() => matrix.register(userName, password)))), mergeMap(({ access_token, device_id }) => {\n                // matrix.register implementation doesn't set returned credentials\n                // which would require an unnecessary additional login request if we didn't\n                // set it here, and login doesn't set deviceId, so we set all credential\n                // parameters again here after successful login or register\n                matrix.deviceId = device_id;\n                matrix._http.opts.accessToken = access_token;\n                matrix.credentials = { userId };\n                // displayName must be signature of full userId for our messages to be accepted\n                return from(signer.signMessage(userId)).pipe(map((signedUserId) => ({\n                    matrix,\n                    server,\n                    setup: {\n                        userId,\n                        accessToken: access_token,\n                        deviceId: device_id,\n                        displayName: signedUserId,\n                    },\n                })));\n            }));\n        }\n    }).pipe(\n    // the APIs below are authenticated, and therefore also act as validator\n    mergeMap(({ matrix, server, setup }) => \n    // ensure displayName is set even on restarts\n    merge(from(matrix.setDisplayName(setup.displayName)), from(matrix.setPresence({ presence: 'online', status_msg: '' })), caps ? from(matrix.setAvatarUrl(stringifyCaps(caps))) : EMPTY).pipe(mapTo({ matrix, server, setup }))));\n}\n/**\n * Initialize matrix transport\n * The matrix client instance will be outputed to RaidenEpicDeps.matrix$ AsyncSubject\n * The setup info (including credentials, for persistence) will be the matrixSetup output action\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param address,network,signer,matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixSetup generated by initializing matrix client\n */\nexport const initMatrixEpic = (action$, {}, { address, signer, matrix$, latest$, config$ }) => combineLatest([latest$.pipe(pluck('state')), config$]).pipe(first(), // at startup\nmergeMap(([state, { matrixServer, matrixServerLookup, httpTimeout, caps }]) => {\n    var _a, _b;\n    const server = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.server, setup = (_b = state.transport.matrix) === null || _b === void 0 ? void 0 : _b.setup;\n    const servers$Array = [];\n    if (matrixServer) {\n        // if config.matrixServer is set, we must use it (possibly re-using stored credentials,\n        // if matching), not fetch from lookup address\n        if (matrixServer === server)\n            servers$Array.push(of({ server, setup }));\n        else\n            servers$Array.push(of({ server: matrixServer }));\n    }\n    else {\n        // previously used server\n        if (server)\n            servers$Array.push(of({ server, setup }));\n        // fetched servers list\n        // notice it may include stored server again, but no stored setup, which could be the\n        // cause of the  first failure, so we allow it to try again (not necessarily first)\n        servers$Array.push(fetchSortedMatrixServers$(matrixServerLookup, httpTimeout));\n    }\n    let lastError;\n    const andSuppress = (err) => ((lastError = err), EMPTY);\n    // on [re-]subscription (defer), pops next observable and subscribe to it\n    return defer(() => servers$Array.shift() || EMPTY).pipe(catchError(andSuppress), // servers$ may error, so store lastError\n    concatMap(({ server, setup }) => \n    // serially, try setting up client and validate its credential\n    setupMatrixClient$(server, setup, { address, signer }, caps).pipe(\n    // store and suppress any 'setupMatrixClient$' error\n    catchError(andSuppress))), \n    // on first setupMatrixClient$'s success, emit, complete and unsubscribe\n    first(), tap(({ matrix }) => matrix.setMaxListeners(30)), \n    // with errors suppressed, only possible error here is 'no element in sequence'\n    retryWhen((err$) => \n    // if there're more servers$ observables in queue, emit once to retry from defer;\n    // else, errors output with lastError to unsubscribe\n    err$.pipe(mergeMap(() => (servers$Array.length ? of(null) : throwError(lastError))))));\n}), \n// on success\nmergeMap(({ matrix, server, setup }) => merge(\n// wait for matrixSetup through reducer, then resolves matrix$ with client and starts it\nstartMatrixSync(action$, matrix, matrix$, config$), \n// emit matrixSetup in parallel to be persisted in state\nof(matrixSetup({ server, setup })), \n// monitor config.logger & disable or re-enable matrix's logger accordingly\nconfig$.pipe(pluckDistinct('logger'), tap((logger) => matrixLogger.setLevel(logger || 'silent', false)), ignoreElements()))));\n/**\n * Calls matrix.stopClient when raiden is shutting down, i.e. action$ completes\n *\n * @param action$ - Observable of matrixSetup actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Empty observable (whole side-effect on matrix instance)\n */\nexport const matrixShutdownEpic = (action$, {}, { matrix$ }) => matrix$.pipe(mergeMap((matrix) => action$.pipe(finalize(() => {\n    matrix.setPresence({ presence: 'offline', status_msg: '' }).catch(() => {\n        /* stopping, ignore exceptions */\n    });\n    matrix.stopClient();\n}))), ignoreElements());\n/**\n * Handles MatrixRequestMonitorPresenceAction and emits a MatrixPresenceUpdateAction\n * If presence is already known, emits it, else fetch from user profile\n * Even if the presence stays the same, we emit a MatrixPresenceUpdateAction, as this may be a\n * request being waited by a promise or something like that\n * IOW: every request should be followed by a presence update or a failed action, but presence\n * updates may happen later without new requests (e.g. when the user goes offline)\n *\n * @param action$ - Observable of matrixPresence.request actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of presence updates or fail action\n */\nexport const matrixMonitorPresenceEpic = (action$, {}, { matrix$, latest$, log }) => action$.pipe(filter(isActionOf(matrixPresence.request)), \n// this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\nmergeMap((action) => matrix$.pipe(map((matrix) => ({ action, matrix })))), groupBy(({ action }) => action.meta.address), mergeMap((grouped$) => grouped$.pipe(withLatestFrom(latest$.pipe(pluckDistinct('presences'))), \n// if we're already fetching presence for this address, no need to fetch again\nexhaustMap(([{ action, matrix }, presences]) => action.meta.address in presences\n    ? // we already monitored/saw this user's presence\n        of(presences[action.meta.address])\n    : searchAddressPresence$(matrix, action.meta.address, { log }).pipe(map(({ presence, user_id: userId, avatar_url }) => matrixPresence.success({\n        userId,\n        available: AVAILABLE.includes(presence),\n        ts: Date.now(),\n        caps: parseCaps(avatar_url),\n    }, action.meta)), catchError((err) => of(matrixPresence.failure(err, action.meta))))))));\n/**\n * Monitor peers matrix presence from User.presence events\n * We aggregate all users of interest (i.e. for which a monitor request was emitted at some point)\n * and emit presence updates for any presence change happening to a user validating to this address\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of presence updates\n */\nexport const matrixPresenceUpdateEpic = (action$, {}, { log, matrix$, latest$ }) => matrix$\n    .pipe(\n// when matrix finishes initialization, register to matrix presence events\nswitchMap((matrix) => \n// matrix's 'User.presence' sometimes fail to fire, but generic 'event' is always fired,\n// and User (retrieved via matrix.getUser) is up-to-date before 'event' emits\nfromEvent(matrix, 'event').pipe(map((event) => ({ event, matrix })))), filter(({ event }) => event.getType() === 'm.presence'), \n// parse peer address from userId\nmap(({ event, matrix }) => {\n    // as 'event' is emitted after user is (created and) updated, getUser always returns it\n    const user = matrix.getUser(event.getSender());\n    if (!user || !user.presence)\n        return;\n    const match = userRe.exec(user.userId), peerAddress = match && match[1];\n    if (!peerAddress)\n        return;\n    // getAddress will convert any valid address into checksummed-format\n    const address = getAddress(peerAddress);\n    if (!address)\n        return;\n    return { matrix, user, address };\n}), \n// filter out events without userId in the right format (startWith hex-address)\nfilter(isntNil), withLatestFrom(\n// observable of all addresses whose presence monitoring was requested since init\naction$.pipe(filter(isActionOf(matrixPresence.request)), scan((toMonitor, request) => toMonitor.add(request.meta.address), new Set()), startWith(new Set())), \n// known presences as { address: <last seen MatrixPresenceUpdateAction> } mapping\nlatest$.pipe(pluckDistinct('presences'))), \n// filter out events from users we don't care about\n// i.e.: presence monitoring never requested\nfilter(([{ address }, toMonitor]) => toMonitor.has(address)), mergeMap(([{ matrix, user, address }, , presences]) => {\n    // first filter can't tell typescript this property will always be set!\n    const userId = user.userId, presence = user.presence, available = AVAILABLE.includes(presence);\n    if (address in presences &&\n        presences[address].payload.userId === userId &&\n        presences[address].payload.available === available)\n        // even if signature verification passes, this wouldn't change presence, so return early\n        return EMPTY;\n    // fetch profile info if user have no valid displayName set\n    const profile$ = Signature.is(user.displayName)\n        ? of({ displayname: user.displayName, avatar_url: user.avatarUrl })\n        : defer(() => matrix.getProfileInfo(userId));\n    return profile$.pipe(map((profile) => {\n        var _a;\n        // errors raised here will be logged and ignored on catchError below\n        assert(profile === null || profile === void 0 ? void 0 : profile.displayname, 'no displayname');\n        // ecrecover address, validating displayName is the signature of the userId\n        const recovered = verifyMessage(userId, profile.displayname);\n        assert(recovered === address, `invalid displayname signature: ${recovered} !== ${address}`);\n        return matrixPresence.success({\n            userId,\n            available,\n            ts: (_a = user.lastPresenceTs) !== null && _a !== void 0 ? _a : Date.now(),\n            caps: parseCaps(profile.avatar_url),\n        }, { address: recovered });\n    }), catchError((err) => (log.debug('Error validating presence event, ignoring', err), EMPTY)));\n}))\n    .pipe(withLatestFrom(latest$), \n// filter out if presence update is to offline, and address became online in another user\nfilter(([action, { presences }]) => action.payload.available ||\n    !(action.meta.address in presences) ||\n    !presences[action.meta.address].payload.available ||\n    action.payload.userId === presences[action.meta.address].payload.userId), pluck(0));\n/**\n * Create room (if needed) for a transfer's target, channel's partner or, as a fallback, for any\n * recipient of a messageSend.request action\n *\n * @param action$ - Observable of transferSigned|channelMonitor|messageSend.request actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixRoom actions\n */\nexport const matrixCreateRoomEpic = (action$, {}, { log, matrix$, latest$ }) => \n// actual output observable, selects addresses of interest from actions\naction$.pipe(\n// ensure there's a room for address of interest for each of these actions\n// matrixRoomLeave ensures a new room is created if all we had are forgotten/left\nfilter(isActionOf([transferSigned, channelMonitor, messageSend.request, matrixRoomLeave])), map((action) => isActionOf(transferSigned, action)\n    ? action.payload.message.target\n    : isActionOf(channelMonitor, action)\n        ? action.meta.partner\n        : action.meta.address), \n// groupby+mergeMap ensures different addresses are processed in parallel, and also\n// prevents one stuck address observable (e.g. presence delayed) from holding whole queue\ngroupBy((address) => address), mergeMap((grouped$) => grouped$.pipe(\n// this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\nmergeMap((address) => matrix$.pipe(map((matrix) => ({ address, matrix })))), \n// exhaustMap is used to prevent bursts of actions for a given address (eg. on startup)\n// of creating multiple rooms for same address, so we ignore new address items while\n// previous is being processed. If user roams, matrixInviteEpic will re-invite\nexhaustMap(({ address, matrix }) => \n// presencesStateReplay$+take(1) acts like withLatestFrom with cached result\nlatest$.pipe(\n// wait for user to be monitored\nfilter(({ presences }) => address in presences), take(1), \n// if there's already a room in state for address, skip\nfilter(({ state }) => { var _a, _b, _c; return !((_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[address]) === null || _c === void 0 ? void 0 : _c[0]); }), \n// else, create a room, invite known user and persist roomId in state\nmergeMap(({ presences }) => matrix.createRoom({\n    visibility: 'private',\n    invite: [presences[address].payload.userId],\n})), map(({ room_id: roomId }) => matrixRoom({ roomId }, { address })), catchError((err) => (log.error('Error creating room, ignoring', err), EMPTY)))))));\n/**\n * Invites users coming online to main room we may have with them\n *\n * This also keeps retrying inviting every config.httpTimeout (default=30s) while user doesn't\n * accept our invite or don't invite or write to us to/in another room.\n *\n * @param action$ - Observable of matrixPresence.success actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @param deps.matrix$ - MatrixClient AsyncSubject\n * @param deps.config$ - RaidenConfig BehaviorSubject\n * @returns Empty observable (whole side-effect on matrix instance)\n */\nexport const matrixInviteEpic = (action$, {}, { matrix$, config$, latest$, log }) => action$.pipe(filter(isActionOf(matrixPresence.success)), groupBy((a) => a.meta.address), mergeMap((grouped$) => \n// grouped$ is one observable of presence actions per partners address\ngrouped$.pipe(\n// action comes only after matrix$ is started, so it's safe to use withLatestFrom\nwithLatestFrom(matrix$), \n// switchMap on new presence action for address\nswitchMap(([action, matrix]) => \n// if not available, do nothing (and unsubscribe from previous observable)\n!action.payload.available\n    ? EMPTY\n    : latest$.pipe(map(({ state }) => { var _a, _b, _c; return (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[action.meta.address]) === null || _c === void 0 ? void 0 : _c[0]; }), distinctUntilChanged(), switchMap((roomId) => concat(of(roomId), !roomId\n        ? EMPTY\n        : // re-trigger invite loop if user leaves\n            fromEvent(matrix, 'RoomMember.membership', ({}, member) => member).pipe(filter((member) => member.roomId === roomId &&\n                member.userId === action.payload.userId &&\n                member.membership === 'leave'), mapTo(roomId)))), \n    // switchMap on main roomId change\n    switchMap((roomId) => !roomId\n        ? // if roomId not set, do nothing and unsubscribe\n            EMPTY\n        : // while subscribed and user didn't join, invite every httpTimeout=30s\n            inviteLoop$(matrix, roomId, action.payload.userId, config$, { log })))))), ignoreElements());\n/**\n * Handle invites sent to us and accepts them iff sent by a monitored user\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixRoom actions\n */\nexport const matrixHandleInvitesEpic = ({}, {}, { log, matrix$, config$, latest$ }) => matrix$.pipe(\n// when matrix finishes initialization, register to matrix invite events\nswitchMap((matrix) => fromEvent(matrix, 'RoomMember.membership', (event, member) => ({ event, member, matrix }))), filter(\n// filter for invite events to us\n({ member, matrix }) => member.userId === matrix.getUserId() && member.membership === 'invite'), withLatestFrom(config$), mergeMap(([{ event, member, matrix }, { httpTimeout }]) => {\n    const sender = event.getSender(), senderPresence$ = latest$.pipe(pluckDistinct('presences'), map((presences) => find(presences, (p) => p.payload.userId === sender)), filter(isntNil), take(1), \n    // Don't wait more than some arbitrary time for this sender presence update to show\n    // up; completes without emitting anything otherwise, ending this pipeline.\n    // This also works as a filter to continue processing invites only for monitored\n    // users, as it'll complete without emitting if no MatrixPresenceUpdateAction is\n    // found for sender in time\n    takeUntil(timer(httpTimeout)));\n    return senderPresence$.pipe(map((senderPresence) => ({ matrix, member, senderPresence })));\n}), mergeMap(({ matrix, member, senderPresence }) => \n// join room and emit MatrixRoomAction to make it default/first option for sender address\nfrom(matrix.joinRoom(member.roomId, { syncRoom: true })).pipe(mapTo(matrixRoom({ roomId: member.roomId }, { address: senderPresence.meta.address })), catchError((err) => (log.error('Error joining invited room, ignoring', err), EMPTY)))));\n/**\n * Leave any excess room for a partner when creating or joining a new one.\n * Excess rooms are LRU beyond a given threshold (configurable, default=3) in address's rooms\n * queue and are checked (only) when a new one is added to it.\n *\n * @param action$ - Observable of matrixRoom actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixRoomLeave actions\n */\nexport const matrixLeaveExcessRoomsEpic = (action$, state$, { log, matrix$, config$ }) => action$.pipe(\n// act whenever a new room is added to the address queue in state\nfilter(isActionOf(matrixRoom)), \n// this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\nmergeMap((action) => matrix$.pipe(map((matrix) => ({ action, matrix })))), withLatestFrom(state$, config$), mergeMap(([{ action, matrix }, state, { matrixExcessRooms }]) => {\n    var _a, _b, _c;\n    const rooms = (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[action.meta.address]) !== null && _c !== void 0 ? _c : [];\n    return from(rooms.filter(({}, i) => i >= matrixExcessRooms)).pipe(mergeMap((roomId) => matrix\n        .leave(roomId)\n        .catch((err) => log.error('Error leaving excess room, ignoring', err))\n        .then(() => roomId)), map((roomId) => matrixRoomLeave({ roomId }, action.meta)));\n}));\n/**\n * Leave any room which is neither global nor known as a room for some user of interest\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Empty observable (whole side-effect on matrix instance)\n */\nexport const matrixLeaveUnknownRoomsEpic = ({}, state$, { log, matrix$, config$ }) => matrix$.pipe(\n// when matrix finishes initialization, register to matrix Room events\nswitchMap((matrix) => fromEvent(matrix, 'Room').pipe(map((room) => ({ matrix, roomId: room.roomId })))), \n// this room may become known later for some reason, so wait a little\ndelayWhen(() => config$.pipe(first(), mergeMap(({ httpTimeout }) => timer(httpTimeout)))), withLatestFrom(state$, config$), \n// filter for leave events to us\nfilter(([{ matrix, roomId }, state, config]) => {\n    var _a, _b;\n    const room = matrix.getRoom(roomId);\n    if (!room)\n        return false; // room already gone while waiting\n    const globalRooms = globalRoomNames(config);\n    if (room.name && globalRooms.some((g) => room.name.match(`#${g}:`)))\n        return false;\n    const rooms = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) !== null && _b !== void 0 ? _b : {};\n    for (const address in rooms) {\n        for (const roomId of rooms[address]) {\n            if (roomId === room.roomId)\n                return false;\n        }\n    }\n    return true;\n}), mergeMap(([{ matrix, roomId }]) => __awaiter(void 0, void 0, void 0, function* () {\n    log.warn('Unknown room in matrix, leaving', roomId);\n    return matrix\n        .leave(roomId)\n        .catch((err) => log.error('Error leaving unknown room, ignoring', err));\n})), ignoreElements());\n/**\n * If we leave a room for any reason (eg. a kick event), purge it from state\n * Notice excess rooms left by matrixLeaveExcessRoomsEpic are cleaned before the matrix event is\n * detected, and then no MatrixRoomLeaveAction is emitted for them by this epic.\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of matrixRoomLeave actions\n */\nexport const matrixCleanLeftRoomsEpic = ({}, state$, { log, matrix$ }) => matrix$.pipe(\n// when matrix finishes initialization, register to matrix invite events\nswitchMap((matrix) => fromEvent(matrix, 'Room.myMembership', (room, membership) => ({ room, membership, matrix }))), \n// filter for leave events to us\nfilter(({ membership }) => membership === 'leave'), withLatestFrom(state$), mergeMap(function* ([{ room }, state]) {\n    var _a, _b;\n    const rooms = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) !== null && _b !== void 0 ? _b : {};\n    for (const address in rooms) {\n        for (const roomId of rooms[address]) {\n            if (roomId === room.roomId) {\n                log.warn('Left event for peer room detected, forgetting', address, roomId);\n                yield matrixRoomLeave({ roomId }, { address: address });\n            }\n        }\n    }\n}));\n/**\n * If some room we had with a peer doesn't show up in transport, forget it\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps members\n * @returns Observable of matrixRoomLeave actions\n */\nexport const matrixCleanMissingRoomsEpic = ({}, state$, { log, matrix$, config$ }) => state$.pipe(pluckDistinct('transport', 'matrix'), mergeMap(function* (matrix) {\n    var _a;\n    const rooms = (_a = matrix === null || matrix === void 0 ? void 0 : matrix.rooms) !== null && _a !== void 0 ? _a : {};\n    for (const address in rooms) {\n        for (const roomId of rooms[address]) {\n            yield { roomId, address: address };\n        }\n    }\n}), distinct(({ roomId }) => roomId), mergeMap(({ roomId, address }) => matrix$.pipe(map((matrix) => ({ matrix, roomId, address })))), withLatestFrom(config$), mergeMap(([{ roomId, address, matrix }, { httpTimeout }]) => getRoom$(matrix, roomId).pipe(\n// wait for room to show up in MatrixClient; if it doesn't, clean up\ntimeout(httpTimeout), ignoreElements(), catchError(() => {\n    log.warn('Peer room in state not found in matrix, forgetting', address, roomId);\n    return of(matrixRoomLeave({ roomId }, { address }));\n}))));\nfunction waitMemberAndSend$(address, matrix, type, content, // eslint-disable-line @typescript-eslint/no-explicit-any\n{ log, latest$, config$ }, allowRtc = false) {\n    const RETRY_COUNT = 3; // is this relevant enough to become a constant/setting?\n    return latest$.pipe(filter(({ presences }) => address in presences), take(1), mergeMap(({ rtc }) => {\n        var _a;\n        // if available & open, use channel\n        if (allowRtc && ((_a = rtc === null || rtc === void 0 ? void 0 : rtc[address]) === null || _a === void 0 ? void 0 : _a.readyState) === 'open')\n            return of(rtc[address]);\n        // else, wait for member to join in the first room, and return roomId\n        return latest$.pipe(map(({ state }) => { var _a, _b, _c; return (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[address]) === null || _c === void 0 ? void 0 : _c[0]; }), \n        // wait for a room to exist (created or invited) for address\n        filter(isntNil), distinctUntilChanged(), \n        // this switchMap unsubscribes from previous \"wait\" if first room for address changes\n        switchMap((roomId) => \n        // get/wait room object for roomId\n        // may wait for the room state to be populated (happens after createRoom resolves)\n        getRoom$(matrix, roomId).pipe(mergeMap((room) => \n        // wait for address to be monitored & online (after getting Room for address)\n        // latest$ ensures it happens immediatelly if all conditions are satisfied\n        latest$.pipe(pluck('presences', address), map((presence) => { var _a; return ((_a = presence === null || presence === void 0 ? void 0 : presence.payload) === null || _a === void 0 ? void 0 : _a.available) ? presence.payload.userId : undefined; }), distinctUntilChanged(), map((userId) => ({ room, userId })))), \n        // when user is online, get room member for partner's userId\n        // this switchMap unsubscribes from previous wait if userId changes or go offline\n        switchMap(({ room, userId }) => {\n            if (!userId)\n                return EMPTY; // user not monitored or not available\n            const member = room.getMember(userId);\n            // if it already joined room, return its membership\n            if (member && member.membership === 'join')\n                return of(member);\n            // else, wait for the user to join/accept invite\n            return fromEvent(matrix, 'RoomMember.membership', ({}, member) => member).pipe(filter((member) => member.roomId === room.roomId &&\n                member.userId === userId &&\n                member.membership === 'join'));\n        }), pluck('roomId'))));\n    }), take(1), // use first room/user which meets all requirements/filters above\n    mergeMap((via) => defer(() => typeof via === 'string'\n        ? matrix.sendEvent(via, type, content, '') // via room\n        : via.send(content.body)).pipe(\n    // this returned value is just for notification, and shouldn't be relayed on\n    // all functionality is provided as side effects of the subscription\n    mapTo(typeof via === 'string' ? via : via.label), retryWhen((err$) => \n    // if sendEvent throws, omit & retry after httpTimeout / N,\n    // up to RETRY_COUNT times; if it continues to error, throws down\n    err$.pipe(withLatestFrom(config$), mergeMap(([err, { httpTimeout }], i) => {\n        if (i < RETRY_COUNT - 1) {\n            log.warn(`messageSend error, retrying ${i + 1}/${RETRY_COUNT}`, err);\n            return timer(httpTimeout / RETRY_COUNT);\n            // give up\n        }\n        else\n            return throwError(err);\n    }))))));\n}\n/**\n * Handles a [[messageSend.request]] action and send its message to the first room on queue for\n * address\n *\n * @param action$ - Observable of messageSend.request actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of messageSend.success actions\n */\nexport const matrixMessageSendEpic = (action$, {}, { log, matrix$, config$, latest$ }) => action$.pipe(filter(isActionOf(messageSend.request)), \n// this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\nmergeMap((action) => matrix$.pipe(map((matrix) => ({ action, matrix })))), groupBy(({ action }) => action.meta.address), \n// merge all inner/grouped observables, so different user's \"queues\" can be parallel\nmergeMap((grouped$) => \n// per-user \"queue\"\ngrouped$.pipe(\n// each per-user \"queue\" (observable) are processed serially (because concatMap)\n// TODO: batch all pending messages in a single send message request, with retry\nconcatMap(({ action, matrix }) => {\n    const body = typeof action.payload.message === 'string'\n        ? action.payload.message\n        : encodeJsonMessage(action.payload.message);\n    const content = { body, msgtype: 'm.text' };\n    // wait for address to be monitored, online & have joined a non-global room with us\n    return waitMemberAndSend$(action.meta.address, matrix, 'm.room.message', content, { log, latest$, config$ }, true).pipe(mapTo(messageSend.success(undefined, action.meta)), catchError((err) => {\n        log.error('messageSend error', err, action.meta);\n        return of(messageSend.failure(err, action.meta));\n    }));\n}))));\n/**\n * Handles a [[messageGlobalSend]] action and send one-shot message to a global room\n *\n * @param action$ - Observable of messageGlobalSend actions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Empty observable (whole side-effect on matrix instance)\n */\nexport const matrixMessageGlobalSendEpic = (action$, {}, { log, matrix$, config$ }) => \n// actual output observable, gets/wait for the user to be in a room, and then sendMessage\naction$.pipe(filter(isActionOf(messageGlobalSend)), \n// this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value\nmergeMap((action) => matrix$.pipe(map((matrix) => ({ action, matrix })))), withLatestFrom(config$), mergeMap(([{ action, matrix }, config]) => {\n    const globalRooms = globalRoomNames(config);\n    if (!globalRooms.includes(action.meta.roomName)) {\n        log.warn('messageGlobalSend for unknown global room, ignoring', action.meta.roomName, globalRooms);\n        return EMPTY;\n    }\n    const serverName = getServerName(matrix.getHomeserverUrl()), roomAlias = `#${action.meta.roomName}:${serverName}`;\n    return getRoom$(matrix, roomAlias).pipe(\n    // send message!\n    mergeMap((room) => {\n        const body = typeof action.payload.message === 'string'\n            ? action.payload.message\n            : encodeJsonMessage(action.payload.message);\n        return matrix.sendEvent(room.roomId, 'm.room.message', { body, msgtype: 'm.text' }, '');\n    }), catchError((err) => {\n        log.error('Error sending message to global room', action.meta, action.payload.message, err);\n        return EMPTY;\n    }));\n}), ignoreElements());\nfunction parseMessage(line, // eslint-disable-line @typescript-eslint/no-explicit-any\naddress, { log }) {\n    if (typeof line !== 'string')\n        return;\n    try {\n        const message = decodeJsonMessage(line);\n        // if Signed, accept only if signature matches sender address\n        if ('signature' in message) {\n            const signer = getMessageSigner(message);\n            if (signer !== address)\n                throw new RaidenError(ErrorCodes.TRNS_MESSAGE_SIGNATURE_MISMATCH, {\n                    sender: address,\n                    signer,\n                });\n        }\n        return message;\n    }\n    catch (err) {\n        log.warn(`Could not decode message: ${line}: ${err}`);\n    }\n}\n/**\n * Subscribe to matrix messages and emits MessageReceivedAction upon receiving a valid message from\n * an user of interest (one valid signature from an address we monitor) in a room we have for them\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param matrix$ - RaidenEpicDeps members\n * @returns Observable of messageReceived actions\n */\nexport const matrixMessageReceivedEpic = ({}, {}, { log, matrix$, config$, latest$ }) => \n// gets/wait for the user to be in a room, and then sendMessage\nmatrix$.pipe(\n// when matrix finishes initialization, register to matrix timeline events\nswitchMap((matrix) => fromEvent(matrix, 'Room.timeline', (event, room) => ({ matrix, event, room }))), withLatestFrom(config$), \n// filter for text messages not from us and not from global rooms\nfilter(([{ matrix, event, room }, config]) => {\n    var _a, _b;\n    return event.getType() === 'm.room.message' &&\n        ((_b = (_a = event.event) === null || _a === void 0 ? void 0 : _a.content) === null || _b === void 0 ? void 0 : _b.msgtype) === 'm.text' &&\n        event.getSender() !== matrix.getUserId() &&\n        !globalRoomNames(config).some((g) => \n        // generate an alias for global room of given name, and check if room matches\n        roomMatch(`#${g}:${getServerName(matrix.getHomeserverUrl())}`, room));\n}), mergeMap(([{ event, room }, { httpTimeout }]) => latest$.pipe(filter(({ presences, state }) => {\n    var _a, _b, _c;\n    const presence = find(presences, ['payload.userId', event.getSender()]);\n    if (!presence)\n        return false;\n    const rooms = (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[presence.meta.address]) !== null && _c !== void 0 ? _c : [];\n    if (!rooms.includes(room.roomId))\n        return false;\n    return true;\n}), take(1), \n// take up to an arbitrary timeout to presence status for the sender\n// AND the room in which this message was sent to be in sender's address room queue\ntakeUntil(timer(httpTimeout)), mergeMap(function* ({ presences }) {\n    var _a;\n    const presence = find(presences, ['payload.userId', event.getSender()]);\n    for (const line of (event.event.content.body || '').split('\\n')) {\n        const message = parseMessage(line, presence.meta.address, { log });\n        yield messageReceived({\n            text: line,\n            message,\n            ts: (_a = event.event.origin_server_ts) !== null && _a !== void 0 ? _a : Date.now(),\n            userId: presence.payload.userId,\n            roomId: room.roomId,\n        }, presence.meta);\n    }\n}))));\n/**\n * If matrix received a message from user in a room we have with them, but not the first on queue,\n * update queue so this room goes to the front and will be used as send message room from now on\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of matrixRoom actions\n */\nexport const matrixMessageReceivedUpdateRoomEpic = (action$, state$) => action$.pipe(filter(messageReceived.is), withLatestFrom(state$), filter(([action, state]) => {\n    var _a, _b, _c;\n    const rooms = (_c = (_b = (_a = state.transport.matrix) === null || _a === void 0 ? void 0 : _a.rooms) === null || _b === void 0 ? void 0 : _b[action.meta.address]) !== null && _c !== void 0 ? _c : [];\n    return (!!action.payload.roomId &&\n        rooms.includes(action.payload.roomId) &&\n        rooms[0] !== action.payload.roomId);\n}), map(([action]) => matrixRoom({ roomId: action.payload.roomId }, action.meta)));\n/**\n * Channel monitoring triggers matrix presence monitoring for partner\n *\n * @param action$ - Observable of RaidenActions\n * @returns Observable of matrixPresence.request actions\n */\nexport const matrixMonitorChannelPresenceEpic = (action$) => action$.pipe(filter(isActionOf(channelMonitor)), map((action) => matrixPresence.request(undefined, { address: action.meta.partner })));\n/**\n * Sends Delivered for specific messages\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @param signer - RaidenEpicDeps members\n * @returns Observable of messageSend.request actions\n */\nexport const deliveredEpic = (action$, {}, { log, signer, latest$ }) => {\n    const cache = new LruCache(32);\n    return action$.pipe(filter(isMessageReceivedOfType([Signed(Processed), Signed(SecretRequest), Signed(SecretReveal)])), withLatestFrom(latest$), filter(([action, { presences }]) => {\n        var _a;\n        return action.meta.address in presences &&\n            // skip if peer supports Capabilities.NO_DELIVERY\n            !((_a = presences[action.meta.address].payload.caps) === null || _a === void 0 ? void 0 : _a[Capabilities.NO_DELIVERY]);\n    }), concatMap(([action]) => {\n        const message = action.payload.message;\n        // defer causes the cache check to be performed at subscription time\n        return defer(() => {\n            const msgId = message.message_identifier;\n            const key = msgId.toString();\n            const cached = cache.get(key);\n            if (cached)\n                return of(messageSend.request({ message: cached }, { address: action.meta.address, msgId: key }));\n            const delivered = {\n                type: MessageType.DELIVERED,\n                delivered_message_identifier: msgId,\n            };\n            log.info(`Signing \"${delivered.type}\" for \"${message.type}\" with id=${msgId.toString()}`);\n            return from(signMessage(signer, delivered, { log })).pipe(tap((signed) => cache.put(key, signed)), map((signed) => messageSend.request({ message: signed }, { address: action.meta.address, msgId: key })));\n        });\n    }));\n};\n// fetches and caches matrix set turnServer\nconst _matrixIceServersCache = new WeakMap();\nfunction getMatrixIceServers(matrix) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const cached = _matrixIceServersCache.get(matrix);\n        if (cached && Date.now() < cached[0])\n            return cached[1];\n        const fetched = (yield matrix.turnServer());\n        // if request returns nothing, caches empty list for 1h\n        let expire = Date.now() + 36e5;\n        const servers = [];\n        if (fetched && 'uris' in fetched) {\n            servers.push({\n                urls: fetched.uris,\n                username: fetched.username,\n                credentialType: 'password',\n                credential: fetched.password,\n            });\n            expire = Date.now() + fetched.ttl * 1e3;\n        }\n        _matrixIceServersCache.set(matrix, [expire, servers]);\n        return servers;\n    });\n}\n// creates a filter function which filters valid MatrixEvents\nfunction filterMatrixVoipEvents(type, sender, callId, httpTimeout) {\n    const contentKey = (type === 'm.call.invite'\n        ? 'offer'\n        : type === 'm.call.answer'\n            ? 'answer'\n            : type === 'm.call.candidates'\n                ? 'candidates'\n                : undefined);\n    return (\n    // FIXME: remove any when MatrixEvent type exposes getAge & getContent methods\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    event) => {\n        var _a, _b, _c, _d;\n        return event.getType() === type &&\n            event.getSender() === sender &&\n            ((_a = event.getContent()) === null || _a === void 0 ? void 0 : _a.call_id) === callId &&\n            (!httpTimeout || event.getAge() <= ((_c = (_b = event.getContent()) === null || _b === void 0 ? void 0 : _b.lifetime) !== null && _c !== void 0 ? _c : httpTimeout)) &&\n            (!contentKey || !!((_d = event.getContent()) === null || _d === void 0 ? void 0 : _d[contentKey]));\n    };\n}\n// setup candidates$ handlers\nfunction handleCandidates$(connection, matrix, start$, { callId, peerId, peerAddress }, { log, latest$, config$ }) {\n    return merge(\n    // when seeing an icecandidate, send it to peer\n    fromEvent(connection, 'icecandidate').pipe(pluck('candidate'), delayWhen(() => start$), takeWhile(isntNil), bufferTime(10), filter((candidates) => candidates.length > 0), tap((e) => log.debug('RTC: got candidates', callId, e)), mergeMap((candidates) => waitMemberAndSend$(peerAddress, matrix, 'm.call.candidates', { call_id: callId, version: 0, candidates }, { log, latest$, config$ }))), \n    // when receiving candidates from peer, add it locally\n    fromEvent(matrix, 'event').pipe(filter(filterMatrixVoipEvents('m.call.candidates', peerId, callId)), tap((e) => log.debug('RTC: received candidates', callId, e.getContent().candidates)), mergeMap((event) => { var _a; return from((_a = event.getContent().candidates) !== null && _a !== void 0 ? _a : []); }), mergeMap((candidate) => defer(() => connection.addIceCandidate(candidate)).pipe(catchError((err) => {\n        log.error('RTC: error setting candidate, ignoring', err);\n        return EMPTY;\n    }))))).pipe(ignoreElements());\n}\n// setup RTC data channel for caller\nfunction setupCallerDataChannel$(matrix, start$, info, { httpTimeout, fallbackIceServers }, deps) {\n    const { callId, peerId, peerAddress } = info;\n    const { log, latest$, config$ } = deps;\n    return from(getMatrixIceServers(matrix)).pipe(mergeMap((matrixTurnServers) => {\n        const connection = new RTCPeerConnection({\n            iceServers: [...matrixTurnServers, ...fallbackIceServers],\n        });\n        // we relay on retries, no need to enforce ordered\n        const dataChannel = connection.createDataChannel(callId, { ordered: false });\n        return merge(\n        // despite 'never' emitting, candidates$ have side-effects while/when subscribed\n        handleCandidates$(connection, matrix, start$, info, deps), defer(() => connection.createOffer()).pipe(mergeMap((offer) => {\n            connection.setLocalDescription(offer);\n            const content = {\n                call_id: callId,\n                lifetime: httpTimeout,\n                version: 0,\n                offer,\n            };\n            return merge(\n            // wait for answer\n            fromEvent(matrix, 'event').pipe(filter(filterMatrixVoipEvents('m.call.answer', peerId, callId, httpTimeout))), \n            // send invite with offer\n            waitMemberAndSend$(peerAddress, matrix, 'm.call.invite', content, {\n                log,\n                latest$,\n                config$,\n            }).pipe(tap((e) => log.debug('RTC: sent invite', callId, e)), ignoreElements()));\n        }), take(1), tap(() => log.info('RTC: got answer', callId)), map((event) => {\n            connection.setRemoteDescription(new RTCSessionDescription(event.getContent().answer));\n            start$.next(null);\n            start$.complete();\n        }), ignoreElements()), of(dataChannel));\n    }));\n}\n// setup RTC data channel for callee\nfunction setupCalleeDataChannel$(matrix, start$, info, { httpTimeout }, deps) {\n    const { callId, peerId, peerAddress } = info;\n    const { log, latest$, config$ } = deps;\n    return fromEvent(matrix, 'event').pipe(filter(filterMatrixVoipEvents('m.call.invite', peerId, callId, httpTimeout)), tap(() => log.info('RTC: got invite', callId)), mergeMap((event) => from(getMatrixIceServers(matrix)).pipe(map((serv) => [event, serv]))), withLatestFrom(config$), mergeMap(([[event, matrixTurnServers], { fallbackIceServers }]) => {\n        // create connection only upon invite/offer\n        const connection = new RTCPeerConnection({\n            iceServers: [...matrixTurnServers, ...fallbackIceServers],\n        });\n        connection.setRemoteDescription(new RTCSessionDescription(event.getContent().offer));\n        return merge(\n        // despite 'never' emitting, candidates$ have side-effects while/when subscribed\n        handleCandidates$(connection, matrix, start$, info, deps), defer(() => connection.createAnswer()).pipe(mergeMap((answer) => {\n            connection.setLocalDescription(answer);\n            const content = {\n                call_id: callId,\n                lifetime: httpTimeout,\n                version: 0,\n                answer,\n            };\n            // send answer\n            return waitMemberAndSend$(peerAddress, matrix, 'm.call.answer', content, {\n                log,\n                latest$,\n                config$,\n            });\n        }), tap((e) => {\n            log.debug('RTC: sent answer', callId, e);\n            start$.next(null);\n            start$.complete();\n        }), ignoreElements()), fromEvent(connection, 'datachannel').pipe(pluck('channel')));\n    }), take(1));\n}\n// setup listeners & events for a data channel, when it gets opened, and teardown when closed\nfunction listenDataChannel$(stop$, { callId, peerId, peerAddress }, { httpTimeout }, { log }) {\n    return (dataChannel$) => dataChannel$.pipe(mergeMap((dataChannel) => merge(fromEvent(dataChannel, 'close').pipe(tap(() => {\n        log.info('RTC: dataChannel close', callId);\n        stop$.next(null);\n        stop$.complete();\n    }), ignoreElements()), fromEvent(dataChannel, 'error').pipe(mergeMap((ev) => throwError(ev.error))), fromEvent(dataChannel, 'open').pipe(take(1), \n    // this timeout ensures the whole dataChannel$ observable throws if it can't be set up,\n    // so it can be retried/repeated/restarted.\n    // notice it only starts after dataChannel$ emits, i.e. on subscription for caller (as\n    // it createDataChannel object, then responsible for hanging up call and retrying),\n    // and after 'datachannel' event for callee (passive listener)\n    timeout(httpTimeout / 3), tap(() => log.info('RTC: dataChannel open', callId)), \n    // output rtcChannel action with defined channel instance to have it set in latest$\n    mapTo(rtcChannel(dataChannel, { address: peerAddress }))), fromEvent(dataChannel, 'message').pipe(tap((e) => log.debug('RTC: dataChannel message', callId, e)), pluck('data'), filter((d) => typeof d === 'string'), map((line) => messageReceived({\n        text: line,\n        message: parseMessage(line, peerAddress, { log }),\n        ts: Date.now(),\n        userId: peerId,\n    }, { address: peerAddress })))).pipe(finalize(() => dataChannel.close()))), takeUntil(stop$), catchError((err) => {\n        var _a;\n        stop$.next(null);\n        stop$.complete();\n        log.info(\"Couldn't set up WebRTC dataChannel, retrying\", callId, (_a = err === null || err === void 0 ? void 0 : err.message) !== null && _a !== void 0 ? _a : err);\n        return EMPTY;\n    }), \n    // if it ends by takeUntil or catchError, output rtcChannel to reset latest$ mapping\n    endWith(rtcChannel(undefined, { address: peerAddress })));\n}\n// handles presence changes for a single peer address (grouped)\nfunction handlePresenceChange$(action$, presence$, { log, address, latest$, matrix$, config$ }) {\n    return presence$.pipe(distinctUntilChanged((a, b) => a.payload.userId === b.payload.userId && a.payload.available === b.payload.available), withLatestFrom(matrix$, config$), filter(([action, , { caps }]) => { var _a; return !!((_a = action.payload.caps) === null || _a === void 0 ? void 0 : _a[Capabilities.WEBRTC]) && !!(caps === null || caps === void 0 ? void 0 : caps[Capabilities.WEBRTC]); }), switchMap(([action, matrix, config]) => {\n        // if peer goes offline in Matrix, reset dataChannel & unsubscribe defer to close dataChannel\n        if (!action.payload.available)\n            return of(rtcChannel(undefined, action.meta));\n        const deps = { log, latest$, config$ };\n        const callId = [address, action.meta.address]\n            .map((a) => a.toLowerCase())\n            .sort((a, b) => a.localeCompare(b))\n            .join('|');\n        const isCaller = callId.startsWith(address.toLowerCase());\n        return defer(() => {\n            const info = {\n                callId,\n                peerId: action.payload.userId,\n                peerAddress: action.meta.address,\n            };\n            // start$ indicates invite/offer/answer cycle completed, and candidates can be exchanged\n            const start$ = new AsyncSubject();\n            // stop$ indicates dataChannel closed (maybe by peer), and teardown should take place\n            const stop$ = new AsyncSubject();\n            let dataChannel$;\n            if (isCaller) {\n                // caller\n                dataChannel$ = setupCallerDataChannel$(matrix, start$, info, config, deps);\n            }\n            else {\n                // callee\n                dataChannel$ = setupCalleeDataChannel$(matrix, start$, info, config, deps);\n            }\n            stop$\n                .pipe(mergeMap(() => waitMemberAndSend$(action.meta.address, matrix, 'm.call.hangup', { call_id: callId, version: 0 }, { log, latest$, config$ }).pipe(takeUntil(timer(config.httpTimeout / 10)))), takeUntil(action$.pipe(filter(raidenShutdown.is))))\n                .subscribe(); // when stopping, if not shutting down, send hangup\n            // listenDataChannel$ needs channel$:Observable<RTCDataChannel>, but we must include/merge\n            // setup and monitoring Observable<never>'s to get things moving on subscription\n            return merge(dataChannel$, \n            // throws nad restart if peer hangs up\n            fromEvent(matrix, 'event').pipe(filter(filterMatrixVoipEvents('m.call.hangup', info.peerId, callId)), \n            // no need for specific error since this is just logged and ignored in listenDataChannel$\n            mergeMapTo(throwError(new Error('RTC: peer hung up'))))).pipe(listenDataChannel$(stop$, info, config, deps));\n        }).pipe(\n        // if it disconnects for any reason, but partner is still online,\n        // try to reconnect by repeating from 'defer'\n        repeatWhen((completed$) => completed$.pipe(withLatestFrom(latest$, config$), mergeMap(([, { presences }, { httpTimeout }]) => {\n            var _a, _b;\n            return !((_b = (_a = presences[action.meta.address]) === null || _a === void 0 ? void 0 : _a.payload) === null || _b === void 0 ? void 0 : _b.available)\n                ? EMPTY\n                : isCaller\n                    ? timer(httpTimeout / 10) // caller waits some time to retry\n                    : of(null);\n        }))));\n    }));\n}\nexport const rtcConnectEpic = (action$, {}, deps) => action$.pipe(filter(matrixPresence.success.is), groupBy((action) => action.meta.address), mergeMap((grouped$) => handlePresenceChange$(action$, grouped$, deps)));\n//# sourceMappingURL=epics.js.map","import { from } from 'rxjs';\nimport { filter, mergeMap, withLatestFrom, map } from 'rxjs/operators';\nimport { channelClose } from '../../channels/actions';\nimport { getBalanceProofFromEnvelopeMessage } from '../../messages/utils';\nimport { isActionOf } from '../../utils/actions';\nimport { RaidenError, ErrorCodes } from '../../utils/error';\nimport { isntNil } from '../../utils/types';\nimport { transfer } from '../actions';\nimport { Direction } from '../state';\n/**\n * Complete or fail any pending transfer for any closing or closed channels\n * Transfer is considered successful if secret was revealed (as it could be claimed on-chain),\n * else it's considered as failed as couldn't succeed inside expiration timeout\n *\n * @param action$ - Observable of channelClose.{requet,success} actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transfer.{success|failure} actions\n */\nexport const transferChannelClosedEpic = (action$, state$, { address }) => action$.pipe(filter(isActionOf([channelClose.request, channelClose.success])), withLatestFrom(state$), mergeMap(([action, state]) => from(Object.entries(state.sent)).pipe(filter(([, { transfer: [, transf], },]) => transf.token_network_address === action.meta.tokenNetwork &&\n    transf.recipient === action.meta.partner &&\n    transf.initiator === address), map(([secrethash, sent]) => {\n    var _a, _b, _c, _d;\n    // as we can't know for sure if recipient/partner received the secret or unlock,\n    //consider transfer failed iff neither the secret was revealed nor the unlock happened\n    const meta = { secrethash, direction: Direction.SENT };\n    if (sent.lockExpired ||\n        sent.unlockProcessed || ((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) ||\n        (sent.secretRequest && !sent.secretReveal))\n        // success/failure already emitted\n        return;\n    else if (!((_d = (_c = sent.secret) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.registerBlock) && !sent.secretReveal && !sent.unlock)\n        return transfer.failure(new RaidenError(ErrorCodes.XFER_CHANNEL_CLOSED_PREMATURELY), meta);\n    else if (sent.unlock)\n        return transfer.success({ balanceProof: getBalanceProofFromEnvelopeMessage(sent.unlock[1]) }, meta);\n    else\n        return transfer.success({}, meta);\n}), filter(isntNil))));\n//# sourceMappingURL=close.js.map","import { merge, of } from 'rxjs';\nimport { filter, ignoreElements, take } from 'rxjs/operators';\n/**\n * Dispatches an actions and waits until a condition is satisfied.\n *\n * @param action$ - Observable of actions that will be monitored\n * @param request - The request/action that will be dispatched\n * @param predicate - The condition that will that was to be satisfied for the observable to\n * complete\n * @returns Observable of the request type.\n */\nexport function dispatchAndWait$(action$, request, predicate) {\n    return merge(\n    // wait until respective success/failure action is seen before completing\n    action$.pipe(filter(predicate), take(1), \n    // don't output success/failure action, just wait for first match to complete\n    ignoreElements()), \n    // output once\n    of(request));\n}\n//# sourceMappingURL=utils.js.map","import { from, merge, of } from 'rxjs';\nimport { exhaustMap, filter, withLatestFrom, mergeMap } from 'rxjs/operators';\nimport { newBlock } from '../../channels/actions';\nimport { isActionOf, isResponseOf } from '../../utils/actions';\nimport { RaidenError, ErrorCodes } from '../../utils/error';\nimport { transfer, transferExpire } from '../actions';\nimport { Direction } from '../state';\nimport { dispatchAndWait$ } from './utils';\n/**\n * Contains the core logic of {@link transferAutoExpireEpic}.\n *\n * @param action$ - Observable of {@link RaidenAction} actions\n * @param state - Contains The current state of the app\n * @param config - Contains the current app config\n * @param blockNumber - The current block number\n * @returns Observable of {@link transferExpire.request} or {@link transfer.failure} actions\n */\nfunction autoExpire$(action$, state, { confirmationBlocks }, blockNumber) {\n    // we can send LockExpired only for SENT transfers\n    return from(Object.entries(state.sent)).pipe(filter(([, sent]) => {\n        var _a, _b;\n        return !sent.unlock &&\n            !sent.lockExpired &&\n            !sent.channelClosed &&\n            sent.transfer[1].lock.expiration.add(confirmationBlocks).lte(blockNumber) &&\n            // don't expire if secret got registered before lock expired\n            !((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock);\n    }), mergeMap(([secrethash, sent]) => {\n        const meta = { secrethash, direction: Direction.SENT };\n        // this observable acts like a Promise: emits request once, completes on success/failure\n        return merge(dispatchAndWait$(action$, transferExpire.request(undefined, meta), isResponseOf(transferExpire, meta)), \n        // notify users that this transfer failed definitely\n        of(transfer.failure(new RaidenError(ErrorCodes.XFER_EXPIRED, {\n            block: sent.transfer[1].lock.expiration.toString(),\n        }), meta)));\n    }));\n}\n/**\n * Process newBlocks, emits transferExpire.request (request to compose&sign LockExpired for a transfer)\n * if pending transfer's lock expired and transfer didn't unlock (succeed) in time\n * Also, emits transfer.failure, to notify users that a transfer has failed (although it'll only be\n * considered as completed with fail once the transferExpireProcessed arrives).\n *\n * @param action$ - Observable of newBlock|transferExpire.success|transferExpire.failure actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferExpire.request|transfer.failure actions\n */\nexport const transferAutoExpireEpic = (action$, state$, { config$ }) => action$.pipe(filter(isActionOf(newBlock)), withLatestFrom(state$, config$), \n// exhaustMap ignores new blocks while previous request batch is still pending\nexhaustMap(([{ payload: { blockNumber } }, state, config]) => autoExpire$(action$, state, config, blockNumber)));\n//# sourceMappingURL=expire.js.map","/* eslint-disable @typescript-eslint/camelcase */\nimport { Zero } from 'ethers/constants';\nimport { bigNumberify } from 'ethers/utils';\nimport { combineLatest, EMPTY, from, of, merge, defer } from 'rxjs';\nimport { catchError, concatMap, filter, first, map, mergeMap, tap, withLatestFrom, } from 'rxjs/operators';\nimport findKey from 'lodash/findKey';\nimport get from 'lodash/get';\nimport isMatchWith from 'lodash/isMatchWith';\nimport pick from 'lodash/pick';\nimport { ChannelState } from '../../channels/state';\nimport { channelAmounts } from '../../channels/utils';\nimport { LockedTransfer, LockExpired, MessageType, Unlock, } from '../../messages/types';\nimport { signMessage, isMessageReceivedOfType, getBalanceProofFromEnvelopeMessage, } from '../../messages/utils';\nimport { matrixPresence } from '../../transport/actions';\nimport { isActionOf } from '../../utils/actions';\nimport { LruCache } from '../../utils/lru';\nimport { pluckDistinct } from '../../utils/rx';\nimport { assert, BigNumberC, Signed } from '../../utils/types';\nimport { RaidenError, ErrorCodes } from '../../utils/error';\nimport { Capabilities } from '../../constants';\nimport { transfer, transferExpire, transferSecret, transferSigned, transferUnlock, withdrawReceive, transferProcessed, transferSecretRequest, transferUnlockProcessed, transferExpireProcessed, } from '../actions';\nimport { getLocksroot, makeMessageId, getSecrethash } from '../utils';\nimport { Direction } from '../state';\n/**\n * Return the next nonce for a (possibly missing) balanceProof, or else BigNumber(1)\n *\n * @param balanceProof - Balance proof to increase nonce from\n * @returns Increased nonce, or One if no balance proof provided\n */\nfunction nextNonce(balanceProof) {\n    var _a;\n    return ((_a = balanceProof === null || balanceProof === void 0 ? void 0 : balanceProof.nonce) !== null && _a !== void 0 ? _a : Zero).add(1);\n}\nfunction getChannelLocksroot(channel, secrethash) {\n    var _a;\n    const locks = ((_a = channel.own.locks) !== null && _a !== void 0 ? _a : []).filter((l) => l.secrethash !== secrethash);\n    return getLocksroot(locks);\n}\n/**\n * THe core logic of {@link makeAndSignTransfer}.\n *\n * @param state - Contains The current state of the app\n * @param action - transfer request action to be sent.\n * @param revealTimeout - The reveal timeout for the transfer.\n * @param deps - {@link RaidenEpicDeps}\n * @returns Observable of {@link transferSecret} or {@link transferSigned} actions\n */\nfunction makeAndSignTransfer$(state, action, { revealTimeout }, { log, address, network, signer }) {\n    var _a, _b, _c, _d, _e, _f;\n    if (action.meta.secrethash in state.sent) {\n        // don't throw to avoid emitting transfer.failure, to just wait for already pending transfer\n        log.warn('transfer already present', action.meta);\n        return EMPTY;\n    }\n    // assume paths are valid and recipient is first hop of first route\n    // compose metadata from it, and use first path fee\n    const metadata = {\n        routes: action.payload.paths.map(({ path }) => ({ route: path })),\n    };\n    const fee = action.payload.paths[0].fee;\n    const recipient = action.payload.paths[0].path[0];\n    const channel = state.channels[action.payload.tokenNetwork][recipient];\n    // check below shouldn't fail because of route validation in pathFindServiceEpic\n    // used here mostly for type narrowing on channel union\n    assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open, 'not open');\n    assert(!action.payload.expiration || action.payload.expiration >= state.blockNumber + revealTimeout, 'expiration too soon');\n    const lock = {\n        amount: action.payload.value.add(fee),\n        expiration: bigNumberify(action.payload.expiration || state.blockNumber + revealTimeout * 2),\n        secrethash: action.meta.secrethash,\n    };\n    const locks = [...((_a = channel.own.locks) !== null && _a !== void 0 ? _a : []), lock];\n    const locksroot = getLocksroot(locks);\n    const token = findKey(state.tokens, (tn) => tn === action.payload.tokenNetwork);\n    log.info('Signing transfer of value', action.payload.value.toString(), 'of token', token, ', to', action.payload.target, ', through routes', action.payload.paths, ', paying', fee.toString(), 'in fees.');\n    const message = {\n        type: MessageType.LOCKED_TRANSFER,\n        message_identifier: makeMessageId(),\n        chain_id: bigNumberify(network.chainId),\n        token_network_address: action.payload.tokenNetwork,\n        channel_identifier: bigNumberify(channel.id),\n        nonce: nextNonce(channel.own.balanceProof),\n        transferred_amount: ((_c = (_b = channel.own.balanceProof) === null || _b === void 0 ? void 0 : _b.transferredAmount) !== null && _c !== void 0 ? _c : Zero),\n        locked_amount: ((_e = (_d = channel.own.balanceProof) === null || _d === void 0 ? void 0 : _d.lockedAmount) !== null && _e !== void 0 ? _e : Zero).add(lock.amount),\n        locksroot,\n        payment_identifier: action.payload.paymentId,\n        token,\n        recipient,\n        lock,\n        target: action.payload.target,\n        initiator: (_f = action.payload.initiator) !== null && _f !== void 0 ? _f : address,\n        metadata,\n    };\n    return from(signMessage(signer, message, { log })).pipe(mergeMap(function* (signed) {\n        // messageSend LockedTransfer handled by transferRetryMessageEpic\n        yield transferSigned({ message: signed, fee }, action.meta);\n        // besides transferSigned, also yield transferSecret (for registering) if we know it\n        if (action.payload.secret)\n            yield transferSecret({ secret: action.payload.secret }, action.meta);\n    }));\n}\n/**\n * Create an observable to compose and sign a LockedTransfer message/transferSigned action\n * As it's an async observable which depends on state and may return an action which changes it,\n * the returned observable must be subscribed in a serialized context that ensures non-concurrent\n * write access to the channel's balance proof (e.g. concatMap)\n *\n * @param state$ - Observable of current state\n * @param action - transfer request action to be sent\n * @param deps - RaidenEpicDeps\n * @returns Observable of transferSigned|transferSecret|transfer.failure actions\n */\nfunction makeAndSignTransfer(state$, action, deps) {\n    return combineLatest([state$, deps.config$]).pipe(first(), mergeMap(([state, config]) => makeAndSignTransfer$(state, action, config, deps)), catchError((err) => of(transfer.failure(err, action.meta))));\n}\n/**\n * Contains the core logic of {@link makeAndSignUnlock}.\n *\n * @param state$ - Observable of the latest app state.\n * @param state - Contains The current state of the app\n * @param action - The transfer unlock action that will generate the transferUnlock.success action.\n * @param signer - The signer that will sign the message\n * @returns Observable of {@link transferUnlock.success} action.\n */\nfunction makeAndSignUnlock$(state$, state, action, { log, signer }) {\n    var _a, _b;\n    const secrethash = action.meta.secrethash;\n    assert(secrethash in state.sent, 'unknown transfer');\n    const transfer = state.sent[secrethash].transfer[1];\n    const channel = get(state.channels, [\n        transfer.token_network_address,\n        transfer.recipient,\n    ]);\n    // shouldn't happen, channel close clears transfers, but unlock may already have been queued\n    assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open && channel.own.balanceProof, 'channel gone, not open or no balanceProof');\n    let signed$;\n    if (state.sent[secrethash].unlock) {\n        // unlock already signed, use cached\n        signed$ = of(state.sent[secrethash].unlock[1]);\n    }\n    else {\n        // don't forget to check after signature too, may have expired by then\n        // allow unlocking past expiration if secret registered\n        assert(((_b = (_a = state.sent[secrethash].secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) ||\n            transfer.lock.expiration.gt(state.blockNumber), 'lock expired');\n        const locksroot = getChannelLocksroot(channel, secrethash);\n        const message = {\n            type: MessageType.UNLOCK,\n            message_identifier: makeMessageId(),\n            chain_id: transfer.chain_id,\n            token_network_address: transfer.token_network_address,\n            channel_identifier: transfer.channel_identifier,\n            nonce: nextNonce(channel.own.balanceProof),\n            transferred_amount: channel.own.balanceProof.transferredAmount.add(transfer.lock.amount),\n            locked_amount: channel.own.balanceProof.lockedAmount.sub(transfer.lock.amount),\n            locksroot,\n            payment_identifier: transfer.payment_identifier,\n            secret: state.sent[action.meta.secrethash].secret[1].value,\n        };\n        signed$ = from(signMessage(signer, message, { log }));\n    }\n    return signed$.pipe(withLatestFrom(state$), mergeMap(function* ([signed, state]) {\n        var _a, _b;\n        assert(((_b = (_a = state.sent[secrethash].secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) ||\n            transfer.lock.expiration.gt(state.blockNumber), 'lock expired');\n        assert(!state.sent[secrethash].channelClosed, 'channel closed!');\n        yield transferUnlock.success({ message: signed }, action.meta);\n        // messageSend Unlock handled by transferRetryMessageEpic\n        // we don't check if transfer was refunded. If partner refunded the transfer but still\n        // forwarded the payment, we still act honestly and unlock if they revealed\n    }));\n}\n/**\n * Create an observable to compose and sign a Unlock message/transferUnlock.success action\n * As it's an async observable which depends on state and may return an action which changes it,\n * the returned observable must be subscribed in a serialized context that ensures non-concurrent\n * write access to the channel's balance proof (e.g. concatMap)\n *\n * @param state$ - Observable of current state\n * @param action - transferUnlock.request request action to be sent\n * @param signer - RaidenEpicDeps members\n * @returns Observable of transferUnlock.success actions\n */\nfunction makeAndSignUnlock(state$, action, { signer, log }) {\n    return state$.pipe(first(), mergeMap((state) => makeAndSignUnlock$(state$, state, action, { log, signer })), catchError((err) => {\n        log.warn('Error trying to unlock after SecretReveal', err);\n        return of(transferUnlock.failure(err, action.meta));\n    }));\n}\n/**\n * Contains the core logic of {@link makeAndSignLockExpired}.\n *\n * @param state - Contains The current state of the app\n * @param action - The transfer expire action.\n * @param signer - RaidenEpicDeps members\n * @returns Observable of transferExpire.success actions\n */\nfunction makeAndSignLockExpired$(state, action, { signer, log }) {\n    const secrethash = action.meta.secrethash;\n    assert(secrethash in state.sent, 'unknown transfer');\n    const transfer = state.sent[secrethash].transfer[1];\n    const channel = get(state.channels, [\n        transfer.token_network_address,\n        transfer.recipient,\n    ]);\n    assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open && channel.own.balanceProof, 'channel gone, not open or no balanceProof');\n    let signed$;\n    if (state.sent[secrethash].lockExpired) {\n        // lockExpired already signed, use cached\n        signed$ = of(state.sent[secrethash].lockExpired[1]);\n    }\n    else {\n        assert(transfer.lock.expiration.lt(state.blockNumber), 'lock not yet expired');\n        assert(!state.sent[secrethash].unlock, 'transfer already unlocked');\n        const locksroot = getChannelLocksroot(channel, secrethash);\n        const message = {\n            type: MessageType.LOCK_EXPIRED,\n            message_identifier: makeMessageId(),\n            chain_id: transfer.chain_id,\n            token_network_address: transfer.token_network_address,\n            channel_identifier: transfer.channel_identifier,\n            nonce: nextNonce(channel.own.balanceProof),\n            transferred_amount: channel.own.balanceProof.transferredAmount,\n            locked_amount: channel.own.balanceProof.lockedAmount.sub(transfer.lock.amount),\n            locksroot,\n            recipient: transfer.recipient,\n            secrethash,\n        };\n        signed$ = from(signMessage(signer, message, { log }));\n    }\n    return signed$.pipe(\n    // messageSend LockExpired handled by transferRetryMessageEpic\n    map((signed) => transferExpire.success({ message: signed }, action.meta)));\n}\n/**\n * Create an observable to compose and sign a LockExpired message/transferExpire.success action\n * As it's an async observable which depends on state and may return an action which changes it,\n * the returned observable must be subscribed in a serialized context that ensures non-concurrent\n * write access to the channel's balance proof (e.g. concatMap)\n *\n * @param state$ - Observable of current state\n * @param action - transfer request action to be sent\n * @param signer - RaidenEpicDeps members\n * @returns Observable of transferExpire.success|transferExpire.failure actions\n */\nfunction makeAndSignLockExpired(state$, action, { log, signer }) {\n    return state$.pipe(first(), mergeMap((state) => makeAndSignLockExpired$(state, action, { signer, log })), catchError((err) => of(transferExpire.failure(err, action.meta))));\n}\nfunction makeAndSignWithdrawConfirmation$(state, action, { log, signer }, cache) {\n    var _a, _b;\n    const request = action.payload.message;\n    const channel = get(state.channels, [\n        action.meta.tokenNetwork,\n        action.meta.partner,\n    ]);\n    // check channel is in valid state and requested total_withdraw is valid\n    // withdrawable amount is: total_withdraw <= partner.deposit + own.transferredAmount\n    assert(channel && channel.state === ChannelState.open && request.channel_identifier.eq(channel.id), 'channel gone or not open');\n    assert(request.expiration.gt(state.blockNumber), 'WithdrawRequest expired');\n    assert(request.total_withdraw.lte(channel.partner.deposit.add((_b = (_a = channel.own.balanceProof) === null || _a === void 0 ? void 0 : _a.transferredAmount) !== null && _b !== void 0 ? _b : Zero)), 'invalid total_withdraw, greater than partner.deposit + own.transferredAmount');\n    let signed$;\n    const key = request.message_identifier.toString();\n    // compare WithdrawRequest and a possible signed WithdrawConfirmation\n    function compareReqConf(req, conf) {\n        if (!conf)\n            return false;\n        const matchSet = pick(conf, [\n            'token_network_address',\n            'participant',\n            'chain_id',\n            'channel_identifier',\n            'total_withdraw',\n            'expiration',\n        ]);\n        return isMatchWith(req, matchSet, (objVal, othVal) => BigNumberC.is(objVal)\n            ? objVal.eq(othVal)\n            : BigNumberC.is(othVal)\n                ? othVal.eq(objVal)\n                : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    undefined);\n    }\n    const cached = cache.get(key);\n    // ensure all parameters are equal the cached one before returning it, or else sign again\n    if (compareReqConf(request, cached)) {\n        signed$ = of(cached);\n    }\n    else {\n        const confirmation = {\n            type: MessageType.WITHDRAW_CONFIRMATION,\n            message_identifier: request.message_identifier,\n            chain_id: request.chain_id,\n            token_network_address: request.token_network_address,\n            channel_identifier: request.channel_identifier,\n            participant: request.participant,\n            total_withdraw: request.total_withdraw,\n            nonce: nextNonce(channel.own.balanceProof),\n            expiration: request.expiration,\n        };\n        signed$ = from(signMessage(signer, confirmation, { log })).pipe(tap((signed) => cache.put(key, signed)));\n    }\n    return signed$.pipe(map((signed) => withdrawReceive.success({ message: signed }, action.meta)));\n}\n/**\n * Create an observable to compose and sign a [[WithdrawConfirmation]] message\n *\n * Validate we're inside expiration timeout, channel exists and is open, and that total_withdraw is\n * less than or equal withdrawable amount (while we don't receive, partner.deposit +\n * own.transferredAmount).\n * We need it inside [[transferGenerateAndSignEnvelopeMessageEpic]] concatMap/lock because we read\n * and change the 'nonce', even though WithdrawConfirmation doesn't carry a full balanceProof.\n * Also, instead of storing the messages in state and retrying, we just cache it and send cached\n * signed message on each received request.\n *\n * TODO: once we're able to receive transfers, instead of considering only own.transferredAmount,\n * we must also listen to ChannelWithdraw events, store it alongside pending withdraw requests and\n * take that into account before accepting a transfer and also total balance/capacity for accepting\n * a total_withdraw from a WithdrawRequest.\n *\n * @param state$ - Observable of current state\n * @param action - Withdraw request which caused this handling\n * @param signer - RaidenEpicDeps members\n * @param cache - A Map to store and reuse previously Signed<WithdrawConfirmation>\n * @returns Observable of transferExpire.success|transferExpire.failure actions\n */\nfunction makeAndSignWithdrawConfirmation(state$, action, { signer, log }, cache) {\n    return state$.pipe(first(), mergeMap((state) => makeAndSignWithdrawConfirmation$(state, action, { log, signer }, cache)), catchError((err) => {\n        log.warn('Error trying to handle WithdrawRequest, ignoring:', err);\n        return EMPTY;\n    }));\n}\nfunction receiveTransferSigned(state$, action, { address, log, network, signer, config$ }) {\n    const secrethash = action.payload.message.lock.secrethash;\n    const meta = { secrethash, direction: Direction.RECEIVED };\n    return combineLatest([state$, config$]).pipe(first(), mergeMap(([state, { revealTimeout, caps }]) => {\n        var _a, _b, _c, _d, _e, _f;\n        const transfer = action.payload.message;\n        if (secrethash in state.received) {\n            log.warn('transfer already present', action.meta);\n            const msgId = transfer.message_identifier;\n            // if transfer matches the stored one, re-send Processed once\n            if (state.received[secrethash].partner === action.meta.address &&\n                state.received[secrethash].transfer[1].message_identifier.eq(msgId)) {\n                // transferProcessed again will trigger messageSend.request\n                return of(transferProcessed({ message: state.received[secrethash].transferProcessed[1] }, meta));\n            }\n            else\n                return EMPTY;\n        }\n        // full balance proof validation\n        const tokenNetwork = transfer.token_network_address;\n        const partner = action.meta.address;\n        const channel = (_a = state.channels[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[partner];\n        assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open, 'channel not found or not open');\n        assert(transfer.chain_id.eq(network.chainId), 'chainId mismatch');\n        assert(transfer.channel_identifier.eq(channel.id), 'channelId mismatch');\n        assert(transfer.nonce.eq(nextNonce(channel.partner.balanceProof)), 'nonce mismatch');\n        assert(transfer.transferred_amount.eq((_c = (_b = channel.partner.balanceProof) === null || _b === void 0 ? void 0 : _b.transferredAmount) !== null && _c !== void 0 ? _c : Zero), 'transferredAmount mismatch');\n        assert(transfer.locked_amount.eq(((_e = (_d = channel.partner.balanceProof) === null || _d === void 0 ? void 0 : _d.lockedAmount) !== null && _e !== void 0 ? _e : Zero).add(transfer.lock.amount)), 'lockedAmount mismatch');\n        const partnerCapacity = channelAmounts(channel).partnerCapacity;\n        assert(transfer.lock.amount.lte(partnerCapacity), 'balanceProof total amount bigger than capacity');\n        assert(transfer.recipient === address, \"Received transfer isn't for us\");\n        assert(transfer.lock.expiration.sub(state.blockNumber).gt(revealTimeout), 'lock expires too soon');\n        const locks = [...((_f = channel.partner.locks) !== null && _f !== void 0 ? _f : []), transfer.lock];\n        const locksroot = getLocksroot(locks);\n        assert(transfer.locksroot === locksroot, 'locksroot mismatch');\n        const token = findKey(state.tokens, (tn) => tn === tokenNetwork);\n        log.info('Receiving transfer of value', transfer.lock.amount.toString(), 'of token', token, ', from', transfer.initiator, ', through partner', partner);\n        let request$ = of(undefined);\n        if (!(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_RECEIVE]) && transfer.target === address)\n            request$ = defer(() => {\n                const request = {\n                    type: MessageType.SECRET_REQUEST,\n                    payment_identifier: transfer.payment_identifier,\n                    secrethash,\n                    amount: transfer.lock.amount,\n                    expiration: transfer.lock.expiration,\n                    message_identifier: makeMessageId(),\n                };\n                return signMessage(signer, request, { log });\n            });\n        const processed$ = defer(() => {\n            const processed = {\n                type: MessageType.PROCESSED,\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                message_identifier: transfer.message_identifier,\n            };\n            return signMessage(signer, processed, { log });\n        });\n        // if any of these signature prompts fail, none of these actions will be emitted\n        return combineLatest([processed$, request$]).pipe(mergeMap(function* ([processed, request]) {\n            yield transferSigned({ message: transfer, fee: Zero }, meta);\n            // sets TransferState.transferProcessed\n            yield transferProcessed({ message: processed }, meta);\n            if (request) {\n                // request initiator's presence, to be able to request secret\n                yield matrixPresence.request(undefined, { address: transfer.initiator });\n                // request secret iff we're the target and receiving is enabled\n                yield transferSecretRequest({ message: request }, meta);\n            }\n        }));\n    }), catchError((err) => of(transfer.failure(err, meta))));\n}\nfunction receiveTransferUnlocked(state$, action, { log, network, signer }) {\n    const secrethash = getSecrethash(action.payload.message.secret);\n    const meta = { secrethash, direction: Direction.RECEIVED };\n    return state$.pipe(first(), mergeMap((state) => {\n        var _a;\n        if (!(secrethash in state.received))\n            return EMPTY;\n        const received = state.received[secrethash];\n        const unlock = action.payload.message;\n        const partner = action.meta.address;\n        assert(partner === received.partner, 'wrong partner');\n        if (received.unlock) {\n            log.warn('transfer already unlocked', action.meta);\n            // if message matches the stored one, re-send Processed once\n            if (received.unlockProcessed &&\n                received.unlockProcessed[1].message_identifier.eq(unlock.message_identifier)) {\n                // transferProcessed again will trigger messageSend.request\n                return of(transferUnlockProcessed({ message: received.unlockProcessed[1] }, meta));\n            }\n            else\n                return EMPTY;\n        }\n        const transf = received.transfer[1];\n        // unlock validation\n        const tokenNetwork = unlock.token_network_address;\n        assert(tokenNetwork === transf.token_network_address, 'wrong tokenNetwork');\n        const channel = (_a = state.channels[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[partner];\n        assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open &&\n            channel.partner.balanceProof &&\n            channel.partner.locks, 'channel not found or not open');\n        assert(unlock.chain_id.eq(network.chainId), 'chainId mismatch');\n        assert(unlock.channel_identifier.eq(channel.id), 'channelId mismatch');\n        assert(unlock.nonce.eq(nextNonce(channel.partner.balanceProof)), 'nonce mismatch');\n        const lock = transf.lock;\n        const amount = lock.amount;\n        assert(unlock.transferred_amount.eq(channel.partner.balanceProof.transferredAmount.add(amount)), 'transferredAmount mismatch');\n        assert(unlock.locked_amount.eq(channel.partner.balanceProof.lockedAmount.sub(amount)), 'lockedAmount mismatch');\n        const locks = channel.partner.locks.filter((lock) => lock.secrethash !== secrethash);\n        const locksroot = getLocksroot(locks);\n        assert(unlock.locksroot === locksroot, 'locksroot mismatch');\n        const processed = {\n            type: MessageType.PROCESSED,\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            message_identifier: unlock.message_identifier,\n        };\n        // if any of these signature prompts fail, none of these actions will be emitted\n        return from(signMessage(signer, processed, { log })).pipe(mergeMap(function* (processed) {\n            yield transferUnlock.success({ message: unlock }, meta);\n            // sets TransferState.transferProcessed\n            yield transferUnlockProcessed({ message: processed }, meta);\n            yield transfer.success({ balanceProof: getBalanceProofFromEnvelopeMessage(unlock) }, meta);\n        }));\n    }), catchError((err) => {\n        log.warn('Error trying to process received Unlock', err);\n        return of(transferUnlock.failure(err, meta));\n    }));\n}\nfunction receiveTransferExpired(state$, action, { log, network, signer, config$ }) {\n    const secrethash = action.payload.message.secrethash;\n    const meta = { secrethash, direction: Direction.RECEIVED };\n    return combineLatest([state$, config$]).pipe(first(), mergeMap(([state, { confirmationBlocks }]) => {\n        var _a, _b, _c;\n        if (!(secrethash in state.received))\n            return EMPTY;\n        const received = state.received[secrethash];\n        const expired = action.payload.message;\n        const partner = action.meta.address;\n        assert(partner === received.partner, 'wrong partner');\n        if (received.lockExpired) {\n            log.warn('transfer already expired', action.meta);\n            // if message matches the stored one, re-send Processed once\n            if (received.lockExpiredProcessed &&\n                received.lockExpiredProcessed[1].message_identifier.eq(expired.message_identifier)) {\n                // transferProcessed again will trigger messageSend.request\n                return of(transferExpireProcessed({ message: received.lockExpiredProcessed[1] }, meta));\n            }\n            else\n                return EMPTY;\n        }\n        const transf = received.transfer[1];\n        // lockExpired validation\n        assert(transf.lock.expiration.add(confirmationBlocks).lte(state.blockNumber), 'expiration block not confirmed yet');\n        assert(!received.unlock, 'transfer unlocked');\n        assert(!((_b = (_a = received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock), 'secret registered');\n        const tokenNetwork = expired.token_network_address;\n        assert(tokenNetwork === transf.token_network_address, 'wrong tokenNetwork');\n        const channel = (_c = state.channels[tokenNetwork]) === null || _c === void 0 ? void 0 : _c[partner];\n        assert((channel === null || channel === void 0 ? void 0 : channel.state) === ChannelState.open &&\n            channel.partner.balanceProof &&\n            channel.partner.locks, 'channel not found or not open');\n        assert(expired.chain_id.eq(network.chainId), 'chainId mismatch');\n        assert(expired.channel_identifier.eq(channel.id), 'channelId mismatch');\n        assert(expired.nonce.eq(nextNonce(channel.partner.balanceProof)), 'nonce mismatch');\n        const lock = transf.lock;\n        const amount = lock.amount;\n        assert(expired.transferred_amount.eq(channel.partner.balanceProof.transferredAmount), 'transferredAmount mismatch');\n        assert(expired.locked_amount.eq(channel.partner.balanceProof.lockedAmount.sub(amount)), 'lockedAmount mismatch');\n        const locks = channel.partner.locks.filter((lock) => lock.secrethash !== secrethash);\n        const locksroot = getLocksroot(locks);\n        assert(expired.locksroot === locksroot, 'locksroot mismatch');\n        const processed = {\n            type: MessageType.PROCESSED,\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            message_identifier: expired.message_identifier,\n        };\n        // if any of these signature prompts fail, none of these actions will be emitted\n        return from(signMessage(signer, processed, { log })).pipe(mergeMap(function* (processed) {\n            yield transferExpire.success({ message: expired }, meta);\n            // sets TransferState.transferProcessed\n            yield transferExpireProcessed({ message: processed }, meta);\n            yield transfer.failure(new RaidenError(ErrorCodes.XFER_EXPIRED, {\n                block: transf.lock.expiration.toString(),\n            }), meta);\n        }));\n    }), catchError((err) => {\n        log.warn('Error trying to process received LockExpired', err);\n        return of(transferExpire.failure(err, meta));\n    }));\n}\n/**\n * Serialize creation and signing of BalanceProof-changing messages or actions\n * Actions which change any data in any channel balance proof must only ever be created reading\n * state inside the serialization flow provided by the concatMap, and also be composed and produced\n * inside it (inner, subscribed observable)\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @returns Observable of output actions for this epic\n */\nexport const transferGenerateAndSignEnvelopeMessageEpic = (action$, {}, deps) => {\n    const withdrawCache = new LruCache(32);\n    const state$ = deps.latest$.pipe(pluckDistinct('state')); // replayed(1)' state$\n    return merge(action$.pipe(filter(isActionOf([\n        transfer.request,\n        transferUnlock.request,\n        transferExpire.request,\n        withdrawReceive.request,\n    ]))), \n    // merge separatedly, to filter per message type before concat\n    action$.pipe(filter(isMessageReceivedOfType([Signed(LockedTransfer), Signed(Unlock), Signed(LockExpired)])))).pipe(concatMap((action) => transfer.request.is(action)\n        ? makeAndSignTransfer(state$, action, deps)\n        : transferUnlock.request.is(action)\n            ? makeAndSignUnlock(state$, action, deps)\n            : transferExpire.request.is(action)\n                ? makeAndSignLockExpired(state$, action, deps)\n                : withdrawReceive.request.is(action)\n                    ? makeAndSignWithdrawConfirmation(state$, action, deps, withdrawCache)\n                    : action.payload.message.type === MessageType.LOCKED_TRANSFER\n                        ? receiveTransferSigned(state$, action, deps)\n                        : action.payload.message.type === MessageType.UNLOCK\n                            ? receiveTransferUnlocked(state$, action, deps)\n                            : receiveTransferExpired(state$, action, deps)));\n};\n//# sourceMappingURL=locked.js.map","import { from } from 'rxjs';\nimport { filter, first, mergeMap, withLatestFrom } from 'rxjs/operators';\nimport { Capabilities } from '../../constants';\nimport { matrixPresence } from '../../transport/actions';\nimport { transferExpire, transferSigned, transferUnlock, transferSecretRequest, transferSecretReveal, transferSecret, } from '../actions';\nimport { Direction } from '../state';\n/**\n * Re-queue pending transfer's BalanceProof/Envelope messages for retry on init\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSigned|transferUnlock.success actions\n */\nexport const initQueuePendingEnvelopeMessagesEpic = ({}, state$) => state$.pipe(first(), mergeMap(function* (state) {\n    var _a, _b;\n    // loop over all pending transfers\n    for (const [key, sent] of Object.entries(state.sent)) {\n        const secrethash = key;\n        // transfer already completed or channelClosed\n        if (sent.unlockProcessed ||\n            sent.lockExpiredProcessed || ((_b = (_a = sent.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) ||\n            sent.channelClosed)\n            continue;\n        const meta = { secrethash, direction: Direction.SENT };\n        // on init, request monitor presence of any pending transfer target\n        yield matrixPresence.request(undefined, { address: sent.transfer[1].target });\n        // Processed not received yet for LockedTransfer\n        if (!sent.transferProcessed)\n            yield transferSigned({ message: sent.transfer[1], fee: sent.fee }, meta);\n        // already unlocked, but Processed not received yet for Unlock\n        if (sent.unlock)\n            yield transferUnlock.success({ message: sent.unlock[1] }, meta);\n        // lock expired, but Processed not received yet for LockExpired\n        if (sent.lockExpired)\n            yield transferExpire.success({ message: sent.lockExpired[1] }, meta);\n    }\n}));\n/**\n * Re-queue pending Received transfer's\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSigned|transferUnlock.success actions\n */\nexport const initQueuePendingReceivedEpic = ({}, state$, { config$ }) => state$.pipe(first(), mergeMap((state) => from(Object.entries(state.received))), filter(([, received]) => {\n    var _a, _b;\n    return !received.unlock &&\n        !received.lockExpired &&\n        !((_b = (_a = received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) &&\n        !received.channelClosed;\n}), withLatestFrom(config$), mergeMap(function* ([[secrethash, received], { caps }]) {\n    // loop over all pending transfers\n    const meta = { secrethash, direction: Direction.RECEIVED };\n    // on init, request monitor presence of any pending transfer initiator\n    yield transferSigned({ message: received.transfer[1], fee: received.fee }, meta);\n    // already revealed to us, but user didn't sign SecretReveal yet\n    if (received.secret && !received.secretReveal)\n        yield transferSecret({ secret: received.secret[1].value }, meta);\n    // already revealed to sender, but they didn't Unlock yet\n    if (received.secretReveal)\n        yield transferSecretReveal({ message: received.secretReveal[1] }, meta);\n    // secret not yet known; request iff receiving is enabled\n    // secretRequest should always be defined as we sign it when receiving transfer\n    if (!(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_RECEIVE]) && !received.secret && received.secretRequest) {\n        yield matrixPresence.request(undefined, { address: received.transfer[1].initiator });\n        yield transferSecretRequest({ message: received.secretRequest[1] }, meta);\n    }\n}));\n//# sourceMappingURL=init.js.map","import { Zero } from 'ethers/constants';\nimport { filter, map, withLatestFrom } from 'rxjs/operators';\nimport { Capabilities } from '../../constants';\nimport { transfer, transferSigned } from '../actions';\nimport { Direction } from '../state';\n/**\n * When receiving a transfer not targeting us, create an outgoing transfer to target\n * Mediated transfers are handled the same way as unrelated received & sent pairs. The difference\n * is that we don't request the secret (as initiator would only reveal to target), and instead,\n * wait for SecretReveal to cascade back from outbound partner, then we unlock it and reveal back\n * to inbound partner, to get its Unlock.\n * If it doesn't succeed, if we didn't get reveal, we'll accept LockExpired, if we did and know\n * the secret but partner didn't unlock, we register on-chain as usual.\n *\n * @param action$ - Observable of incoming transferSigned transfers\n * @param state$ - Observable of RaidenStates\n * @param deps - Raiden epic deps\n * @returns Observable of outbound transfer.request actions\n */\nexport const transferMediateEpic = (action$, state$, { address, config$ }) => action$.pipe(filter(transferSigned.is), \n// filter for received transfers not to us\nfilter((action) => action.meta.direction === Direction.RECEIVED && action.payload.message.target !== address), withLatestFrom(state$, config$), \n// filter when mediating is enabled and outgoing transfer isn't set\nfilter(([action, { sent }, { caps }]) => !(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_MEDIATE]) && !(action.meta.secrethash in sent)), map(([{ payload: { message: transf }, meta: { secrethash } }]) => \n// request an outbound transfer to target\ntransfer.request({\n    tokenNetwork: transf.token_network_address,\n    target: transf.target,\n    value: transf.lock.amount,\n    paymentId: transf.payment_identifier,\n    paths: transf.metadata.routes.map(({ route }) => ({\n        path: route.slice(1),\n        fee: Zero,\n    })),\n    expiration: transf.lock.expiration.toNumber(),\n    initiator: transf.initiator,\n}, { secrethash, direction: Direction.SENT })));\n//# sourceMappingURL=mediate.js.map","import { defer, from, of } from 'rxjs';\nimport { concatMap, filter, map, mergeMap, tap, withLatestFrom } from 'rxjs/operators';\nimport findKey from 'lodash/findKey';\nimport { messageSend } from '../../messages/actions';\nimport { MessageType, Processed, RefundTransfer, WithdrawExpired } from '../../messages/types';\nimport { getBalanceProofFromEnvelopeMessage, signMessage, isMessageReceivedOfType, } from '../../messages/utils';\nimport { LruCache } from '../../utils/lru';\nimport { Signed } from '../../utils/types';\nimport { isActionOf } from '../../utils/actions';\nimport { transfer, transferExpireProcessed, transferProcessed, transferUnlockProcessed, } from '../actions';\nimport { Direction } from '../state';\n/**\n * Handles receiving a signed Processed for some sent LockedTransfer\n * This will persist the Processed reply in transfer state and stop message retry\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferProcessed actions\n */\nexport const transferProcessedReceivedEpic = (action$, state$) => action$.pipe(filter(isMessageReceivedOfType(Signed(Processed))), withLatestFrom(state$), mergeMap(function* ([action, state]) {\n    const message = action.payload.message;\n    let secrethash = undefined;\n    for (const [key, sent] of Object.entries(state.sent)) {\n        if (sent.transfer[1].message_identifier.eq(message.message_identifier) &&\n            sent.transfer[1].recipient === action.meta.address) {\n            secrethash = key;\n            break;\n        }\n    }\n    if (!secrethash)\n        return;\n    yield transferProcessed({ message }, { secrethash, direction: Direction.SENT });\n}));\n/**\n * Handles sending Processed for a received EnvelopeMessages\n *\n * @param action$ - Observable of transferProcessed actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of messageSend.request actions\n */\nexport const transferProcessedSendEpic = (action$, state$) => action$.pipe(filter(isActionOf([transferProcessed, transferUnlockProcessed, transferExpireProcessed])), \n// transfer direction is RECEIVED, not message direction (which is outbound)\nfilter((action) => action.meta.direction === Direction.RECEIVED), withLatestFrom(state$), map(([action, { received }]) => messageSend.request({ message: action.payload.message }, {\n    address: received[action.meta.secrethash].partner,\n    msgId: action.payload.message.message_identifier.toString(),\n})));\n/**\n * Handles receiving a signed Processed for some sent Unlock\n * It sends the success action for transfer (which resolves any pending Promise), marking it as\n * completed successfuly by setting sent.unlockProcessed\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transfer.success|transferUnlockProcessed actions\n */\nexport const transferUnlockProcessedReceivedEpic = (action$, state$) => action$.pipe(filter(isMessageReceivedOfType(Signed(Processed))), withLatestFrom(state$), mergeMap(function* ([action, state]) {\n    const message = action.payload.message;\n    const secrethash = findKey(state.sent, (sent) => sent.unlock &&\n        sent.unlock[1].message_identifier.eq(message.message_identifier) &&\n        sent.partner === action.meta.address);\n    if (!secrethash)\n        return;\n    const meta = { secrethash, direction: Direction.SENT };\n    yield transfer.success({\n        balanceProof: getBalanceProofFromEnvelopeMessage(state.sent[secrethash].unlock[1]),\n    }, meta);\n    yield transferUnlockProcessed({ message }, meta);\n}));\n/**\n * Handles receiving a signed Processed for some sent LockExpired\n * It marks the end of the unhappy case, by setting sent.lockExpiredProcessed\n * transfer.failure was already sent at newBlock handling/transferExpire.request time\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of output actions for this epic\n */\nexport const transferExpireProcessedEpic = (action$, state$) => action$.pipe(filter(isMessageReceivedOfType(Signed(Processed))), withLatestFrom(state$), mergeMap(function* ([action, state]) {\n    const message = action.payload.message;\n    const secrethash = findKey(state.sent, (sent) => sent.lockExpired &&\n        sent.lockExpired[1].message_identifier.eq(message.message_identifier) &&\n        sent.partner === action.meta.address);\n    if (!secrethash)\n        return;\n    yield transferExpireProcessed({ message }, { secrethash, direction: Direction.SENT });\n}));\n/**\n * Sends Processed for unhandled nonce'd messages\n *\n * We don't yet support receiving nor mediating transfers (LockedTransfer, RefundTransfer), but\n * also don't want the partner to keep retrying any messages intended for us indefinitely.\n * That's why we decided to just answer them with Processed, to clear their queue. Of course, we\n * still don't validate, store state for these messages nor handle them in any way (e.g. requesting\n * secret from initiator), so any transfer is going to expire, and then we also reply Processed for\n * the respective LockExpired.\n * Additionally, we hook in sending Processed for other messages which contain nonces (and require\n * Processed reply to stop being retried) but are safe to be ignored, like WithdrawExpired.\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @param signer - RaidenEpicDeps members\n * @returns Observable of messageSend.request actions\n */\nexport const transferReceivedReplyProcessedEpic = (action$, {}, { log, signer }) => {\n    const cache = new LruCache(32);\n    return action$.pipe(filter(isMessageReceivedOfType([Signed(RefundTransfer), Signed(WithdrawExpired)])), concatMap((action) => {\n        const message = action.payload.message;\n        // defer causes the cache check to be performed at subscription time\n        return defer(() => {\n            const msgId = message.message_identifier;\n            const key = msgId.toString();\n            const cached = cache.get(key);\n            if (cached)\n                return of(messageSend.request({ message: cached }, { address: action.meta.address, msgId: key }));\n            const processed = {\n                type: MessageType.PROCESSED,\n                // eslint-disable-next-line @typescript-eslint/camelcase\n                message_identifier: msgId,\n            };\n            return from(signMessage(signer, processed, { log })).pipe(tap((signed) => cache.put(key, signed)), map((signed) => messageSend.request({ message: signed }, { address: action.meta.address, msgId: key })));\n        });\n    }));\n};\n//# sourceMappingURL=processed.js.map","import { filter, mergeMap, withLatestFrom } from 'rxjs/operators';\nimport isEqualWith from 'lodash/isEqualWith';\nimport { RefundTransfer } from '../../messages/types';\nimport { isMessageReceivedOfType } from '../../messages/utils';\nimport { RaidenError, ErrorCodes } from '../../utils/error';\nimport { Signed, BigNumberC } from '../../utils/types';\nimport { transfer, transferRefunded } from '../actions';\nimport { Direction } from '../state';\n// Compare two objects, using .eq for BigNumber properties\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction bnIsEqual(obj, other) {\n    return isEqualWith(obj, other, (objVal, othVal) => BigNumberC.is(objVal)\n        ? objVal.eq(othVal)\n        : BigNumberC.is(othVal)\n            ? othVal.eq(objVal)\n            : undefined);\n}\n/**\n * Receiving RefundTransfer for pending transfer fails it\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transfer.failure|transferRefunded actions\n */\nexport const transferRefundedEpic = (action$, state$) => action$.pipe(filter(isMessageReceivedOfType(Signed(RefundTransfer))), withLatestFrom(state$), mergeMap(function* ([action, state]) {\n    const message = action.payload.message;\n    const secrethash = message.lock.secrethash;\n    if (!(secrethash in state.sent))\n        return;\n    const sent = state.sent[secrethash], transf = sent.transfer[1];\n    if (message.initiator !== transf.recipient ||\n        !message.payment_identifier.eq(transf.payment_identifier) ||\n        !bnIsEqual(message.lock, transf.lock))\n        return;\n    if (sent.unlock || // already unlocked\n        sent.lockExpired || // already expired\n        sent.channelClosed || // channel closed\n        transf.lock.expiration.lte(state.blockNumber) // lock expired but transfer didn't yet\n    )\n        return;\n    const meta = { secrethash, direction: Direction.SENT };\n    yield transferRefunded({ message }, meta);\n    yield transfer.failure(new RaidenError(ErrorCodes.XFER_REFUNDED), meta);\n}));\n//# sourceMappingURL=refund.js.map","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { EMPTY } from 'rxjs';\nimport { delay, filter, mergeMap, repeatWhen, takeUntil, withLatestFrom, switchMap, first, } from 'rxjs/operators';\nimport { messageSend } from '../../messages/actions';\nimport { isActionOf, isResponseOf } from '../../utils/actions';\nimport { pluckDistinct } from '../../utils/rx';\nimport { transferExpire, transferSigned, transferUnlock, transferSecretRequest, transferSecretReveal, } from '../actions';\nimport { Direction } from '../state';\nimport { dispatchAndWait$ } from './utils';\nfunction repeatUntil(notifier, delayMs = 30e3) {\n    // Resubscribe/retry every 30s after messageSend succeeds\n    // Notice first (or any) messageSend.request can wait for a long time before succeeding, as it\n    // waits for address's user in transport to be online and joined room before actually\n    // sending the message. That's why repeatWhen emits/resubscribe only some time after\n    // sendOnceAndWaitSent$ completes, instead of a plain 'interval'\n    return (input$) => input$.pipe(repeatWhen((completed$) => completed$.pipe(delay(delayMs))), takeUntil(notifier));\n}\nfunction retrySendUntil$(send, action$, notifier, delayMs = 30e3) {\n    return dispatchAndWait$(action$, send, isResponseOf(messageSend, send.meta)).pipe(repeatUntil(notifier, delayMs));\n}\n/**\n * Handles a transferSigned action and retry messageSend.request until transfer is gone (completed\n * with success or error) OR Processed message for LockedTransfer received.\n * transferSigned for pending LockedTransfer's may be re-emitted on startup for pending transfer,\n * to start retrying sending the message again until stop condition is met.\n *\n * @param action$ - Observable of transferSigned actions\n * @param state$ - Observable of latest RaidenStates\n * @param config$ - Observable of latest RaidenConfig\n * @param action - The {@link transferSigned} action\n * @returns - Observable of {@link messageSend.request} actions\n */\nconst signedRetryMessage$ = (action$, state$, config$, action) => {\n    if (action.meta.direction !== Direction.SENT)\n        return EMPTY;\n    return config$.pipe(first(), switchMap(({ httpTimeout }) => {\n        const secrethash = action.meta.secrethash;\n        const signed = action.payload.message;\n        const send = messageSend.request({ message: signed }, { address: signed.recipient, msgId: signed.message_identifier.toString() });\n        const notifier = state$.pipe(pluckDistinct('sent', secrethash), filter((sent) => !!(sent.transferProcessed ||\n            sent.unlockProcessed ||\n            sent.lockExpiredProcessed ||\n            sent.channelClosed)));\n        // emit request once immediatelly, then wait until success, then retry every 30s\n        return retrySendUntil$(send, action$, notifier, httpTimeout);\n    }));\n};\n/**\n * Handles a transferUnlock.success action and retry messageSend until confirmed.\n * transferUnlock.success for pending Unlock's may be re-emitted on startup for pending transfer, to\n * start retrying sending the message again until stop condition is met.\n *\n * @param action$ - Observable of transferUnlock.success actions\n * @param state$ - Observable of the latest RaidenStates\n * @param config$ - Observable of latest RaidenConfig\n * @param action - the transferUnlock.success action\n * @returns Observable of {@link messageSend.request} actions\n */\nconst unlockedRetryMessage$ = (action$, state$, config$, action) => {\n    if (action.meta.direction !== Direction.SENT)\n        return EMPTY;\n    return state$.pipe(first(), withLatestFrom(config$), switchMap(([state, { httpTimeout }]) => {\n        const secrethash = action.meta.secrethash;\n        const unlock = action.payload.message;\n        const transfer = state.sent[secrethash].transfer[1];\n        const send = messageSend.request({ message: unlock }, { address: transfer.recipient, msgId: unlock.message_identifier.toString() });\n        const notifier = state$.pipe(pluckDistinct('sent', secrethash), filter((sent) => !!(sent.unlockProcessed || sent.channelClosed)));\n        // emit request once immediatelly, then wait until respective success,\n        // then repeats until confirmed\n        return retrySendUntil$(send, action$, notifier, httpTimeout);\n    }));\n};\n/**\n * Handles a transferExpire.success action and retry messageSend.request until transfer is gone (completed\n * with success or error).\n * transferExpire.success for pending LockExpired's may be re-emitted on startup for pending transfer, to\n * start retrying sending the message again until stop condition is met.\n *\n * @param action$ - Observable of transferUnlock.success actions\n * @param state$ - Observable of latest RaidenState\n * @param config$ - Observable of latest RaidenConfig\n * @param action - transferExpire.success action\n * @returns Observable of {@link messageSend.request} actions\n */\nconst expiredRetryMessages$ = (action$, state$, config$, action) => {\n    if (action.meta.direction !== Direction.SENT)\n        return EMPTY;\n    return state$.pipe(first(), withLatestFrom(config$), switchMap(([state, { httpTimeout }]) => {\n        const secrethash = action.meta.secrethash;\n        const lockExpired = action.payload.message;\n        const send = messageSend.request({ message: lockExpired }, {\n            address: state.sent[secrethash].transfer[1].recipient,\n            msgId: lockExpired.message_identifier.toString(),\n        });\n        const notifier = state$.pipe(pluckDistinct('sent', secrethash), filter((sent) => !!(sent.lockExpiredProcessed || sent.channelClosed)));\n        // emit request once immediatelly, then wait until respective success,\n        // then retries until confirmed\n        return retrySendUntil$(send, action$, notifier, httpTimeout);\n    }));\n};\nconst secretRequestRetryMessage$ = (action$, state$, config$, action) => {\n    if (action.meta.direction !== Direction.RECEIVED)\n        return EMPTY;\n    return state$.pipe(first(), withLatestFrom(config$), switchMap(([state, { httpTimeout }]) => {\n        const secrethash = action.meta.secrethash;\n        const request = action.payload.message;\n        const send = messageSend.request({ message: request }, {\n            address: state.received[secrethash].transfer[1].initiator,\n            msgId: request.message_identifier.toString(),\n        });\n        const notifier = state$.pipe(pluckDistinct('received', secrethash), \n        // stop retrying when we've signed secretReveal, lock expired or channel closed\n        // we could stop as soon as we know received.secret, but we use it to retry SecretReveal\n        // signature, if it failed for any reason\n        filter((received) => !!(received.secretReveal || received.lockExpired || received.channelClosed)));\n        // emit request once immediatelly, then wait until respective success,\n        // then retries until confirmed\n        return retrySendUntil$(send, action$, notifier, httpTimeout);\n    }));\n};\nconst secretRevealRetryMessage$ = (action$, state$, config$, action) => {\n    if (action.meta.direction !== Direction.RECEIVED)\n        return EMPTY;\n    return state$.pipe(first(), withLatestFrom(config$), switchMap(([state, { httpTimeout }]) => {\n        const secrethash = action.meta.secrethash;\n        const reveal = action.payload.message;\n        const send = messageSend.request({ message: reveal }, {\n            address: state.received[secrethash].partner,\n            msgId: reveal.message_identifier.toString(),\n        });\n        const notifier = state$.pipe(pluckDistinct('received', secrethash), \n        // stop retrying when we were unlocked, secret registered or channel closed\n        // we don't test for lockExpired, as we know the secret and must not accept LockExpired\n        filter((received) => { var _a, _b; return !!(received.unlock || ((_b = (_a = received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) || received.channelClosed); }));\n        // emit request once immediatelly, then wait until respective success,\n        // then retries until confirmed\n        return retrySendUntil$(send, action$, notifier, httpTimeout);\n    }));\n};\n/**\n * Retry sending balance proof messages until their respective Processed\n *\n * @param action$ - Observable of transferExpire.success actions\n * @param state$ - Observable of RaidenStates\n * @param latest$ - RaidenEpicDeps latest\n * @returns Observable of messageSend.request actions\n */\nexport const transferRetryMessageEpic = (action$, {}, { latest$, config$ }) => {\n    const state$ = latest$.pipe(pluckDistinct('state'));\n    return action$.pipe(filter(isActionOf([\n        transferSigned,\n        transferUnlock.success,\n        transferExpire.success,\n        transferSecretRequest,\n        transferSecretReveal,\n    ])), mergeMap((action) => transferSigned.is(action)\n        ? signedRetryMessage$(action$, state$, config$, action)\n        : transferUnlock.success.is(action)\n            ? unlockedRetryMessage$(action$, state$, config$, action)\n            : transferExpire.success.is(action)\n                ? expiredRetryMessages$(action$, state$, config$, action)\n                : transferSecretRequest.is(action)\n                    ? secretRequestRetryMessage$(action$, state$, config$, action)\n                    : secretRevealRetryMessage$(action$, state$, config$, action)));\n};\n//# sourceMappingURL=retry.js.map","import { EMPTY, from, of } from 'rxjs';\nimport { concatMap, filter, first, map, mergeMap, withLatestFrom, catchError, distinct, pluck, exhaustMap, takeUntil, ignoreElements, } from 'rxjs/operators';\nimport { newBlock } from '../../channels/actions';\nimport { assertTx } from '../../channels/utils';\nimport { messageSend } from '../../messages/actions';\nimport { MessageType, SecretRequest, SecretReveal } from '../../messages/types';\nimport { signMessage, isMessageReceivedOfType } from '../../messages/utils';\nimport { isActionOf, isConfirmationResponseOf } from '../../utils/actions';\nimport { RaidenError, ErrorCodes } from '../../utils/error';\nimport { getEventsStream } from '../../utils/ethers';\nimport { pluckDistinct } from '../../utils/rx';\nimport { Signed } from '../../utils/types';\nimport { transfer, transferSecret, transferSecretRegister, transferSecretRequest, transferSecretReveal, transferUnlock, } from '../actions';\nimport { getSecrethash, makeMessageId } from '../utils';\nimport { Direction } from '../state';\nimport { chooseOnchainAccount, getContractWithSigner } from '../../helpers';\nimport { Capabilities } from '../../constants';\nimport { dispatchAndWait$ } from './utils';\n/**\n * Handles receiving a signed SecretRequest from target for some sent LockedTransfer\n * Emits a transferSecretRequest action only if all conditions are met\n *\n * @param action$ - Observable of messageReceived actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSecretRequest actions\n */\nexport const transferSecretRequestedEpic = (action$, state$, { address, log }) => action$.pipe(filter(isMessageReceivedOfType(Signed(SecretRequest))), withLatestFrom(state$), mergeMap(function* ([action, state]) {\n    const message = action.payload.message;\n    // proceed only if we know the secret and the SENT transfer\n    if (!(message.secrethash in state.sent))\n        return;\n    const transfer = state.sent[message.secrethash].transfer[1];\n    // we do only some basic verification here, as most of it is done upon SecretReveal,\n    // to persist the request in most cases in TransferState.secretRequest\n    if (transfer.initiator !== address || // only the initiator may reply a SecretRequest\n        transfer.target !== action.meta.address || // reveal only to target\n        !transfer.payment_identifier.eq(message.payment_identifier)) {\n        log.warn('Invalid SecretRequest for transfer', message, transfer);\n        return;\n    }\n    yield transferSecretRequest({ message }, { secrethash: message.secrethash, direction: Direction.SENT });\n    // we don't check if transfer was refunded. If partner refunded the transfer but still\n    // forwarded the payment, they would be in risk of losing their money, not us\n}));\n/**\n * Contains the core logic of {@link transferSecretRevealEpic}.\n *\n * @param state - Contains the current state of the app\n * @param action - The {@link transferSecretRequest} action that\n * @param signer - The singer that will sign the message\n * @returns Observable of {@link transfer.failure}, {@link transferSecretReveal} or\n *      {@link messageSend.request} actions\n */\nconst secretReveal$ = (state, action, { signer, log }) => {\n    var _a;\n    const request = action.payload.message;\n    const secrethash = action.meta.secrethash;\n    if (!((_a = state.sent[secrethash]) === null || _a === void 0 ? void 0 : _a.secret)) {\n        // shouldn't happen, as we're the initiator (for now), and always know the secret\n        log.warn('SecretRequest for unknown secret', request, secrethash);\n        return EMPTY;\n    }\n    const transf = state.sent[secrethash].transfer[1];\n    const target = transf.target;\n    const fee = state.sent[secrethash].fee;\n    const value = transf.lock.amount.sub(fee);\n    if (!request.expiration.lte(transf.lock.expiration) ||\n        !request.expiration.gt(state.blockNumber)) {\n        log.error('SecretRequest for expired transfer', request, transf);\n        return EMPTY;\n    }\n    else if (request.amount.lt(value)) {\n        log.error('SecretRequest for amount too small!', request, transf);\n        return of(transfer.failure(new RaidenError(ErrorCodes.XFER_INVALID_SECRETREQUEST), action.meta));\n    }\n    else if (!request.amount.eq(value)) {\n        // accept request\n        log.info('Accepted SecretRequest for amount different than sent', request, transf);\n    }\n    let reveal$;\n    if (state.sent[action.meta.secrethash].secretReveal)\n        reveal$ = of(state.sent[action.meta.secrethash].secretReveal[1]);\n    else {\n        const message = {\n            type: MessageType.SECRET_REVEAL,\n            // eslint-disable-next-line @typescript-eslint/camelcase\n            message_identifier: makeMessageId(),\n            secret: state.sent[action.meta.secrethash].secret[1].value,\n        };\n        reveal$ = from(signMessage(signer, message, { log }));\n    }\n    return reveal$.pipe(mergeMap(function* (message) {\n        yield transferSecretReveal({ message }, action.meta);\n        yield messageSend.request({ message }, { address: target, msgId: message.message_identifier.toString() });\n    }));\n};\n/**\n * Handles a transferSecretRequest action to send the respective secret to target\n * It both emits transferSecretReveal (to persist sent SecretReveal in state and indicate that\n * the secret was revealed and thus the transfer should be assumed as succeeded) as well as\n * triggers sending the message once. New SecretRequests will cause a new transferSecretRequest,\n * which will re-send the cached SecretReveal.\n * transfer.failure is emitted in case invalid secretRequest comes, as no valid one will come as\n * per current implementation, so we fail early to notify users about it.\n *\n * @param action$ - Observable of transferSecretRequest actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @param deps.signer - RaidenEpicDeps signer\n * @param deps.latest$ - RaidenEpicDeps latest$\n * @returns Observable of transfer.failure|transferSecretReveal|messageSend.request actions\n */\nexport const transferSecretRevealEpic = (action$, {}, { log, signer, latest$ }) => action$.pipe(filter(isActionOf(transferSecretRequest)), filter((action) => action.meta.direction === Direction.SENT), concatMap((action) => latest$.pipe(pluckDistinct('state')).pipe(first(), mergeMap((state) => secretReveal$(state, action, { log, signer })))));\n/**\n * Handles receiving a valid SecretReveal from recipient (neighbor/partner)\n * This indicates that the partner knowws the secret, and we should Unlock to avoid going on-chain.\n * The transferUnlock.request action is a request for the unlocking to be generated and sent.\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of output actions for this epic\n */\nexport const transferSecretRevealedEpic = (action$, state$) => action$.pipe(\n// we don't require Signed SecretReveal, nor even check sender for persisting the secret\nfilter(isMessageReceivedOfType(SecretReveal)), withLatestFrom(state$), mergeMap(function* ([action, state]) {\n    const message = action.payload.message;\n    const secrethash = getSecrethash(message.secret);\n    if (secrethash in state.sent) {\n        const meta = { secrethash, direction: Direction.SENT };\n        // if secrethash matches, we're good for persisting\n        yield transferSecret({ secret: message.secret }, meta);\n        // but are stricter for unlocking to next hop\n        if (action.meta.address === state.sent[secrethash].partner &&\n            // don't unlock if channel closed\n            !state.sent[secrethash].channelClosed &&\n            // don't unlock again if already unlocked, retry handled by transferRetryMessageEpic\n            // in the future, we may avoid retry until Processed, and [re]send once per SecretReveal\n            !state.sent[secrethash].unlock\n        // accepts secretReveal/unlock request even if registered on-chain\n        ) {\n            // request unlock to be composed, signed & sent to partner\n            yield transferUnlock.request(undefined, meta);\n        }\n    }\n    // we're mediator or target, and received reveal from next hop or initiator, respectively\n    if (secrethash in state.received) {\n        // if secrethash matches, we're good for persisting, which also triggers Reveal back\n        yield transferSecret({ secret: message.secret }, { secrethash, direction: Direction.RECEIVED });\n    }\n}));\n/**\n * For a received transfer, when we know the secret, sign & send a SecretReveal to previous hop\n *\n * @param action$ - Observable of transferSecret|transferSecretReveal actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps\n * @returns Observable of transferSecretReveal actions\n */\nexport const transferRequestUnlockEpic = (action$, {}, { log, signer, latest$ }) => action$.pipe(filter(isActionOf([transferSecret, transferSecretRegister.success])), filter((action) => action.meta.direction === Direction.RECEIVED), concatMap((action) => latest$.pipe(pluckDistinct('state'), first(), filter(({ received }) => { var _a; return !((_a = received[action.meta.secrethash]) === null || _a === void 0 ? void 0 : _a.secretReveal); }), mergeMap(() => {\n    const message = {\n        type: MessageType.SECRET_REVEAL,\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        message_identifier: makeMessageId(),\n        secret: action.payload.secret,\n    };\n    return signMessage(signer, message, { log });\n}), map((message) => transferSecretReveal({ message }, action.meta)), catchError((err) => {\n    log.warn('Error trying to sign SecretReveal - ignoring', err, action.meta);\n    return EMPTY;\n}))));\n/**\n * Monitors SecretRegistry and emits when a relevant secret gets registered\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSecretRegister.success actions\n */\nexport const monitorSecretRegistryEpic = ({}, state$, { secretRegistryContract }) => getEventsStream(secretRegistryContract, [\n    secretRegistryContract.filters.SecretRevealed(null, null),\n]).pipe(withLatestFrom(state$), filter(([[secrethash, , { blockNumber }], { sent, received }]) => \n// emits only if lock didn't expire yet\n(secrethash in sent && sent[secrethash].transfer[1].lock.expiration.gte(blockNumber)) ||\n    (secrethash in received &&\n        received[secrethash].transfer[1].lock.expiration.gte(blockNumber))), mergeMap(function* ([[secrethash, secret, event], { sent, received }]) {\n    if (secrethash in sent &&\n        sent[secrethash].transfer[1].lock.expiration.gte(event.blockNumber)) {\n        yield transferSecretRegister.success({\n            secret,\n            txHash: event.transactionHash,\n            txBlock: event.blockNumber,\n            confirmed: undefined,\n        }, { secrethash, direction: Direction.SENT });\n    }\n    if (secrethash in received &&\n        received[secrethash].transfer[1].lock.expiration.gte(event.blockNumber)) {\n        yield transferSecretRegister.success({\n            secret,\n            txHash: event.transactionHash,\n            txBlock: event.blockNumber,\n            confirmed: undefined,\n        }, { secrethash, direction: Direction.RECEIVED });\n    }\n}));\n/**\n * A simple epic to emit transfer.success when secret register is confirmed\n *\n * @param action$ - Observable of transferSecretRegister.success actions\n * @returns Observable of transfer.success actions\n */\nexport const transferSuccessOnSecretRegisteredEpic = (action$) => action$.pipe(filter(transferSecretRegister.success.is), filter((action) => !!action.payload.confirmed), map((action) => transfer.success({}, action.meta)));\n/**\n * Process newBlocks and pending received transfers. If we know the secret, and transfer doesn't\n * get unlocked before revealTimeout blocks are left to lock expiration, request to register secret\n * TODO: check economic viability (and define what that means) of registering lock on-chain\n *\n * @param action$ - Observable of newBlock actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of transferSecretRegister.request actions\n */\nexport const transferAutoRegisterEpic = (action$, state$, { config$, latest$ }) => state$.pipe(pluckDistinct(Direction.RECEIVED), mergeMap((received) => from(Object.keys(received))), distinct(), mergeMap((secrethash) => action$.pipe(filter(newBlock.is), withLatestFrom(latest$.pipe(pluck('state', Direction.RECEIVED, secrethash)), config$), filter(([action, received, { caps, revealTimeout }]) => {\n    var _a, _b;\n    return !(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_RECEIVE]) && // ignore if receiving is disabled\n        !!received.secret && // register only if we know the secret\n        received.transfer[1].lock.expiration\n            .sub(revealTimeout)\n            .lt(action.payload.blockNumber) && // and after <revealTimeout left to expiration\n        !((_b = (_a = received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock) && // and not yet registered nor unlocked\n        !received.unlock;\n}), exhaustMap(([, received]) => {\n    const meta = { secrethash, direction: Direction.RECEIVED };\n    return dispatchAndWait$(action$, transferSecretRegister.request({ secret: received.secret[1].value }, meta), isConfirmationResponseOf(transferSecretRegister, meta));\n}), takeUntil(latest$.pipe(pluckDistinct('state'), filter((state) => {\n    var _a, _b;\n    const blockNumber = state.blockNumber;\n    const received = state.received[secrethash];\n    const expiration = received.transfer[1].lock.expiration;\n    return !!(expiration.lt(blockNumber) || // give up if lock already expired\n        received.unlock || ((_b = (_a = \n    // stop if secret got registered or unlocked\n    received.secret) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.registerBlock));\n    // even if channelClosed, while inside lock expiration, continue to try to register\n}))))));\n/**\n * Registers secret on-chain. Success is detected by monitorSecretRegistryEpic\n *\n * @param action$ - Observable of transferSecretRegister.request actions\n * @param state$ - Observable of RaidenStates\n * @param deps - Dependencies\n * @returns Observable of transferSecretRegister.failure actions\n */\nexport const transferSecretRegisterEpic = (action$, {}, { log, signer, address, main, secretRegistryContract, config$ }) => action$.pipe(filter(transferSecretRegister.request.is), withLatestFrom(config$), mergeMap(([action, { subkey: configSubkey }]) => {\n    var _a;\n    const { signer: onchainSigner } = chooseOnchainAccount({ signer, address, main }, (_a = action.payload.subkey) !== null && _a !== void 0 ? _a : configSubkey);\n    const contract = getContractWithSigner(secretRegistryContract, onchainSigner);\n    return from(contract.functions.registerSecret(action.payload.secret)).pipe(assertTx('registerSecret', ErrorCodes.XFER_REGISTERSECRET_TX_FAILED, { log }), \n    // transferSecretRegister.success handled by monitorSecretRegistryEpic\n    ignoreElements(), catchError((err) => of(transferSecretRegister.failure(err, action.meta))));\n}));\n//# sourceMappingURL=secret.js.map","import { filter, map } from 'rxjs/operators';\nimport { Signed } from '../../utils/types';\nimport { isActionOf } from '../../utils/actions';\nimport { messageSend } from '../../messages/actions';\nimport { WithdrawRequest } from '../../messages/types';\nimport { isMessageReceivedOfType } from '../../messages/utils';\nimport { withdrawReceive } from '../actions';\n/**\n * When receiving a [[WithdrawRequest]] message, create the respective [[withdrawReceive.request]]\n * action\n *\n * @param action$ - Observable of messageReceived actions\n * @returns Observable of withdrawReceive.request actions\n */\nexport const withdrawRequestReceivedEpic = (action$) => action$.pipe(filter(isMessageReceivedOfType(Signed(WithdrawRequest))), filter((action) => action.payload.message.participant === action.meta.address), map((action) => {\n    const message = action.payload.message;\n    return withdrawReceive.request({ message }, {\n        tokenNetwork: message.token_network_address,\n        partner: message.participant,\n        totalWithdraw: message.total_withdraw,\n        expiration: message.expiration.toNumber(),\n    });\n}));\n/**\n * sendMessage when a [[withdrawReceive.success]] action is fired\n *\n * @param action$ - Observable of withdrawReceive.success actions\n * @returns Observable of messageSend.request actions\n */\nexport const withdrawSendConfirmationEpic = (action$) => action$.pipe(filter(isActionOf(withdrawReceive.success)), map((action) => messageSend.request({ message: action.payload.message }, {\n    address: action.meta.partner,\n    msgId: action.payload.message.message_identifier.toString(),\n})));\n//# sourceMappingURL=withdraw.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/camelcase */\nimport * as t from 'io-ts';\nimport { from, of, EMPTY } from 'rxjs';\nimport { mergeMap, map, timeout, withLatestFrom, catchError, toArray } from 'rxjs/operators';\nimport { fromFetch } from 'rxjs/fetch';\nimport memoize from 'lodash/memoize';\nimport { Address, UInt, decode } from '../utils/types';\nimport { losslessParse } from '../utils/data';\nimport { ChannelState } from '../channels/state';\nimport { channelAmounts } from '../channels/utils';\nimport { RaidenError, ErrorCodes } from '../utils/error';\nimport { Capabilities } from '../constants';\nimport { isValidUrl } from '../helpers';\n/**\n * Either returns true if given channel can route a payment, or a reason as string if not\n *\n * @param state - current RaidenState\n * @param presences - latest Presences mapping\n * @param tokenNetwork - tokenNetwork where the channel is\n * @param partner - possibly a partner on given tokenNetwork\n * @param target - transfer target\n * @param value - amount of tokens to check if channel can route\n * @returns true if channel can route, string containing reason if not\n */\nexport function channelCanRoute(state, presences, tokenNetwork, partner, target, value) {\n    var _a;\n    if (!(partner in presences) || !presences[partner].payload.available)\n        return `path: partner \"${partner}\" not available in transport`;\n    if (target !== partner && ((_a = presences[partner].payload.caps) === null || _a === void 0 ? void 0 : _a[Capabilities.NO_MEDIATE]))\n        return `path: partner \"${partner}\" doesn't mediate transfers`;\n    if (!(partner in state.channels[tokenNetwork]))\n        return `path: there's no direct channel with partner \"${partner}\"`;\n    const channel = state.channels[tokenNetwork][partner];\n    if (channel.state !== ChannelState.open)\n        return `path: channel with \"${partner}\" in state \"${channel.state}\" instead of \"${ChannelState.open}\"`;\n    const { ownCapacity: capacity } = channelAmounts(channel);\n    if (capacity.lt(value))\n        return `path: channel with \"${partner}\" doesn't have enough capacity=${capacity.toString()}`;\n    return true;\n}\nconst serviceRegistryToken = memoize((serviceRegistryContract) => __awaiter(void 0, void 0, void 0, function* () { return serviceRegistryContract.functions.token(); }));\n/**\n * Returns a cold observable which fetch PFS info & validate for a given server address or URL\n *\n * @param pfsAddrOrUrl - PFS account/address or URL\n * @param deps - RaidenEpicDeps needed for various parameters\n * @returns Observable containing PFS server info\n */\nexport function pfsInfo(pfsAddrOrUrl, { serviceRegistryContract, network, contractsInfo, config$ }) {\n    /**\n     * Codec for PFS /api/v1/info result schema\n     */\n    const PathInfo = t.type({\n        message: t.string,\n        network_info: t.type({\n            // literals will fail if trying to decode anything different from these constants\n            chain_id: t.literal(network.chainId),\n            token_network_registry_address: t.literal(contractsInfo.TokenNetworkRegistry.address),\n        }),\n        operator: t.string,\n        payment_address: Address,\n        price_info: UInt(32),\n        version: t.string,\n    });\n    // if it's an address, fetch url from ServiceRegistry, else it's already the URL\n    const url$ = Address.is(pfsAddrOrUrl)\n        ? from(serviceRegistryContract.functions.urls(pfsAddrOrUrl))\n        : of(pfsAddrOrUrl);\n    return url$.pipe(withLatestFrom(config$), mergeMap(([url, { httpTimeout }]) => {\n        if (!url)\n            throw new RaidenError(ErrorCodes.PFS_EMPTY_URL);\n        else if (!isValidUrl(url))\n            throw new RaidenError(ErrorCodes.PFS_INVALID_URL, { url });\n        // default to https for domain-only urls\n        else if (!url.startsWith('https://') && !url.startsWith('http://'))\n            url = `https://${url}`;\n        const start = Date.now();\n        return fromFetch(url + '/api/v1/info').pipe(timeout(httpTimeout), mergeMap((res) => __awaiter(this, void 0, void 0, function* () {\n            return [\n                decode(PathInfo, losslessParse(yield res.text())),\n                yield serviceRegistryToken(serviceRegistryContract),\n            ];\n        })), map(([info, token]) => ({\n            address: info.payment_address,\n            url,\n            rtt: Date.now() - start,\n            price: info.price_info,\n            token,\n        })));\n    }));\n}\n/**\n * Retrieve pfsInfo for these servers & return sorted PFS info\n *\n * Sort order is price then response time (rtt).\n * Throws if no server can be validated, meaning either there's none in the current network or\n * we're out-of-sync (outdated or ahead of PFS's deployment network version).\n *\n * @param pfsList - Array of PFS addresses or URLs\n * @param deps - RaidenEpicDeps array\n * @returns Observable of online, validated & sorted PFS info array\n */\nexport function pfsListInfo(pfsList, deps) {\n    const { log } = deps;\n    return from(pfsList).pipe(mergeMap((addrOrUrl) => pfsInfo(addrOrUrl, deps).pipe(catchError((err) => {\n        log.warn(`Error trying to fetch PFS info for \"${addrOrUrl}\" - ignoring:`, err);\n        return EMPTY;\n    })), 5), toArray(), map((list) => {\n        if (!list.length)\n            throw new RaidenError(ErrorCodes.PFS_INVALID_INFO);\n        return list.sort((a, b) => {\n            const dif = a.price.sub(b.price);\n            // first, sort by price\n            if (dif.lt(0))\n                return -1;\n            else if (dif.gt(0))\n                return 1;\n            // if it's equal, tiebreak on rtt\n            else\n                return a.rtt - b.rtt;\n        });\n    }));\n}\n//# sourceMappingURL=utils.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/camelcase */\nimport * as t from 'io-ts';\nimport { defer, EMPTY, from, merge, of } from 'rxjs';\nimport { catchError, concatMap, debounceTime, delay, distinctUntilChanged, filter, first, groupBy, map, mergeMap, pluck, scan, switchMap, tap, timeout, withLatestFrom, } from 'rxjs/operators';\nimport { fromFetch } from 'rxjs/fetch';\nimport { bigNumberify, toUtf8Bytes, verifyMessage, concat } from 'ethers/utils';\nimport { Two, Zero } from 'ethers/constants';\nimport memoize from 'lodash/memoize';\nimport { messageGlobalSend } from '../messages/actions';\nimport { MessageType } from '../messages/types';\nimport { MessageTypeId, signMessage } from '../messages/utils';\nimport { channelMonitor } from '../channels/actions';\nimport { ChannelState } from '../channels/state';\nimport { channelAmounts } from '../channels/utils';\nimport { decode, UInt, isntNil } from '../utils/types';\nimport { isActionOf } from '../utils/actions';\nimport { encode, losslessParse, losslessStringify } from '../utils/data';\nimport { getEventsStream } from '../utils/ethers';\nimport { RaidenError, ErrorCodes } from '../utils/error';\nimport { pluckDistinct } from '../utils/rx';\nimport { Capabilities } from '../constants';\nimport { iouClear, pathFind, iouPersist, pfsListUpdated } from './actions';\nimport { channelCanRoute, pfsInfo, pfsListInfo } from './utils';\nimport { LastIOUResults, PathResults } from './types';\nconst oneToNAddress = memoize((userDepositContract) => __awaiter(void 0, void 0, void 0, function* () { return userDepositContract.functions.one_to_n_address(); }));\n/**\n * Codec for PFS API returned error\n *\n * May contain other fields like error_details, but we don't care about them (for now)\n */\nconst PathError = t.readonly(t.type({\n    /* eslint-disable-next-line @typescript-eslint/camelcase */\n    error_code: t.number,\n    errors: t.string,\n}));\n// returns a ISO string truncated at the integer second resolution\nfunction makeTimestamp(time) {\n    return (time !== null && time !== void 0 ? time : new Date()).toISOString().substr(0, 19);\n}\nconst makeIOU = (sender, receiver, chainId, oneToNAddress, blockNumber) => ({\n    sender: sender,\n    receiver: receiver,\n    chain_id: bigNumberify(chainId),\n    amount: Zero,\n    one_to_n_address: oneToNAddress,\n    expiration_block: bigNumberify(blockNumber).add(2 * Math.pow(10, 5)),\n});\nconst updateIOU = (iou, price) => (Object.assign(Object.assign({}, iou), { amount: iou.amount.add(price) }));\nconst packIOU = (iou) => concat([\n    encode(iou.one_to_n_address, 20),\n    encode(iou.chain_id, 32),\n    encode(MessageTypeId.IOU, 32),\n    encode(iou.sender, 20),\n    encode(iou.receiver, 20),\n    encode(iou.amount, 32),\n    encode(iou.expiration_block, 32),\n]);\nconst signIOU$ = (iou, signer) => from(signer.signMessage(packIOU(iou))).pipe(map((signature) => (Object.assign(Object.assign({}, iou), { signature }))));\nconst makeAndSignLastIOURequest$ = (sender, receiver, signer) => defer(() => {\n    const timestamp = makeTimestamp(), message = concat([sender, receiver, toUtf8Bytes(timestamp)]);\n    return from(signer.signMessage(message)).pipe(map((signature) => ({ sender, receiver, timestamp, signature })));\n});\nconst prepareNextIOU$ = (pfs, tokenNetwork, { address, signer, network, userDepositContract, latest$ }) => {\n    return latest$.pipe(first(), switchMap(({ state, config: { httpTimeout } }) => {\n        var _a;\n        const cachedIOU = (_a = state.path.iou[tokenNetwork]) === null || _a === void 0 ? void 0 : _a[pfs.address];\n        return (cachedIOU\n            ? of(cachedIOU)\n            : makeAndSignLastIOURequest$(address, pfs.address, signer).pipe(mergeMap((payload) => fromFetch(`${pfs.url}/api/v1/${tokenNetwork}/payment/iou?${new URLSearchParams(payload).toString()}`, {\n                method: 'GET',\n                headers: { 'Content-Type': 'application/json' },\n            }).pipe(timeout(httpTimeout))), withLatestFrom(latest$.pipe(pluck('state'))), mergeMap(([response, { blockNumber }]) => __awaiter(void 0, void 0, void 0, function* () {\n                if (response.status === 404) {\n                    return makeIOU(address, pfs.address, network.chainId, yield oneToNAddress(userDepositContract), blockNumber);\n                }\n                const text = yield response.text();\n                if (!response.ok)\n                    throw new RaidenError(ErrorCodes.PFS_LAST_IOU_REQUEST_FAILED, {\n                        responseStatus: response.status,\n                        responseText: text,\n                    });\n                const { last_iou: lastIou } = decode(LastIOUResults, losslessParse(text));\n                const signer = verifyMessage(packIOU(lastIou), lastIou.signature);\n                if (signer !== address)\n                    throw new RaidenError(ErrorCodes.PFS_IOU_SIGNATURE_MISMATCH, {\n                        signer,\n                        address,\n                    });\n                return lastIou;\n            })))).pipe(map((iou) => updateIOU(iou, pfs.price)), mergeMap((iou) => signIOU$(iou, signer)));\n    }));\n};\n/**\n * Check if a transfer can be made and return a set of paths for it.\n *\n * @param action$ - Observable of pathFind.request actions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps object\n * @returns Observable of pathFind.{success|failure} actions\n */\nexport const pathFindServiceEpic = (action$, {}, deps) => {\n    const { log, latest$ } = deps;\n    return action$.pipe(filter(isActionOf(pathFind.request)), concatMap((action) => latest$.pipe(first(), mergeMap(({ state, presences, config: { pfs: configPfs, httpTimeout, pfsSafetyMargin } }) => {\n        var _a;\n        const { tokenNetwork, target } = action.meta;\n        if (!(tokenNetwork in state.channels))\n            throw new RaidenError(ErrorCodes.PFS_UNKNOWN_TOKEN_NETWORK, { tokenNetwork });\n        if (!(target in presences) || !presences[target].payload.available)\n            throw new RaidenError(ErrorCodes.PFS_TARGET_OFFLINE, { target });\n        if ((_a = presences[target].payload.caps) === null || _a === void 0 ? void 0 : _a[Capabilities.NO_RECEIVE])\n            throw new RaidenError(ErrorCodes.PFS_TARGET_NO_RECEIVE, { target });\n        // if pathFind received a set of paths, pass it through to validation/cleanup\n        if (action.payload.paths)\n            return of({ paths: action.payload.paths, iou: undefined });\n        // else, if possible, use a direct transfer\n        else if (channelCanRoute(state, presences, tokenNetwork, target, target, action.meta.value) === true) {\n            return of({\n                paths: [{ path: [deps.address, target], fee: Zero }],\n                iou: undefined,\n            });\n        }\n        else if (action.payload.pfs === null || // explicitly disabled in action\n            (!action.payload.pfs && configPfs === null) // undefined in action and disabled in config\n        ) {\n            // pfs not specified in action and disabled (null) in config\n            throw new RaidenError(ErrorCodes.PFS_DISABLED);\n        }\n        else {\n            // else, request a route from PFS.\n            // pfs$ - Observable which emits one PFS info and then completes\n            const pfs$ = action.payload.pfs\n                ? // first, use action.payload.pfs as is, if present\n                    of(action.payload.pfs)\n                : configPfs\n                    ? // or if config.pfs isn't disabled (null) nor auto (''), fetch & use it\n                        pfsInfo(configPfs, deps)\n                    : // else (action unset, config.pfs=''=auto mode)\n                        latest$.pipe(pluck('pfsList'), // get cached pfsList\n                        // if needed, wait for list to be populated\n                        first((pfsList) => pfsList.length > 0), \n                        // fetch pfsInfo from whole list & sort it\n                        mergeMap((pfsList) => pfsListInfo(pfsList, deps)), tap((pfss) => log.info('Auto-selecting best PFS from:', pfss)), \n                        // pop best ranked\n                        pluck(0));\n            return pfs$.pipe(mergeMap((pfs) => pfs.price.isZero()\n                ? of({ pfs, iou: undefined })\n                : prepareNextIOU$(pfs, tokenNetwork, deps).pipe(map((iou) => ({ pfs, iou })))), mergeMap(({ pfs, iou }) => fromFetch(`${pfs.url}/api/v1/${tokenNetwork}/paths`, {\n                method: 'POST',\n                headers: { 'Content-Type': 'application/json' },\n                body: losslessStringify({\n                    from: deps.address,\n                    to: target,\n                    value: UInt(32).encode(action.meta.value),\n                    max_paths: 10,\n                    iou: iou\n                        ? Object.assign(Object.assign({}, iou), { amount: UInt(32).encode(iou.amount), expiration_block: UInt(32).encode(iou.expiration_block), chain_id: UInt(32).encode(iou.chain_id) }) : undefined,\n                }),\n            }).pipe(timeout(httpTimeout), map((response) => ({ response, iou })))), mergeMap(({ response, iou }) => __awaiter(void 0, void 0, void 0, function* () {\n                return ({\n                    response,\n                    text: yield response.text(),\n                    iou,\n                });\n            })), map(({ response, text, iou }) => {\n                // any decode error here will throw early and end up in catchError\n                const data = losslessParse(text);\n                if (!response.ok) {\n                    return { error: decode(PathError, data), iou };\n                }\n                return {\n                    paths: decode(PathResults, data).result.map((r) => ({\n                        path: r.path,\n                        // Add PFS safety margin to estimated fees\n                        fee: r.estimated_fee\n                            .mul(Math.round(pfsSafetyMargin * 1e6))\n                            .div(1e6),\n                    })),\n                    iou,\n                };\n            }));\n        }\n    }), withLatestFrom(latest$), \n    // validate/cleanup received routes/paths/results\n    mergeMap(([data, { state, presences }]) => \n    // looks like mergeMap with generator doesn't handle exceptions correctly\n    // use from+iterator from iife generator instead\n    from((function* () {\n        const { iou } = data;\n        if (iou) {\n            // if not error or error_code of \"no route found\", iou accepted => persist\n            if (data.paths || data.error.error_code === 2201)\n                yield iouPersist({ iou }, { tokenNetwork: action.meta.tokenNetwork, serviceAddress: iou.receiver });\n            // else (error and error_code of \"iou rejected\"), clear\n            else\n                yield iouClear(undefined, {\n                    tokenNetwork: action.meta.tokenNetwork,\n                    serviceAddress: iou.receiver,\n                });\n        }\n        // if error, don't proceed\n        if (!data.paths) {\n            const { errors, error_code } = data.error;\n            if (error_code === 2201) {\n                throw new RaidenError(ErrorCodes.PFS_NO_ROUTES_BETWEEN_NODES);\n            }\n            throw new RaidenError(ErrorCodes.PFS_ERROR_RESPONSE, {\n                errorCode: error_code,\n                errors,\n            });\n        }\n        const filteredPaths = [], invalidatedRecipients = new Set();\n        // eslint-disable-next-line prefer-const\n        for (let { path, fee } of data.paths) {\n            // if route has us as first hop, cleanup/shift\n            if (path[0] === deps.address)\n                path = path.slice(1);\n            const recipient = path[0];\n            // if this recipient was already invalidated in a previous iteration, skip\n            if (invalidatedRecipients.has(recipient))\n                continue;\n            // if we already found some valid route, allow only new routes through this peer\n            const canTransferOrReason = !filteredPaths.length\n                ? channelCanRoute(state, presences, action.meta.tokenNetwork, recipient, action.meta.target, action.meta.value.add(fee))\n                : recipient !== filteredPaths[0].path[0]\n                    ? 'path: already selected another recipient'\n                    : fee.gt(filteredPaths[0].fee)\n                        ? 'path: already selected a smaller fee'\n                        : true;\n            if (canTransferOrReason !== true) {\n                log.warn('Invalidated received route. Reason:', canTransferOrReason, 'Route:', path);\n                invalidatedRecipients.add(recipient);\n                continue;\n            }\n            filteredPaths.push({ path, fee });\n        }\n        if (!filteredPaths.length)\n            throw new RaidenError(ErrorCodes.PFS_NO_ROUTES_FOUND);\n        yield pathFind.success({ paths: filteredPaths }, action.meta);\n    })())), catchError((err) => of(pathFind.failure(err, action.meta))))));\n};\nfunction channelEntries(channels) {\n    return Object.entries(channels)\n        .map(([tokenNetwork, partnerChannels]) => Object.entries(partnerChannels).map(([partner, channel]) => [`${partner}@${tokenNetwork}`, channel]))\n        .reduce((acc, val) => [...acc, ...val], []);\n}\nfunction keyToTNP(key) {\n    const [partner, tokenNetwork] = key.split('@');\n    return { key, tokenNetwork: tokenNetwork, partnerAddr: partner };\n}\n/**\n * Sends a [[PFSCapacityUpdate]] to PFS global room on new deposit on our side of channels\n *\n * @param action$ - Observable of channelDeposit.success actions\n * @param state$ - Observable of RaidenStates\n * @returns Observable of messageGlobalSend actions\n */\nexport const pfsCapacityUpdateEpic = ({}, {}, { log, address, network, signer, config$, latest$ }) => latest$.pipe(pluckDistinct('state', 'channels'), concatMap((channels) => from(channelEntries(channels))), \n/* this scan stores a reference to each [key,value] in 'acc', and emit as 'changed' iff it\n * changes from last time seen. It relies on value references changing only if needed */\nscan(({ acc }, [key, channel]) => \n// if ref didn't change, emit previous accumulator, without 'changed' value\nacc[key] === channel\n    ? { acc }\n    : // else, update ref in 'acc' and emit value in 'changed' prop\n        {\n            acc: Object.assign(Object.assign({}, acc), { [key]: channel }),\n            changed: Object.assign(Object.assign({}, channel), keyToTNP(key)),\n        }, { acc: {} }), pluck('changed'), filter(isntNil), // filter out if reference didn't change from last emit\ngroupBy(({ key }) => key), withLatestFrom(config$), mergeMap(([grouped$, { httpTimeout }]) => grouped$.pipe(withLatestFrom(config$), filter(([, { pfsRoom }]) => !!pfsRoom), // ignore actions while/if config.pfsRoom isn't set\ndebounceTime(httpTimeout / 2), // default: 15s\nconcatMap(([channel, { revealTimeout, pfsRoom }]) => {\n    var _a, _b, _c, _d;\n    const { tokenNetwork, partnerAddr: partner } = channel;\n    if (channel.state !== ChannelState.open)\n        return EMPTY;\n    const { ownCapacity, partnerCapacity } = channelAmounts(channel);\n    const message = {\n        type: MessageType.PFS_CAPACITY_UPDATE,\n        canonical_identifier: {\n            chain_identifier: bigNumberify(network.chainId),\n            token_network_address: tokenNetwork,\n            channel_identifier: bigNumberify(channel.id),\n        },\n        updating_participant: address,\n        other_participant: partner,\n        updating_nonce: (_b = (_a = channel.own.balanceProof) === null || _a === void 0 ? void 0 : _a.nonce) !== null && _b !== void 0 ? _b : Zero,\n        other_nonce: (_d = (_c = channel.partner.balanceProof) === null || _c === void 0 ? void 0 : _c.nonce) !== null && _d !== void 0 ? _d : Zero,\n        updating_capacity: ownCapacity,\n        other_capacity: partnerCapacity,\n        reveal_timeout: bigNumberify(revealTimeout),\n    };\n    return defer(() => signMessage(signer, message, { log })).pipe(map((signed) => messageGlobalSend({ message: signed }, { roomName: pfsRoom })), catchError((err) => {\n        log.error('Error trying to generate & sign PFSCapacityUpdate', err);\n        return EMPTY;\n    }));\n}))));\n/**\n * When monitoring a channel (either a new channel or a previously monitored one), send a matching\n * PFSFeeUpdate to path_finding global room, so PFSs can pick us for mediation\n * TODO: Currently, we always send Zero fees; we should send correct fee data from config\n *\n * @param action$ - Observable of channelMonitor actions\n * @param state$ - Observable of RaidenStates\n * @param deps - Raiden epic dependencies\n * @returns Observable of messageGlobalSend actions\n */\nexport const pfsFeeUpdateEpic = (action$, state$, { log, address, network, signer, config$ }) => action$.pipe(filter(channelMonitor.is), withLatestFrom(state$, config$), \n// ignore actions while/if mediating not enabled\nfilter(([, , { pfsRoom, caps }]) => !!pfsRoom && !(caps === null || caps === void 0 ? void 0 : caps[Capabilities.NO_MEDIATE])), mergeMap(([action, state, { pfsRoom }]) => {\n    var _a;\n    const channel = (_a = state.channels[action.meta.tokenNetwork]) === null || _a === void 0 ? void 0 : _a[action.meta.partner];\n    if ((channel === null || channel === void 0 ? void 0 : channel.state) !== ChannelState.open)\n        return EMPTY;\n    const message = {\n        type: MessageType.PFS_FEE_UPDATE,\n        canonical_identifier: {\n            chain_identifier: bigNumberify(network.chainId),\n            token_network_address: action.meta.tokenNetwork,\n            channel_identifier: bigNumberify(channel.id),\n        },\n        updating_participant: address,\n        timestamp: makeTimestamp(),\n        fee_schedule: {\n            cap_fees: true,\n            imbalance_penalty: null,\n            proportional: Zero,\n            flat: Zero,\n        },\n    };\n    return from(signMessage(signer, message, { log })).pipe(map((signed) => messageGlobalSend({ message: signed }, { roomName: pfsRoom })), catchError((err) => {\n        log.error('Error trying to generate & sign PFSFeeUpdate', err);\n        return EMPTY;\n    }));\n}));\n/**\n * Fetch & monitors ServiceRegistry's RegisteredService events, keep track of valid_till expiration\n * and aggregate list of valid service addresses\n *\n * Notice this epic only deals with the events & addresses, and don't fetch URLs, which need to be\n * fetched on-demand through [[pfsInfo]] & [[pfsListInfo]].\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @param deps - RaidenEpicDeps object\n * @returns Observable of pfsListUpdated actions\n */\nexport const pfsServiceRegistryMonitorEpic = ({}, {}, { serviceRegistryContract, contractsInfo, config$ }) => config$.pipe(\n// monitors config.pfs, and only monitors contract if it's empty\npluckDistinct('pfs'), switchMap((pfs) => pfs !== ''\n    ? // disable ServiceRegistry monitoring if/while pfs is null=disabled or truty\n        EMPTY\n    : // type of elements emitted by getEventsStream (past and new events coming from contract):\n        // [service, valid_till, deposit_amount, deposit_contract, Event]\n        getEventsStream(serviceRegistryContract, [serviceRegistryContract.filters.RegisteredService(null, null, null, null)], of(contractsInfo.ServiceRegistry.block_number)).pipe(groupBy(([service]) => service), mergeMap((grouped$) => grouped$.pipe(\n        // switchMap ensures new events for each server (grouped$) picks latest event\n        switchMap(([service, valid_till]) => {\n            const now = Date.now(), validTill = valid_till.mul(1000); // milliseconds valid_till\n            if (validTill.lt(now))\n                return EMPTY; // this event already expired\n            // end$ will emit valid=false iff <2^31 ms in the future (setTimeout limit)\n            const end$ = validTill.sub(now).lt(Two.pow(31))\n                ? of({ service, valid: false }).pipe(delay(new Date(validTill.toNumber())))\n                : EMPTY;\n            return merge(of({ service, valid: true }), end$);\n        }))), scan((acc, { service, valid }) => !valid && acc.includes(service)\n            ? acc.filter((s) => s !== service)\n            : valid && !acc.includes(service)\n                ? [...acc, service]\n                : acc, []), distinctUntilChanged(), debounceTime(1e3), // debounce burst of updates on initial fetch\n        map((pfsList) => pfsListUpdated({ pfsList })))));\n//# sourceMappingURL=epics.js.map","import { from, of, combineLatest } from 'rxjs';\nimport { catchError, filter, mergeMap, takeWhile, takeUntil, pluck, startWith, map, scan, } from 'rxjs/operators';\nimport negate from 'lodash/negate';\nimport unset from 'lodash/fp/unset';\nimport { raidenShutdown } from './actions';\nimport { pluckDistinct } from './utils/rx';\nimport { getPresences$ } from './transport/utils';\nimport { rtcChannel } from './transport/actions';\nimport { pfsListUpdated } from './services/actions';\nimport { isActionOf } from './utils/actions';\nimport * as ChannelsEpics from './channels/epics';\nimport * as TransportEpics from './transport/epics';\nimport * as TransfersEpics from './transfers/epics';\nimport * as ServicesEpics from './services/epics';\n/**\n * This function maps cached/latest relevant values from action$ & state$\n *\n * @param action$ - Observable of RaidenActions\n * @param state$ - Observable of RaidenStates\n * @returns latest$ observable\n */\nexport function getLatest$(action$, state$, { defaultConfig }) {\n    return combineLatest([\n        action$,\n        state$,\n        state$.pipe(pluckDistinct('config'), map((c) => (Object.assign(Object.assign({}, defaultConfig), c)))),\n        getPresences$(action$),\n        action$.pipe(filter(isActionOf(pfsListUpdated)), pluck('payload', 'pfsList'), startWith([])),\n        action$.pipe(filter(rtcChannel.is), \n        // scan: if v.payload is defined, set it; else, unset\n        scan((acc, v) => v.payload ? Object.assign(Object.assign({}, acc), { [v.meta.address]: v.payload }) : unset(v.meta.address, acc), {}), startWith({})),\n    ]).pipe(map(([action, state, config, presences, pfsList, rtc]) => {\n        return {\n            action,\n            state,\n            config,\n            presences,\n            pfsList,\n            rtc,\n        };\n    }));\n}\nconst RaidenEpics = Object.assign(Object.assign(Object.assign(Object.assign({}, ChannelsEpics), TransportEpics), TransfersEpics), ServicesEpics);\nexport const raidenRootEpic = (action$, state$, deps) => {\n    // observable which emits once when a raidenShutdown action goes through actions pipeline\n    const shutdownNotification = action$.pipe(filter(isActionOf(raidenShutdown))), \n    // actions pipeline, but ends with (including) a raidenShutdown action\n    limitedAction$ = action$.pipe(takeWhile(negate(isActionOf(raidenShutdown)), true)), \n    // states pipeline, but ends when shutdownNotification emits\n    limitedState$ = state$.pipe(takeUntil(shutdownNotification));\n    // wire deps.latest$\n    getLatest$(limitedAction$, limitedState$, deps).subscribe(deps.latest$);\n    // like combineEpics, but completes action$, state$ & output$ when a raidenShutdown goes through\n    return from(Object.values(RaidenEpics)).pipe(mergeMap((epic) => epic(limitedAction$, limitedState$, deps)), catchError((err) => of(raidenShutdown({ reason: err }))), takeUntil(shutdownNotification));\n};\n//# sourceMappingURL=epics.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport './polyfills';\nimport { Web3Provider, JsonRpcProvider } from 'ethers/providers';\nimport { bigNumberify } from 'ethers/utils';\nimport { Zero, AddressZero, MaxUint256 } from 'ethers/constants';\nimport { applyMiddleware, createStore } from 'redux';\nimport { createEpicMiddleware } from 'redux-observable';\nimport { createLogger } from 'redux-logger';\nimport constant from 'lodash/constant';\nimport memoize from 'lodash/memoize';\nimport { AsyncSubject, merge, defer, EMPTY, ReplaySubject, of } from 'rxjs';\nimport { first, filter, map, mergeMap, skip } from 'rxjs/operators';\nimport logging from 'loglevel';\nimport { TokenNetworkRegistryFactory } from './contracts/TokenNetworkRegistryFactory';\nimport { TokenNetworkFactory } from './contracts/TokenNetworkFactory';\nimport { HumanStandardTokenFactory } from './contracts/HumanStandardTokenFactory';\nimport { ServiceRegistryFactory } from './contracts/ServiceRegistryFactory';\nimport { CustomTokenFactory } from './contracts/CustomTokenFactory';\nimport { UserDepositFactory } from './contracts/UserDepositFactory';\nimport { SecretRegistryFactory } from './contracts/SecretRegistryFactory';\nimport versions from './versions.json';\nimport { EventTypes } from './types';\nimport { ShutdownReason } from './constants';\nimport { getState } from './state';\nimport { PartialRaidenConfig } from './config';\nimport { ChannelState } from './channels/state';\nimport { Direction } from './transfers/state';\nimport { raidenReducer } from './reducer';\nimport { raidenRootEpic } from './epics';\nimport { RaidenEvents, raidenShutdown, raidenConfigUpdate, } from './actions';\nimport { channelOpen, channelDeposit, channelClose, channelSettle, tokenMonitored, } from './channels/actions';\nimport { matrixPresence } from './transport/actions';\nimport { transfer, transferSigned } from './transfers/actions';\nimport { makeSecret, getSecrethash, makePaymentId, raidenSentTransfer } from './transfers/utils';\nimport { pathFind } from './services/actions';\nimport { Paths, PFS } from './services/types';\nimport { pfsListInfo } from './services/utils';\nimport { Address, Secret, Hash, UInt, decode, assert } from './utils/types';\nimport { isActionOf, asyncActionToPromise, isResponseOf } from './utils/actions';\nimport { patchSignSend } from './utils/ethers';\nimport { pluckDistinct } from './utils/rx';\nimport { getContracts, getSigner, initTransfers$, mapTokenToPartner, chooseOnchainAccount, getContractWithSigner, waitConfirmation, callAndWaitMined, } from './helpers';\nimport { RaidenError, ErrorCodes } from './utils/error';\nexport class Raiden {\n    constructor(provider, network, signer, contractsInfo, state, defaultConfig, main) {\n        var _a, _b, _c, _d;\n        this.resolveName = provider.resolveName.bind(provider);\n        const address = state.address;\n        this.log = logging.getLogger(`raiden:${address}`);\n        // use next from latest known blockNumber as start block when polling\n        provider.resetEventsBlock(state.blockNumber + 1);\n        const latest$ = new ReplaySubject(1);\n        // pipe cached state\n        this.state$ = latest$.pipe(pluckDistinct('state'));\n        // pipe action, skipping cached\n        this.action$ = latest$.pipe(pluckDistinct('action'), skip(1));\n        this.channels$ = this.state$.pipe(map((state) => mapTokenToPartner(state)));\n        this.transfers$ = initTransfers$(this.state$);\n        this.events$ = this.action$.pipe(filter(isActionOf(RaidenEvents)));\n        this.getTokenInfo = memoize(function (token) {\n            return __awaiter(this, void 0, void 0, function* () {\n                assert(Address.is(token), 'Invalid address');\n                const tokenContract = this.deps.getTokenContract(token);\n                const [totalSupply, decimals, name, symbol] = yield Promise.all([\n                    tokenContract.functions.totalSupply(),\n                    tokenContract.functions.decimals(),\n                    tokenContract.functions.name().catch(constant(undefined)),\n                    tokenContract.functions.symbol().catch(constant(undefined)),\n                ]);\n                // workaround for https://github.com/microsoft/TypeScript/issues/33752\n                assert(totalSupply && decimals != null, 'Not a token contract');\n                return { totalSupply, decimals, name, symbol };\n            });\n        });\n        this.deps = {\n            latest$,\n            config$: latest$.pipe(pluckDistinct('config')),\n            matrix$: new AsyncSubject(),\n            provider,\n            network,\n            signer,\n            address,\n            log: this.log,\n            defaultConfig,\n            contractsInfo,\n            registryContract: TokenNetworkRegistryFactory.connect(contractsInfo.TokenNetworkRegistry.address, (_a = main === null || main === void 0 ? void 0 : main.signer) !== null && _a !== void 0 ? _a : signer),\n            getTokenNetworkContract: memoize((address) => { var _a; return TokenNetworkFactory.connect(address, (_a = main === null || main === void 0 ? void 0 : main.signer) !== null && _a !== void 0 ? _a : signer); }),\n            getTokenContract: memoize((address) => { var _a; return HumanStandardTokenFactory.connect(address, (_a = main === null || main === void 0 ? void 0 : main.signer) !== null && _a !== void 0 ? _a : signer); }),\n            serviceRegistryContract: ServiceRegistryFactory.connect(contractsInfo.ServiceRegistry.address, (_b = main === null || main === void 0 ? void 0 : main.signer) !== null && _b !== void 0 ? _b : signer),\n            userDepositContract: UserDepositFactory.connect(contractsInfo.UserDeposit.address, (_c = main === null || main === void 0 ? void 0 : main.signer) !== null && _c !== void 0 ? _c : signer),\n            secretRegistryContract: SecretRegistryFactory.connect(contractsInfo.SecretRegistry.address, (_d = main === null || main === void 0 ? void 0 : main.signer) !== null && _d !== void 0 ? _d : signer),\n            main,\n        };\n        this.userDepositTokenAddress = memoize(() => __awaiter(this, void 0, void 0, function* () { return (yield this.deps.userDepositContract.functions.token()); }));\n        const loggerMiddleware = createLogger({\n            predicate: () => this.log.getLevel() <= logging.levels.INFO,\n            logger: this.log,\n            level: {\n                prevState: 'debug',\n                action: 'info',\n                error: 'error',\n                nextState: 'debug',\n            },\n        });\n        this.config = Object.assign(Object.assign({}, defaultConfig), state.config);\n        this.deps.config$.subscribe((config) => (this.config = config));\n        this.deps.config$\n            .pipe(pluckDistinct('logger'))\n            .subscribe((logger) => this.log.setLevel(logger || 'silent', false));\n        // minimum blockNumber of contracts deployment as start scan block\n        this.epicMiddleware = createEpicMiddleware({ dependencies: this.deps });\n        this.store = createStore(raidenReducer, \n        // workaround for redux's PreloadedState issues with branded values\n        state, // eslint-disable-line @typescript-eslint/no-explicit-any\n        applyMiddleware(loggerMiddleware, this.epicMiddleware));\n    }\n    /**\n     * Async helper factory to make a Raiden instance from more common parameters.\n     *\n     * An async factory is needed so we can do the needed async requests to construct the required\n     * parameters ahead of construction time, and avoid partial initialization then\n     *\n     * @param this - Raiden class or subclass\n     * @param connection - A URL or provider to connect to, one of:\n     *     <ul>\n     *       <li>JsonRpcProvider instance,</li>\n     *       <li>a Metamask's web3.currentProvider object or,</li>\n     *       <li>a hostname or remote json-rpc connection string</li>\n     *     </ul>\n     * @param account - An account to use as main account, one of:\n     *     <ul>\n     *       <li>Signer instance (e.g. Wallet) loadded with account/private key or</li>\n     *       <li>hex-encoded string address of a remote account in provider or</li>\n     *       <li>hex-encoded string local private key or</li>\n     *       <li>number index of a remote account loaded in provider\n     *            (e.g. 0 for Metamask's loaded account)</li>\n     *     </ul>\n     * @param storageOrState - Storage/localStorage-like object from where to load and store current\n     *     state, initial RaidenState-like object, or a { storage; state? } object containing both.\n     *     If a storage isn't provided, user must listen state$ changes on ensure it's persisted.\n     * @param contracts - Contracts deployment info\n     * @param config - Raiden configuration\n     * @param subkey - Whether to use a derived subkey or not\n     * @returns Promise to Raiden SDK client instance\n     */\n    static create(connection, account, storageOrState, contracts, config, subkey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let provider;\n            if (typeof connection === 'string') {\n                provider = new JsonRpcProvider(connection);\n            }\n            else if (connection instanceof JsonRpcProvider) {\n                provider = connection;\n            }\n            else {\n                provider = new Web3Provider(connection);\n            }\n            // Patch provider's sign method (https://github.com/raiden-network/light-client/issues/223)\n            patchSignSend(provider);\n            const network = yield provider.getNetwork();\n            // if no ContractsInfo, try to populate from defaults\n            if (!contracts) {\n                contracts = getContracts(network);\n            }\n            const { signer, address, main } = yield getSigner(account, provider, subkey);\n            // Build initial state or parse from storage\n            const { state, onState, onStateComplete, defaultConfig } = yield getState(network, contracts, address, storageOrState, config && decode(PartialRaidenConfig, config));\n            assert(address === state.address, `Mismatch between provided account and loaded state: \"${address}\" !== \"${state.address}\"`);\n            assert(network.chainId === state.chainId &&\n                contracts.TokenNetworkRegistry.address === state.registry, `Mismatch between network or registry address and loaded state`);\n            const raiden = new this(provider, network, signer, contracts, state, defaultConfig, main);\n            if (onState)\n                raiden.state$.subscribe(onState, onStateComplete, onStateComplete);\n            return raiden;\n        });\n    }\n    /**\n     * Starts redux/observables by subscribing to all epics and emitting initial state and action\n     *\n     * No event should be emitted before start is called\n     */\n    start() {\n        assert(this.epicMiddleware, 'Already started or stopped!');\n        // on complete, sets epicMiddleware to null, so this.started === false\n        this.deps.latest$.subscribe(undefined, undefined, () => (this.epicMiddleware = null));\n        this.epicMiddleware.run(raidenRootEpic);\n        // prevent start from being called again, turns this.started to true\n        this.epicMiddleware = undefined;\n        // dispatch a first, noop action, to next first state$ as current/initial state\n        this.store.dispatch(raidenConfigUpdate({}));\n    }\n    /**\n     * Gets the running state of the instance\n     *\n     * @returns undefined if not yet started, true if running, false if already stopped\n     */\n    get started() {\n        // !epicMiddleware -> undefined | null -> undefined ? true/started : null/stopped;\n        if (!this.epicMiddleware)\n            return this.epicMiddleware === undefined;\n        // else -> !!epicMiddleware -> not yet started -> returns undefined\n    }\n    /**\n     * Triggers all epics to be unsubscribed\n     */\n    stop() {\n        // start still can't be called again, but turns this.started to false\n        // this.epicMiddleware is set to null by latest$'s complete callback\n        this.store.dispatch(raidenShutdown({ reason: ShutdownReason.STOP }));\n    }\n    /**\n     * Get current RaidenState object. Can be serialized safely with [[encodeRaidenState]]\n     *\n     * @returns Current Raiden state\n     */\n    get state() {\n        return this.store.getState();\n    }\n    /**\n     * Get current account address (subkey's address, if subkey is being used)\n     *\n     * @returns Instance address\n     */\n    get address() {\n        return this.deps.address;\n    }\n    /**\n     * Get main account address (if subkey is being used, undefined otherwise)\n     *\n     * @returns Main account address\n     */\n    get mainAddress() {\n        var _a;\n        return (_a = this.deps.main) === null || _a === void 0 ? void 0 : _a.address;\n    }\n    /**\n     * Get current network from provider\n     *\n     * @returns Network object containing blockchain's name & chainId\n     */\n    get network() {\n        return this.deps.network;\n    }\n    /**\n     * Returns a promise to current block number, as seen in provider and state\n     *\n     * @returns Promise to current block number\n     */\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.deps.provider.blockNumber || (yield this.deps.provider.getBlockNumber());\n        });\n    }\n    /**\n     * Returns the currently used SDK version.\n     *\n     * @returns SDK version\n     */\n    static get version() {\n        return versions.sdk;\n    }\n    /**\n     * Returns the version of the used Smart Contracts.\n     *\n     * @returns Smart Contract version\n     */\n    static get contractVersion() {\n        return versions.contracts;\n    }\n    /**\n     * Update Raiden Config with a partial (shallow) object\n     *\n     * @param config - Partial object containing keys and values to update in config\n     */\n    updateConfig(config) {\n        this.store.dispatch(raidenConfigUpdate(decode(PartialRaidenConfig, config)));\n    }\n    /**\n     * Get ETH balance for given address or self\n     *\n     * @param address - Optional target address. If omitted, gets own balance\n     * @returns BigNumber of ETH balance\n     */\n    getBalance(address) {\n        address = address !== null && address !== void 0 ? address : chooseOnchainAccount(this.deps, this.config.subkey).address;\n        assert(Address.is(address), 'Invalid address');\n        return this.deps.provider.getBalance(address);\n    }\n    /**\n     * Get token balance and token decimals for given address or self\n     *\n     * @param token - Token address to fetch balance. Must be one of the monitored tokens.\n     * @param address - Optional target address. If omitted, gets own balance\n     * @returns BigNumber containing address's token balance\n     */\n    getTokenBalance(token, address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = address !== null && address !== void 0 ? address : chooseOnchainAccount(this.deps, this.config.subkey).address;\n            assert(Address.is(address) && Address.is(token), 'Invalid address');\n            const tokenContract = this.deps.getTokenContract(token);\n            return tokenContract.functions.balanceOf(address);\n        });\n    }\n    /**\n     * Returns a list of all token addresses registered as token networks in registry\n     *\n     * @returns Promise to list of token addresses\n     */\n    getTokenList() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.deps.provider\n                .getLogs(Object.assign(Object.assign({}, this.deps.registryContract.filters.TokenNetworkCreated(null, null)), { fromBlock: this.deps.contractsInfo.TokenNetworkRegistry.block_number, toBlock: 'latest' }))\n                .then((logs) => logs\n                .map((log) => this.deps.registryContract.interface.parseLog(log))\n                .filter((parsed) => { var _a; return !!((_a = parsed.values) === null || _a === void 0 ? void 0 : _a.token_address); })\n                .map((parsed) => parsed.values.token_address));\n        });\n    }\n    /**\n     * Scans initially and start monitoring a token for channels with us, returning its Tokennetwork\n     * address\n     *\n     * Throws an exception if token isn't registered in current registry\n     *\n     * @param token - token address to monitor, must be registered in current token network registry\n     * @returns Address of TokenNetwork contract\n     */\n    monitorToken(token) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token), 'Invalid address');\n            const alreadyMonitoredTokens = this.state.tokens;\n            if (token in alreadyMonitoredTokens)\n                return alreadyMonitoredTokens[token];\n            const tokenNetwork = (yield this.deps.registryContract.token_to_token_networks(token));\n            assert(tokenNetwork && tokenNetwork !== AddressZero, 'Unknown token network');\n            this.store.dispatch(tokenMonitored({\n                token,\n                tokenNetwork,\n                fromBlock: this.deps.contractsInfo.TokenNetworkRegistry.block_number,\n            }));\n            return tokenNetwork;\n        });\n    }\n    /**\n     * Open a channel on the tokenNetwork for given token address with partner\n     *\n     * If token isn't yet monitored, starts monitoring it\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param partner - Partner address\n     * @param options - (optional) option parameter\n     * @param options.settleTimeout - Custom, one-time settle timeout\n     * @param options.subkey - Whether to use the subkey for on-chain tx or main account (default)\n     * @param onChange - Optional callback for status change notification\n     * @returns txHash of channelOpen call, iff it succeeded\n     */\n    openChannel(token, partner, options = {}, onChange) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token) && Address.is(partner), 'Invalid address');\n            const tokenNetwork = yield this.monitorToken(token);\n            assert(!options.subkey || this.deps.main, \"Can't send tx from subkey if not set\");\n            const deposit = options.deposit === undefined ? undefined : decode(UInt(32), options.deposit);\n            const meta = { tokenNetwork, partner };\n            // wait for confirmation\n            const openPromise = asyncActionToPromise(channelOpen, meta, this.action$, false).then(({ txHash }) => txHash);\n            this.store.dispatch(channelOpen.request(Object.assign(Object.assign({}, options), { deposit }), meta));\n            const openTxHash = yield openPromise;\n            onChange === null || onChange === void 0 ? void 0 : onChange({ type: EventTypes.OPENED, payload: { txHash: openTxHash } });\n            yield this.state$\n                .pipe(pluckDistinct('channels', tokenNetwork, partner, 'state'), first((state) => state === ChannelState.open))\n                .toPromise();\n            onChange === null || onChange === void 0 ? void 0 : onChange({ type: EventTypes.CONFIRMED, payload: { txHash: openTxHash } });\n            if (deposit) {\n                const depositTx = yield asyncActionToPromise(channelDeposit, meta, this.action$, true).then(({ txHash }) => txHash);\n                onChange === null || onChange === void 0 ? void 0 : onChange({ type: EventTypes.DEPOSITED, payload: { txHash: depositTx } });\n            }\n            return openTxHash;\n        });\n    }\n    /**\n     * Deposit tokens on channel between us and partner on tokenNetwork for token\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param partner - Partner address\n     * @param amount - Number of tokens to deposit on channel\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    (and is also the account used as source of the deposit tokens).\n     *    Set this to true if one wants to force sending the transaction with the subkey, and using\n     *    tokens held in the subkey.\n     * @returns txHash of setTotalDeposit call, iff it succeeded\n     */\n    depositChannel(token, partner, amount, { subkey } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token) && Address.is(partner), 'Invalid address');\n            const state = this.state;\n            const tokenNetwork = state.tokens[token];\n            assert(tokenNetwork, 'Unknown token network');\n            assert(!subkey || this.deps.main, \"Can't send tx from subkey if not set\");\n            const deposit = decode(UInt(32), amount);\n            const meta = { tokenNetwork, partner };\n            const promise = asyncActionToPromise(channelDeposit, meta, this.action$, true).then(({ txHash }) => txHash);\n            this.store.dispatch(channelDeposit.request({ deposit, subkey }, meta));\n            return promise;\n        });\n    }\n    /**\n     * Close channel between us and partner on tokenNetwork for token\n     * This method will fail if called on a channel not in 'opened' or 'closing' state.\n     * When calling this method on an 'opened' channel, its state becomes 'closing', and from there\n     * on, no payments can be performed on the channel. If for any reason the closeChannel\n     * transaction fails, channel's state stays as 'closing', and this method can be called again\n     * to retry sending 'closeChannel' transaction. After it's successful, channel becomes 'closed',\n     * and can be settled after 'settleTimeout' blocks (when it then becomes 'settleable').\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param partner - Partner address\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns txHash of closeChannel call, iff it succeeded\n     */\n    closeChannel(token, partner, { subkey } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token) && Address.is(partner), 'Invalid address');\n            const state = this.state;\n            const tokenNetwork = state.tokens[token];\n            assert(tokenNetwork, 'Unknown token network');\n            assert(!subkey || this.deps.main, \"Can't send tx from subkey if not set\");\n            const meta = { tokenNetwork, partner };\n            const promise = asyncActionToPromise(channelClose, meta, this.action$, true).then(({ txHash }) => txHash);\n            this.store.dispatch(channelClose.request(subkey ? { subkey } : undefined, meta));\n            return promise;\n        });\n    }\n    /**\n     * Settle channel between us and partner on tokenNetwork for token\n     * This method will fail if called on a channel not in 'settleable' or 'settling' state.\n     * Channel becomes 'settleable' settleTimeout blocks after closed (detected automatically\n     * while Raiden Light Client is running or later on restart). When calling it, channel state\n     * becomes 'settling'. If for any reason transaction fails, it'll stay on this state, and this\n     * method can be called again to re-send a settleChannel transaction.\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param partner - Partner address\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns txHash of settleChannel call, iff it succeeded\n     */\n    settleChannel(token, partner, { subkey } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token) && Address.is(partner), 'Invalid address');\n            const state = this.state;\n            const tokenNetwork = state.tokens[token];\n            assert(tokenNetwork, 'Unknown token network');\n            assert(!subkey || this.deps.main, \"Can't send tx from subkey if not set\");\n            // wait for the corresponding success or error action\n            const meta = { tokenNetwork, partner };\n            const promise = asyncActionToPromise(channelSettle, meta, this.action$, true).then(({ txHash }) => txHash);\n            this.store.dispatch(channelSettle.request(subkey ? { subkey } : undefined, meta));\n            return promise;\n        });\n    }\n    /**\n     * Returns object describing address's users availability on transport\n     * After calling this method, any further presence update to valid transport peers of this\n     * address will trigger a corresponding MatrixPresenceUpdateAction on events$\n     *\n     * @param address - checksummed address to be monitored\n     * @returns Promise to object describing availability and last event timestamp\n     */\n    getAvailability(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(address), 'Invalid address');\n            const meta = { address };\n            const promise = asyncActionToPromise(matrixPresence, meta, this.action$);\n            this.store.dispatch(matrixPresence.request(undefined, meta));\n            return promise;\n        });\n    }\n    /**\n     * Send a Locked Transfer!\n     * This will reject if LockedTransfer signature prompt is canceled/signature fails, or be\n     * resolved to the transfer unique identifier (secrethash) otherwise, and transfer status can be\n     * queried with this id on this.transfers$ observable, which will just have emitted the 'pending'\n     * transfer. Any following transfer state change will be notified through this observable.\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param target - Target address (must be getAvailability before)\n     * @param value - Amount to try to transfer\n     * @param options - Optional parameters for transfer:\n     *    <ul>\n     *      <li>paymentId - payment identifier, a random one will be generated if missing</li>\n     *      <li>secret - Secret to register, a random one will be generated if missing</li>\n     *      <li>secrethash - Must match secret, if both provided, or else, secret must be\n     *          informed to target by other means, and reveal can't be performed</li>\n     *      <li>paths - Used to specify possible routes & fees instead of querying PFS.</li>\n     *      <li>pfs - Use this PFS instead of configured or automatically choosen ones.\n     *          Is ignored if paths were already provided. If neither are set and config.pfs is not\n     *          disabled (null), use it if set or if undefined (auto mode), fetches the best\n     *          PFS from ServiceRegistry and automatically fetch routes from it.</li>\n     *    </ul>\n     * @returns A promise to transfer's secrethash (unique id) when it's accepted\n     */\n    transfer(token, target, value, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token) && Address.is(target), 'Invalid address');\n            const tokenNetwork = this.state.tokens[token];\n            assert(tokenNetwork, 'Unknown token network');\n            const decodedValue = decode(UInt(32), value);\n            const paymentId = options.paymentId ? decode(UInt(8), options.paymentId) : makePaymentId();\n            const paths = options.paths ? decode(Paths, options.paths) : undefined;\n            const pfs = options.pfs ? decode(PFS, options.pfs) : undefined;\n            assert(options.secret === undefined || Secret.is(options.secret), 'Invalid options.secret');\n            assert(options.secrethash === undefined || Hash.is(options.secrethash), 'Invalid options.secrethash');\n            // use provided secret or create one if no secrethash was provided\n            const secret = options.secret\n                ? options.secret\n                : !options.secrethash\n                    ? makeSecret()\n                    : undefined;\n            const secrethash = options.secrethash || getSecrethash(secret);\n            assert(!secret || getSecrethash(secret) === secrethash, 'Provided secrethash must match the sha256 hash of provided secret');\n            const pathFindMeta = { tokenNetwork, target, value: decodedValue };\n            return merge(\n            // wait for pathFind response\n            this.action$.pipe(first(isResponseOf(pathFind, pathFindMeta)), map((action) => {\n                if (pathFind.failure.is(action))\n                    throw action.payload;\n                return action.payload.paths;\n            })), \n            // request pathFind; even if paths were provided, send it again for validation\n            // this is done at 'merge' subscription time (i.e. when above action filter is subscribed)\n            defer(() => {\n                this.store.dispatch(pathFind.request({ paths, pfs }, pathFindMeta));\n                return EMPTY;\n            }))\n                .pipe(mergeMap((paths) => merge(\n            // wait for transfer response\n            this.action$.pipe(filter(isActionOf([transferSigned, transfer.failure])), first((action) => action.meta.secrethash === secrethash), map((action) => {\n                if (transfer.failure.is(action))\n                    throw action.payload;\n                return secrethash;\n            })), \n            // request transfer with returned/validated paths at 'merge' subscription time\n            defer(() => {\n                this.store.dispatch(transfer.request({\n                    tokenNetwork,\n                    target,\n                    value: decodedValue,\n                    paths,\n                    paymentId,\n                    secret,\n                }, { secrethash, direction: Direction.SENT }));\n                return EMPTY;\n            }))))\n                .toPromise();\n        });\n    }\n    /**\n     * Waits for the transfer identified by a secrethash to fail or complete\n     *\n     * The returned promise will resolve with the final amount received by the target\n     *\n     * @param secrethash - Transfer identifier\n     * @returns Amount received by target, as informed by them on SecretRequest\n     */\n    waitTransfer(secrethash) {\n        var _a, _b, _c, _d;\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Hash.is(secrethash), 'Invalid secrethash for transfer');\n            let state = this.state;\n            assert(secrethash in state.sent, 'Unknown secrethash');\n            const sent = raidenSentTransfer(state.sent[secrethash]);\n            // already completed/past transfer\n            if (sent.completed) {\n                if (sent.success)\n                    return (_b = (_a = this.state.sent[secrethash].secretRequest) === null || _a === void 0 ? void 0 : _a[1]) === null || _b === void 0 ? void 0 : _b.amount;\n                else\n                    throw new RaidenError(ErrorCodes.XFER_ALREADY_COMPLETED, { status: sent.status });\n            }\n            // throws/rejects if a failure occurs\n            yield asyncActionToPromise(transfer, { secrethash, direction: Direction.SENT }, this.action$);\n            state = this.state;\n            return (_d = (_c = state.sent[secrethash].secretRequest) === null || _c === void 0 ? void 0 : _c[1]) === null || _d === void 0 ? void 0 : _d.amount;\n        });\n    }\n    /**\n     * Request a path from PFS\n     *\n     * If a direct route is possible, it'll be returned. Else if PFS is set up, a request will be\n     * performed and the cleaned/validated path results will be resolved.\n     * Else, if no route can be found, promise is rejected with respective error.\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param target - Target address (must be getAvailability before)\n     * @param value - Minimum capacity required on routes\n     * @param options - Optional parameters\n     * @param options.pfs - Use this PFS instead of configured or automatically choosen ones\n     * @returns A promise to returned routes/paths result\n     */\n    findRoutes(token, target, value, options = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token) && Address.is(target), 'Invalid address');\n            const tokenNetwork = this.state.tokens[token];\n            assert(tokenNetwork, 'Unknown token network');\n            const decodedValue = decode(UInt(32), value);\n            const pfs = options.pfs ? decode(PFS, options.pfs) : undefined;\n            const meta = { tokenNetwork, target, value: decodedValue };\n            const promise = asyncActionToPromise(pathFind, meta, this.action$).then(({ paths }) => paths);\n            this.store.dispatch(pathFind.request({ pfs }, meta));\n            return promise;\n        });\n    }\n    /**\n     * Checks if a direct transfer of token to target could be performed and returns it on a\n     * single-element array of Paths\n     *\n     * @param token - Token address on currently configured token network registry\n     * @param target - Target address (must be getAvailability before)\n     * @param value - Minimum capacity required on route\n     * @returns Promise to a [Raiden]Paths array containing the single, direct route, or undefined\n     */\n    directRoute(token, target, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token) && Address.is(target), 'Invalid address');\n            const tokenNetwork = this.state.tokens[token];\n            assert(tokenNetwork, 'Unknown token network');\n            const decodedValue = decode(UInt(32), value);\n            const meta = { tokenNetwork, target, value: decodedValue };\n            const promise = asyncActionToPromise(pathFind, meta, this.action$).then(({ paths }) => paths, // pluck paths\n            () => undefined);\n            // dispatch a pathFind with pfs disabled, to force checking for a direct route\n            this.store.dispatch(pathFind.request({ pfs: null }, meta));\n            return promise;\n        });\n    }\n    /**\n     * Returns a sorted array of info of available PFS\n     *\n     * It uses data polled from ServiceRegistry, which is available only when config.pfs is\n     * undefined, instead of set or disabled (null), and will reject if not.\n     * It can reject if the validated list is empty, meaning we can be out-of-sync (we're outdated or\n     * they are) with PFSs deployment, or no PFS is available on this TokenNetwork/blockchain.\n     *\n     * @returns Promise to array of PFS, which is the interface which describes a PFS\n     */\n    findPFS() {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(this.config.pfs !== null, 'PFS disabled in config');\n            return (this.config.pfs\n                ? of([this.config.pfs])\n                : this.deps.latest$.pipe(pluckDistinct('pfsList'), first((v) => v.length > 0)))\n                .pipe(mergeMap((pfsList) => pfsListInfo(pfsList, this.deps)))\n                .toPromise();\n        });\n    }\n    /**\n     * Mints the amount of tokens of the provided token address.\n     * Throws an error, if\n     * <ol>\n     *  <li>Executed on main net</li>\n     *  <li>`token` is not a valid address</li>\n     *  <li>Token could not be minted</li>\n     * </ol>\n     *\n     * @param token - Address of the token to be minted\n     * @param amount - Amount to be minted\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Notice the beneficiary here is always the account that sends the transaction, as this is\n     *    expectedly also the account that will pay for e.g. future deposits.\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns transaction\n     */\n    mint(token, amount, { subkey } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Check whether address is valid\n            assert(Address.is(token), 'Invalid address');\n            assert(!subkey || this.deps.main, \"Can't send tx from subkey if not set\");\n            // Check whether we are on a test network\n            assert(this.deps.network.name !== 'homestead', 'Minting is only allowed on test networks.');\n            const { signer } = chooseOnchainAccount(this.deps, subkey !== null && subkey !== void 0 ? subkey : this.config.subkey);\n            // Mint token\n            const customTokenContract = CustomTokenFactory.connect(token, signer);\n            const receipt = yield callAndWaitMined(customTokenContract, 'mint', [decode(UInt(32), amount)], ErrorCodes.RDN_MINT_FAILED, { log: this.log });\n            // wait for a single block, so future calls will correctly pick value\n            yield waitConfirmation(receipt, this.deps, 1);\n            return receipt.transactionHash;\n        });\n    }\n    /**\n     * Fetches balance of UserDeposit Contract for SDK's account minus cached spent IOUs\n     *\n     * @returns Promise to UDC remaining capacity\n     */\n    getUDCCapacity() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const balance = yield this.deps.userDepositContract.functions.balances(this.deps.address);\n            const blockNumber = this.state.blockNumber;\n            const owedAmount = Object.values(this.state.path.iou)\n                .reduce((acc, value) => {\n                const nonExpiredIOUs = Object.values(value).filter((value) => value.expiration_block.gte(blockNumber));\n                acc.push(...nonExpiredIOUs);\n                return acc;\n            }, new Array())\n                .reduce((acc, iou) => acc.add(iou.amount), Zero);\n            return balance.sub(owedAmount);\n        });\n    }\n    /**\n     * Deposits the amount to the UserDeposit contract with the target/signer as a beneficiary.\n     * The deposited amount can be used as a collateral in order to sign valid IOUs that will\n     * be accepted by the Services.\n     *\n     * Throws an error, in the following cases:\n     * <ol>\n     *  <li>The amount specified equals to zero</li>\n     *  <li>The target has an insufficient token balance</li>\n     *  <li>The \"approve\" transaction fails with an error</li>\n     *  <li>The \"deposit\" transaction fails with an error</li>\n     * </ol>\n     *\n     * @param amount - The amount to deposit on behalf of the target/beneficiary.\n     * @param onChange - callback providing notifications about state changes\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns transaction hash\n     */\n    depositToUDC(amount, onChange, { subkey } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(!subkey || this.deps.main, \"Can't send tx from subkey if not set\", this.log.debug);\n            const depositAmount = bigNumberify(amount);\n            assert(depositAmount.gt(Zero), 'Please deposit a positive amount.', this.log.debug);\n            const { signer, address } = chooseOnchainAccount(this.deps, subkey !== null && subkey !== void 0 ? subkey : this.config.subkey);\n            const userDepositContract = getContractWithSigner(this.deps.userDepositContract, signer);\n            const serviceTokenContract = getContractWithSigner(this.deps.getTokenContract(yield this.userDepositTokenAddress()), signer);\n            const balance = yield serviceTokenContract.functions.balanceOf(address);\n            assert(balance.gte(amount), `Insufficient token balance (${balance}).`, this.log.debug);\n            const approveReceipt = yield callAndWaitMined(serviceTokenContract, 'approve', [userDepositContract.address, depositAmount], ErrorCodes.RDN_APPROVE_TRANSACTION_FAILED, { log: this.log });\n            onChange === null || onChange === void 0 ? void 0 : onChange({\n                type: EventTypes.APPROVED,\n                payload: {\n                    txHash: approveReceipt.transactionHash,\n                },\n            });\n            const currentUDCBalance = yield userDepositContract.functions.balances(this.address);\n            const depositReceipt = yield callAndWaitMined(userDepositContract, 'deposit', [this.address, currentUDCBalance.add(depositAmount)], ErrorCodes.RDN_DEPOSIT_TRANSACTION_FAILED, { log: this.log });\n            onChange === null || onChange === void 0 ? void 0 : onChange({\n                type: EventTypes.DEPOSITED,\n                payload: {\n                    txHash: depositReceipt.transactionHash,\n                },\n            });\n            yield waitConfirmation(depositReceipt, this.deps);\n            this.log.debug(`deposit tx \"${depositReceipt.transactionHash}\" confirmed`);\n            onChange === null || onChange === void 0 ? void 0 : onChange({\n                type: EventTypes.CONFIRMED,\n                payload: {\n                    txHash: depositReceipt.transactionHash,\n                },\n            });\n            return depositReceipt.transactionHash;\n        });\n    }\n    /**\n     * Transfer value ETH on-chain to address.\n     * If subkey is being used, use main account by default, or subkey account if 'subkey' is true\n     * Example:\n     *   // transfer 0.1 ETH from main account to subkey account, when subkey is used\n     *   await raiden.transferOnchainBalance(raiden.address, parseEther('0.1'));\n     *   // transfer entire balance from subkey account back to main account\n     *   await raiden.transferOnchainBalance(raiden.mainAddress, undefined, { subkey: true });\n     *\n     * @param to - Recipient address\n     * @param value - Amount of ETH (in Wei) to transfer. Use ethers/utils::parseEther if needed\n     *    Defaults to a very big number, which will cause all entire balance to be transfered\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @param options.gasPrice - Set to force a specific gasPrice; used to calculate transferable\n     *    amount when transfering entire balance. If left unset, uses average network gasPrice\n     * @returns transaction hash\n     */\n    transferOnchainBalance(to, value = MaxUint256, { subkey, gasPrice } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(to), 'Invalid address', this.log.debug);\n            assert(!subkey || this.deps.main, \"Can't send tx from subkey if not set\", this.log.debug);\n            const { signer, address } = chooseOnchainAccount(this.deps, subkey !== null && subkey !== void 0 ? subkey : this.config.subkey);\n            const price = gasPrice ? bigNumberify(gasPrice) : yield this.deps.provider.getGasPrice();\n            const gasLimit = bigNumberify(21000);\n            const curBalance = yield this.getBalance(address);\n            // transferableBalance is current balance minus the cost of a single transfer as per gasPrice\n            const transferableBalance = curBalance.sub(price.mul(gasLimit));\n            assert(transferableBalance.gt(Zero), 'Not enough balance for a transfer', this.log.error);\n            // caps value to transferableBalance, so if it's too big, transfer all\n            const amount = transferableBalance.lte(value) ? transferableBalance : bigNumberify(value);\n            const tx = yield signer.sendTransaction({ to, value: amount, gasPrice: price, gasLimit });\n            const receipt = yield tx.wait();\n            if (!receipt.status)\n                throw new RaidenError(ErrorCodes.RDN_TRANSFER_ONCHAIN_BALANCE_FAILED);\n            return tx.hash;\n        });\n    }\n    /**\n     * Transfer value tokens on-chain to address.\n     * If subkey is being used, use main account by default, or subkey account if 'subkey' is true\n     *\n     * @param token - Token address\n     * @param to - Recipient address\n     * @param value - Amount of tokens (in Wei) to transfer. Use ethers/utils::parseUnits if needed\n     *    Defaults to a very big number, which will cause all entire balance to be transfered\n     * @param options - tx options\n     * @param options.subkey - By default, if using subkey, main account is used to send transactions\n     *    Set this to true if one wants to force sending the transaction with the subkey\n     * @returns transaction hash\n     */\n    transferOnchainTokens(token, to, value = MaxUint256, { subkey } = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(Address.is(token) && Address.is(to), 'Invalid address', this.log.debug);\n            assert(!subkey || this.deps.main, \"Can't send tx from subkey if not set\", this.log.debug);\n            const { signer, address } = chooseOnchainAccount(this.deps, subkey !== null && subkey !== void 0 ? subkey : this.config.subkey);\n            const tokenContract = getContractWithSigner(this.deps.getTokenContract(token), signer);\n            const curBalance = yield this.getTokenBalance(token, address);\n            // caps value to balance, so if it's too big, transfer all\n            const amount = curBalance.lte(value) ? curBalance : bigNumberify(value);\n            const receipt = yield callAndWaitMined(tokenContract, 'transfer', [to, amount], ErrorCodes.RDN_TRANSFER_ONCHAIN_TOKENS_FAILED, { log: this.log });\n            return receipt.transactionHash;\n        });\n    }\n}\nexport default Raiden;\n//# sourceMappingURL=raiden.js.map"],"sourceRoot":""}