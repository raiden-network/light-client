import {
  Observable,
  combineLatest,
  from,
  of,
  EMPTY,
  fromEvent,
  timer,
  ReplaySubject,
  throwError,
} from 'rxjs';
import {
  catchError,
  concatMap,
  delay,
  distinctUntilChanged,
  filter,
  groupBy,
  ignoreElements,
  map,
  mergeMap,
  multicast,
  withLatestFrom,
  scan,
  startWith,
  switchMap,
  take,
  takeUntil,
  tap,
  toArray,
  mapTo,
  finalize,
} from 'rxjs/operators';
import { isActionOf, ActionType } from 'typesafe-actions';
import { find, get, minBy, sortBy } from 'lodash';

import { getAddress, verifyMessage } from 'ethers/utils';
import { createClient, MatrixClient, MatrixEvent, User, Room, RoomMember } from 'matrix-js-sdk';
import fetch from 'cross-fetch';

import { Address } from '../utils/types';
import { RaidenEpicDeps } from '../types';
import { RaidenAction } from '../actions';
import { MATRIX_KNOWN_SERVERS_URL } from '../constants';
import { channelMonitored } from '../channels/actions';
import {
  Message,
  MessageType,
  Delivered,
  Processed,
  SecretRequest,
  SecretReveal,
  Signed,
} from '../messages/types';
import {
  decodeJsonMessage,
  encodeJsonMessage,
  getMessageSigner,
  signMessage,
} from '../messages/utils';
import { messageSend, messageReceived, messageSent } from '../messages/actions';
import { RaidenState } from '../store/state';
import { raidenInit } from '../store/actions';
import { getServerName, getUserPresence, matrixRTT, yamlListToArray } from '../utils/matrix';
import { LruCache } from '../utils/lru';
import {
  matrixPresenceUpdate,
  matrixRequestMonitorPresenceFailed,
  matrixRoom,
  matrixRoomLeave,
  matrixSetup,
  matrixRequestMonitorPresence,
} from './actions';
import { RaidenMatrixSetup } from './state';
import { Presences } from './types';
import { getPresences$ } from './utils';

// unavailable just means the user didn't do anything over a certain amount of time, but they're
// still there, so we consider the user as available then
const AVAILABLE = ['online', 'unavailable'];
const userRe = /^@(0x[0-9a-f]{40})[.:]/i;

/**
 * Initialize matrix transport
 * The matrix client instance will be outputed to RaidenEpicDeps.matrix$ AsyncSubject
 * The setup info (including credentials, for persistence) will be the matrixSetup output action
 *
 * @param action$  Observable of raidenInit actions
 * @param state$  Observable of RaidenStates
 * @param address,network,signer,matrix$  RaidenEpicDeps members
 * @returns  Observable of matrixSetup generated by initializing matrix client
 */
export const initMatrixEpic = (
  action$: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
  { address, network, signer, matrix$ }: RaidenEpicDeps,
): Observable<ActionType<typeof matrixSetup>> =>
  action$.pipe(
    filter(isActionOf(raidenInit)),
    withLatestFrom(state$),
    mergeMap(function([, state]) {
      const server: string | undefined = get(state, ['transport', 'matrix', 'server']),
        setup: RaidenMatrixSetup | undefined = get(state, ['transport', 'matrix', 'setup']);
      if (server) {
        // use server from state/settings
        return of({ server, setup });
      } else {
        const knownServersUrl =
          MATRIX_KNOWN_SERVERS_URL[network.name] || MATRIX_KNOWN_SERVERS_URL.default;
        // fetch servers list and use the one with shortest http round trip time (rtt)
        return from(fetch(knownServersUrl)).pipe(
          mergeMap(response => {
            if (!response.ok)
              return throwError(
                new Error(
                  `Could not fetch server list from "${knownServersUrl}" => ${response.status}`,
                ),
              );
            return response.text();
          }),
          mergeMap(text => from(yamlListToArray(text))),
          mergeMap(server => matrixRTT(server)),
          toArray(),
          map(rtts => sortBy(rtts, ['rtt'])),
          map(rtts => {
            if (!rtts[0] || typeof rtts[0].rtt !== 'number' || isNaN(rtts[0].rtt))
              throw new Error(`Could not contact any matrix servers: ${JSON.stringify(rtts)}`);
            return rtts[0].server;
          }),
          map(server => ({
            server: server.includes('://') ? server : `https://${server}`,
            setup: undefined,
          })),
        );
      }
    }),
    mergeMap(function({
      server,
      setup,
    }): Observable<{ matrix: MatrixClient; server: string; setup: RaidenMatrixSetup }> {
      let { userId, accessToken, deviceId }: Partial<RaidenMatrixSetup> = setup || {};
      if (setup) {
        // if matrixSetup was already issued before, and credentials are already in state
        const matrix = createClient({
          baseUrl: server,
          userId,
          accessToken,
          deviceId,
        });
        return of({ matrix, server, setup });
      } else {
        const serverName = getServerName(server);
        if (!serverName) return throwError(new Error(`Could not get serverName from "${server}"`));
        const matrix = createClient({ baseUrl: server });
        const userName = address.toLowerCase();
        userId = `@${userName}:${serverName}`;

        // create password as signature of serverName, then try login or register
        return from(signer.signMessage(serverName)).pipe(
          mergeMap(password =>
            from(matrix.loginWithPassword(userName, password)).pipe(
              catchError(() => from(matrix.register(userName, password))),
            ),
          ),
          tap(result => {
            // matrix.register implementation doesn't set returned credentials
            // which would require an unnecessary additional login request if we didn't
            // set it here, and login doesn't set deviceId, so we set all credential
            // parameters again here after successful login or register
            matrix.deviceId = result.device_id;
            matrix._http.opts.accessToken = result.access_token;
            matrix.credentials = {
              userId: result.user_id,
            };
            // set vars for later MatrixSetupAction
            accessToken = result.access_token;
            deviceId = result.device_id;
          }),
          // displayName must be signature of full userId for our messages to be accepted
          mergeMap(() => signer.signMessage(userId!)),
          map(signedUserId => ({
            matrix,
            server,
            setup: {
              userId: userId!,
              accessToken: accessToken!,
              deviceId: deviceId!,
              displayName: signedUserId,
            },
          })),
        );
      }
    }),
    mergeMap(({ matrix, server, setup }) =>
      // ensure displayName is set even on restarts
      from(matrix.setDisplayName(setup.displayName)).pipe(
        // ensure we joined discovery room
        mergeMap(() =>
          matrix.joinRoom(
            `#raiden_${network.name || network.chainId}_discovery:${getServerName(server)}`,
          ),
        ),
        mapTo({ matrix, server, setup }),
      ),
    ),
    tap(({ matrix }) => {
      // like Promise.resolve for AsyncSubjects
      matrix$.next(matrix);
      matrix$.complete();
    }),
    map(({ server, setup }) => matrixSetup({ server, setup })),
  );

/**
 * Start MatrixClient sync polling when detecting MatrixSetupAction, **after** init time fromEvents
 * were already registered.
 * This is required to ensure init-time events registering are done before initial sync, to avoid
 * losing one-shot events, like invitations.
 *
 * @param action$  Observable of matrixSetup actions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Empty observable (whole side-effect on matrix instance)
 */
export const matrixStartEpic = (
  action$: Observable<RaidenAction>,
  {  }: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<RaidenAction> =>
  action$.pipe(
    filter(isActionOf(matrixSetup)),
    switchMap(() => matrix$),
    tap(matrix => console.log('MATRIX client', matrix)),
    mergeMap(matrix => matrix.startClient({ initialSyncLimit: 0 })),
    ignoreElements(),
  );

/**
 * Calls matrix.stopClient when raiden is shutting down, i.e. action$ completes
 *
 * @param action$  Observable of matrixSetup actions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Empty observable (whole side-effect on matrix instance)
 */
export const matrixShutdownEpic = (
  action$: Observable<RaidenAction>,
  {  }: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<RaidenAction> =>
  matrix$.pipe(
    mergeMap(matrix => action$.pipe(finalize(() => matrix.stopClient()))),
    ignoreElements(), // dont re-emit action$, but keep it subscribed so finalize works
  );

/**
 * Handles MatrixRequestMonitorPresenceAction and emits a MatrixPresenceUpdateAction
 * If presence is already known, emits it, else fetch from user profile
 * Even if the presence stays the same, we emit a MatrixPresenceUpdateAction, as this may be a
 * request being waited by a promise or something like that
 * IOW: every request should be followed by a presence update or a failed action, but presence
 * updates may happen later without new requests (e.g. when the user goes offline)
 *
 * @param action$  Observable of matrixRequestMonitorPresence actions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Observable of presence updates or fail action
 */
export const matrixMonitorPresenceEpic = (
  action$: Observable<RaidenAction>,
  {  }: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<
  ActionType<typeof matrixPresenceUpdate | typeof matrixRequestMonitorPresenceFailed>
> =>
  action$.pipe(
    filter(isActionOf(matrixRequestMonitorPresence)),
    // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value
    mergeMap(action => matrix$.pipe(map(matrix => ({ action, matrix })))),
    withLatestFrom(getPresences$(action$)),
    // TODO: groupBy(address)+concatMap serialize presence fetching
    mergeMap(([{ action, matrix }, presences]) => {
      if (action.meta.address in presences)
        // we already monitored/saw this user's presence
        return of(presences[action.meta.address]);

      const validUsers: User[] = [];
      for (const user of matrix.getUsers()) {
        if (!user.displayName) continue;
        if (!user.presence) continue;
        let recovered: Address | undefined;
        try {
          const match = userRe.exec(user.userId);
          if (!match || getAddress(match[1]) !== action.meta.address) continue;
          recovered = verifyMessage(user.userId, user.displayName) as Address | undefined;
          if (!recovered || recovered !== action.meta.address) continue;
        } catch (err) {
          continue;
        }
        validUsers.push(user);
      }
      // IFF we see a cached/stored user (matrix.getUsers), with displayName and presence already
      // populated, which displayName signature verifies to our address of interest,
      // then construct and return the MatrixPresenceUpdateAction from the stored data
      if (validUsers.length > 0) {
        const user = minBy(validUsers, 'lastPresenceTs')!;
        return of(
          matrixPresenceUpdate(
            { userId: user.userId, available: AVAILABLE.includes(user.presence!) },
            action.meta,
          ),
        );
      }

      // if anything failed up to here, go the slow path: searchUserDirectory + getUserPresence
      return from(
        // search user directory for any user containing the address of interest in its userId
        matrix.searchUserDirectory({ term: action.meta.address.toLowerCase() }),
      ).pipe(
        // for every result matches, verify displayName signature is address of interest
        map(({ results }) => {
          const validUsers: string[] = [];
          for (const user of results) {
            if (!user.display_name) continue;
            try {
              const match = userRe.exec(user.user_id);
              if (!match || getAddress(match[1]) !== action.meta.address) continue;
              const recovered = verifyMessage(user.user_id, user.display_name);
              if (!recovered || recovered !== action.meta.address) continue;
            } catch (err) {
              continue;
            }
            validUsers.push(user.user_id);
          }
          if (validUsers.length === 0)
            // if no valid user could be found, throw an error to be handled below
            throw new Error(
              `Could not find any user with valid signature for ${
                action.meta.address
              } in ${JSON.stringify(results)}`,
            );
          else return validUsers;
        }),
        mergeMap(userIds => from(userIds)),
        mergeMap(userId =>
          getUserPresence(matrix, userId).then(presence =>
            // eslint-disable-next-line @typescript-eslint/camelcase
            Object.assign(presence, { user_id: userId }),
          ),
        ),
        toArray(),
        // for all matched/verified users, get its presence through dedicated API
        // it's required because, as the user events could already have been handled and
        // filtered out by matrixPresenceUpdateEpic because it wasn't yet a user-of-interest,
        // we could have missed presence updates, then we need to fetch it here directly,
        // and from now on, that other epic will monitor its updates, and sort by most recently
        // seen user
        map(presences => minBy(presences, 'last_active_ago')!),
        map(({ presence, user_id: userId }) =>
          matrixPresenceUpdate(
            {
              userId,
              available: AVAILABLE.includes(presence),
            },
            action.meta,
          ),
        ),
        catchError(err => of(matrixRequestMonitorPresenceFailed(err, action.meta))),
      );
    }),
  );

/**
 * Monitor peers matrix presence from User.presence events
 * We aggregate all users of interest (i.e. for which a monitor request was emitted at some point)
 * and emit presence updates for any presence change happening to a user validating to this address
 *
 * @param action$  Observable of RaidenActions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Observable of presence updates
 */
export const matrixPresenceUpdateEpic = (
  action$: Observable<RaidenAction>,
  {  }: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<ActionType<typeof matrixPresenceUpdate>> =>
  matrix$.pipe(
    // when matrix finishes initialization, register to matrix presence events
    switchMap(matrix =>
      // matrix's 'User.presence' sometimes fail to fire, but generic 'event' is always fired,
      // and User (retrieved via matrix.getUser) is up-to-date before 'event' emits
      fromEvent<MatrixEvent>(matrix, 'event').pipe(map(event => ({ event, matrix }))),
    ),
    filter(({ event }) => event.getType() === 'm.presence'),
    // parse peer address from userId
    map(({ event, matrix }) => {
      // as 'event' is emitted after user is (created and) updated, getUser always returns it
      const user = matrix.getUser(event.getSender())!,
        match = userRe.exec(user.userId),
        peerAddress = match && match[1];
      // getAddress will convert any valid address into checksummed-format
      return {
        user,
        matrix,
        peerAddress: (peerAddress && getAddress(peerAddress)) as Address | undefined,
      };
    }),
    // filter out events without userId in the right format (startWith hex-address)
    filter(({ user, peerAddress }) => !!(user.presence && peerAddress)),
    withLatestFrom(
      // observable of all addresses whose presence monitoring was requested since init
      action$.pipe(
        filter(isActionOf(matrixRequestMonitorPresence)),
        scan((toMonitor, request) => toMonitor.add(request.meta.address), new Set<Address>()),
        startWith(new Set<Address>()),
      ),
      // known presences as { address: <last seen MatrixPresenceUpdateAction> } mapping
      getPresences$(action$),
    ),
    // filter out events from users we don't care about
    // i.e.: presence monitoring never requested
    filter(([{ peerAddress }, toMonitor]) => toMonitor.has(peerAddress!)),
    mergeMap(([{ user, matrix, peerAddress }, , presences]) => {
      // first filter can't tell typescript this property will always be set!
      const userId = user.userId,
        address = peerAddress!,
        presence = user.presence!,
        available = AVAILABLE.includes(presence);

      if (
        address in presences &&
        presences[address].payload.userId === userId &&
        presences[address].payload.available === available
      )
        // even if signature verification passes, this wouldn't change presence, so return early
        return EMPTY;

      // fetch profile info if user doesn't contain a displayName
      const displayName$: Observable<string | undefined> = user.displayName
        ? of(user.displayName)
        : from(matrix.getProfileInfo(userId, 'displayname')).pipe(
            map(profile => profile.displayname),
            catchError(() => of(undefined)),
          );

      return displayName$.pipe(
        map(displayName => {
          // errors raised here will be logged and ignored on catchError below
          if (!displayName) throw new Error(`Could not get displayName of "${userId}"`);
          // ecrecover address, validating displayName is the signature of the userId
          const recovered = verifyMessage(userId, displayName) as Address | undefined;
          if (!recovered || recovered !== peerAddress)
            throw new Error(
              `Could not verify displayName signature of "${userId}": got "${recovered}"`,
            );
          return recovered;
        }),
        map(address =>
          matrixPresenceUpdate({ userId, available, ts: user.lastPresenceTs }, { address }),
        ),
      );
    }),
    catchError(err => (console.log('Error validating presence event, ignoring', err), EMPTY)),
  );

/**
 * Upon receiving a MessageSendAction, ensure there's a room for the given address
 * Requires address to have its presence monitored.
 *
 * @param action$  Observable of messageSend actions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Observable of matrixRoom actions
 */
export const matrixCreateRoomEpic = (
  action$: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<ActionType<typeof matrixRoom>> =>
  combineLatest(getPresences$(action$), state$).pipe(
    // multicasting combined presences+state with a ReplaySubject makes it act as withLatestFrom
    // but working inside concatMap, which is called only at outer next and subscribe delayed
    multicast(new ReplaySubject<[Presences, RaidenState]>(1), presencesStateReplay$ =>
      // actual output observable, handles MessageSendAction serially and create room if needed
      action$.pipe(
        filter(isActionOf(messageSend)),
        // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value
        mergeMap(action => matrix$.pipe(map(matrix => ({ action, matrix })))),
        // concatMap is used to prevent bursts of messages for a given address (eg. on startup)
        // of creating multiple rooms for same address
        concatMap(({ action, matrix }) =>
          // presencesStateReplay$+take(1) acts like withLatestFrom with cached result
          presencesStateReplay$.pipe(
            // wait for user to be monitored
            filter(([presences]) => action.meta.address in presences),
            take(1),
            // if there's already a room state for address and it's present in matrix, skip
            filter(
              ([, state]) => !get(state, ['transport', 'matrix', 'rooms', action.meta.address, 0]),
            ),
            // else, create a room, invite known user and dispatch the respective MatrixRoomAction
            // to store it in state
            mergeMap(([presences]) =>
              matrix.createRoom({
                visibility: 'private',
                invite: [presences[action.meta.address].payload.userId],
              }),
            ),
            map(({ room_id: roomId }) => matrixRoom({ roomId }, action.meta)),
          ),
        ),
      ),
    ),
  );

/**
 * Invites users coming online to rooms we may have with them
 *
 * @param action$  Observable of matrixPresenceUpdate actions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Empty observable (whole side-effect on matrix instance)
 */
export const matrixInviteEpic = (
  action$: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<RaidenAction> =>
  action$.pipe(
    filter(isActionOf(matrixPresenceUpdate)),
    filter(action => action.payload.available),
    // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value
    mergeMap(action => matrix$.pipe(map(matrix => ({ action, matrix })))),
    withLatestFrom(state$),
    mergeMap(([{ action, matrix }, state]) => {
      const roomId: string | undefined = get(state, [
        'transport',
        'matrix',
        'rooms',
        action.meta.address,
        0,
      ]);
      if (roomId) {
        const room = matrix.getRoom(roomId);
        if (room) {
          const member = room.getMember(action.payload.userId);
          if (!member) return from(matrix.invite(roomId, action.payload.userId));
        }
      }
      return EMPTY;
    }),
    ignoreElements(),
  );

/**
 * Handle invites sent to us and accepts them iff sent by a monitored user
 *
 * @param action$  Observable of RaidenActions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Observable of matrixRoom actions
 */
export const matrixHandleInvitesEpic = (
  action$: Observable<RaidenAction>,
  {  }: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<ActionType<typeof matrixRoom>> =>
  matrix$.pipe(
    // when matrix finishes initialization, register to matrix invite events
    switchMap(matrix =>
      fromEvent<{ event: MatrixEvent; member: RoomMember; matrix: MatrixClient }>(
        matrix,
        'RoomMember.membership',
        (event, member) => ({ event, member, matrix }),
      ),
    ),
    filter(
      // filter for invite events to us
      ({ member, matrix }) =>
        member.userId === matrix.getUserId() && member.membership === 'invite',
    ),
    withLatestFrom(getPresences$(action$)),
    mergeMap(([{ event, member, matrix }, presences]) => {
      const sender = event.getSender(),
        cachedPresence = find(presences, p => p.payload.userId === sender),
        senderPresence$ = cachedPresence
          ? of(cachedPresence)
          : action$.pipe(
              // as these membership events can come up quite early, we delay continue processing
              // them a while, to see if the sender is of interest to us (presence monitored)
              filter(isActionOf(matrixPresenceUpdate)),
              filter(a => a.payload.userId === sender),
              take(1),
              // Don't wait more than some arbitrary time for this sender presence update to show
              // up; completes without emitting anything otherwise, ending this pipeline.
              // This also works as a filter to continue processing invites only for monitored
              // users, as it'll complete without emitting if no MatrixPresenceUpdateAction is
              // found for sender in time
              takeUntil(timer(30e3)),
            );
      return senderPresence$.pipe(map(senderPresence => ({ matrix, member, senderPresence })));
    }),
    mergeMap(({ matrix, member, senderPresence }) =>
      // join room and emit MatrixRoomAction to make it default/first option for sender address
      from(matrix.joinRoom(member.roomId, { syncRoom: true })).pipe(
        map(() => matrixRoom({ roomId: member.roomId }, { address: senderPresence.meta.address })),
      ),
    ),
  );

/**
 * Leave any excess room for a partner when creating or joining a new one.
 * Excess rooms are the ones behind a given threshold (currently 3) in the address's rooms queue
 *
 * @param action$  Observable of matrixRoom actions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Observable of matrixRoomLeave actions
 */
export const matrixLeaveExcessRoomsEpic = (
  action$: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<ActionType<typeof matrixRoomLeave>> =>
  action$.pipe(
    // act whenever a new room is added to the address queue in state
    filter(isActionOf(matrixRoom)),
    // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value
    mergeMap(action => matrix$.pipe(map(matrix => ({ action, matrix })))),
    withLatestFrom(state$),
    mergeMap(([{ action, matrix }, state]) => {
      const THRESHOLD = 3;
      const rooms = state.transport!.matrix!.rooms![action.meta.address];
      return from(rooms.filter(({}, i) => i >= THRESHOLD)).pipe(
        mergeMap(roomId => matrix.leave(roomId).then(() => roomId)),
        map(roomId => matrixRoomLeave({ roomId }, action.meta)),
      );
    }),
  );

/**
 * Leave any room which is neither discovery/global nor known to state as a room for a user of
 * interest
 *
 * @param action$  Observable of RaidenActions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Empty observable (whole side-effect on matrix instance)
 */
export const matrixLeaveUnknownRoomsEpic = (
  {  }: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
  { matrix$, network }: RaidenEpicDeps,
): Observable<RaidenAction> =>
  matrix$.pipe(
    // when matrix finishes initialization, register to matrix Room events
    switchMap(matrix =>
      fromEvent<Room>(matrix, 'Room').pipe(map(room => ({ matrix, roomId: room.roomId }))),
    ),
    delay(30e3), // this room may become known later for some reason, so wait a little
    withLatestFrom(state$),
    // filter for leave events to us
    filter(([{ matrix, roomId }, state]) => {
      const room = matrix.getRoom(roomId);
      if (!room) return false; // room already gone while waiting
      if (room.name && room.name.match(`#raiden_${network.name || network.chainId}_discovery:`))
        return false;
      const rooms: { [address: string]: string[] } = get(
        state,
        ['transport', 'matrix', 'rooms'],
        {},
      );
      for (const address in rooms) {
        for (const roomId of rooms[address]) {
          if (roomId === room.roomId) return false;
        }
      }
      return true;
    }),
    mergeMap(([{ matrix, roomId }]) => matrix.leave(roomId)),
    ignoreElements(),
  );

/**
 * If we leave a room for any reason (eg. a kick event), purge it from state
 * Notice excess rooms left by matrixLeaveExcessRoomsEpic are cleaned before the matrix event is
 * detected, and then no MatrixRoomLeaveAction is emitted for them by this epic.
 *
 * @param action$  Observable of RaidenActions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Observable of matrixRoomLeave actions
 */
export const matrixCleanLeftRoomsEpic = (
  {  }: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<ActionType<typeof matrixRoomLeave>> =>
  matrix$.pipe(
    // when matrix finishes initialization, register to matrix invite events
    switchMap(matrix =>
      fromEvent<{ room: Room; membership: string; matrix: MatrixClient }>(
        matrix,
        'Room.myMembership',
        (room, membership) => ({ room, membership, matrix }),
      ),
    ),
    // filter for leave events to us
    filter(({ membership }) => membership === 'leave'),
    withLatestFrom(state$),
    mergeMap(function*([{ room }, state]) {
      const rooms: { [address: string]: string[] } = get(
        state,
        ['transport', 'matrix', 'rooms'],
        {},
      );
      for (const address in rooms) {
        for (const roomId of rooms[address]) {
          if (roomId === room.roomId) {
            yield matrixRoomLeave({ roomId }, { address: address as Address });
          }
        }
      }
    }),
  );

/**
 * Handles a MessageSendAction and send its message to the first room on queue for address
 *
 * @param action$  Observable of messageSend actions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Empty observable (whole side-effect on matrix instance)
 */
export const matrixMessageSendEpic = (
  action$: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<RaidenAction> =>
  combineLatest(getPresences$(action$), state$).pipe(
    // multicasting combined presences+state with a ReplaySubject makes it act as withLatestFrom
    // but working inside concatMap, called only at outer emit and subscription delayed
    multicast(new ReplaySubject<[Presences, RaidenState]>(1), presencesStateReplay$ =>
      // actual output observable, gets/wait for the user to be in a room, and then sendMessage
      action$.pipe(
        filter(isActionOf(messageSend)),
        // this mergeMap is like withLatestFrom, but waits until matrix$ emits its only value
        mergeMap(action => matrix$.pipe(map(matrix => ({ action, matrix })))),
        groupBy(({ action }) => action.meta.address),
        // merge all inner/grouped observables, so different user's "queues" can be parallel
        mergeMap(grouped$ =>
          // per-user "queue"
          grouped$.pipe(
            // each per-user "queue" (observable) are processed serially (because concatMap)
            // TODO: batch all pending messages in a single send message request, with retry
            concatMap(({ action, matrix }) =>
              presencesStateReplay$.pipe(
                // wait for address to be monitored, online and roomId to be in state.
                // ReplaySubject ensures it happens immediatelly if all conditions are satisfied
                filter(
                  ([presences, state]) =>
                    action.meta.address in presences &&
                    presences[action.meta.address].payload.available &&
                    get(state, ['transport', 'matrix', 'rooms', action.meta.address, 0]),
                ),
                map(([, state]) => state.transport!.matrix!.rooms![action.meta.address][0]),
                distinctUntilChanged(),
                // get/wait room object for roomId
                switchMap(roomId => {
                  const room = matrix.getRoom(roomId);
                  // wait for the room state to be populated (happens after createRoom resolves)
                  return room
                    ? of(room)
                    : fromEvent<Room>(matrix, 'Room').pipe(
                        filter(room => room.roomId === roomId),
                        take(1),
                      );
                }),
                // get up-to-date/last presences at this point in time, which may have been updated
                withLatestFrom(presencesStateReplay$),
                // get room member for partner userId
                mergeMap(([room, [presences]]) => {
                  // get latest known userId for address at this point in time
                  const userId = presences[action.meta.address].payload.userId;
                  const member = room.getMember(userId);
                  // if it's already present in room, return its membership
                  if (member && member.membership === 'join') return of(member);
                  // else, wait for the user to join our newly created room
                  return fromEvent<RoomMember>(
                    matrix,
                    'RoomMember.membership',
                    ({  }: MatrixEvent, member: RoomMember) => member,
                  ).pipe(
                    // use up-to-date presences again, which may have been updated while
                    // waiting for member join event (e.g. user roamed and was re-invited)
                    withLatestFrom(presencesStateReplay$),
                    filter(
                      ([member, [presences]]) =>
                        member.roomId === room.roomId &&
                        member.userId === presences[action.meta.address].payload.userId &&
                        member.membership === 'join',
                    ),
                    take(1),
                    map(([member]) => member),
                  );
                }),
                take(1), // use first room/user which meets all requirements/filters so far
                // send message!
                mergeMap(member => {
                  const body: string =
                    typeof action.payload.message === 'string'
                      ? action.payload.message
                      : encodeJsonMessage(action.payload.message);
                  return matrix.sendEvent(
                    member.roomId,
                    'm.room.message',
                    { body, msgtype: 'm.text' },
                    '',
                  );
                }),
                map(() => messageSent(action.payload, action.meta)),
              ),
            ),
          ),
        ),
      ),
    ),
  );

/**
 * Subscribe to matrix messages and emits MessageReceivedAction upon receiving a valid message from
 * an user of interest (one valid signature from an address we monitor) in a room we have for them
 *
 * @param action$  Observable of RaidenActions
 * @param state$  Observable of RaidenStates
 * @param matrix$  RaidenEpicDeps members
 * @returns  Observable of messageReceived actions
 */
export const matrixMessageReceivedEpic = (
  action$: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
  { matrix$ }: RaidenEpicDeps,
): Observable<ActionType<typeof messageReceived>> =>
  combineLatest(getPresences$(action$), state$).pipe(
    // multicasting combined presences+state with a ReplaySubject makes it act as withLatestFrom
    // but working inside concatMap, called only at outer emit and subscription delayed
    multicast(new ReplaySubject<[Presences, RaidenState]>(1), presencesStateReplay$ =>
      // actual output observable, gets/wait for the user to be in a room, and then sendMessage
      matrix$.pipe(
        // when matrix finishes initialization, register to matrix timeline events
        switchMap(matrix =>
          fromEvent<{ event: MatrixEvent; room: Room; matrix: MatrixClient }>(
            matrix,
            'Room.timeline',
            (event, room) => ({ matrix, event, room }),
          ),
        ),
        // filter for text messages from other users
        filter(
          ({ event, matrix }) =>
            event.getType() === 'm.room.message' &&
            event.getSender() !== matrix.getUserId() &&
            event.event.content.msgtype === 'm.text',
        ),
        mergeMap(({ event, room }) =>
          presencesStateReplay$.pipe(
            filter(([presences, state]) => {
              const presence = find(presences, ['payload.userId', event.getSender()]);
              if (!presence) return false;
              const rooms: string[] = get(
                state,
                ['transport', 'matrix', 'rooms', presence.meta.address],
                [],
              );
              if (!rooms.includes(room.roomId)) return false;
              return true;
            }),
            take(1),
            // take up to an arbitrary timeout to presence status for the sender
            // AND the room in which this message was sent to be in sender's address room queue
            takeUntil(timer(30e3)),
            mergeMap(function*([presences]) {
              const presence = find(presences, ['payload.userId', event.getSender()])!;
              for (const line of (event.event.content.body || '').split('\n')) {
                let message: Signed<Message> | undefined;
                try {
                  message = decodeJsonMessage(line);
                  const signer = getMessageSigner(message);
                  if (signer !== presence.meta.address)
                    throw new Error(
                      `Signature mismatch: sender=${presence.meta.address} != signer=${signer}`,
                    );
                } catch (err) {
                  console.warn(`Could not decode message: ${line}: ${err}`);
                  message = undefined;
                }
                yield messageReceived(
                  {
                    text: line,
                    message,
                    ts: event.event.origin_server_ts,
                    userId: presence.payload.userId,
                    roomId: room.roomId,
                  },
                  presence.meta,
                );
              }
            }),
          ),
        ),
      ),
    ),
  );

/**
 * If matrix received a message from user in a room we have with them, but not the first on queue,
 * update queue so this room goes to the front and will be used as send message room from now on
 *
 * @param action$  Observable of messageReceived actions
 * @param state$  Observable of RaidenStates
 * @returns  Observable of matrixRoom actions
 */
export const matrixMessageReceivedUpdateRoomEpic = (
  action$: Observable<RaidenAction>,
  state$: Observable<RaidenState>,
): Observable<ActionType<typeof matrixRoom>> =>
  action$.pipe(
    filter(isActionOf(messageReceived)),
    withLatestFrom(state$),
    filter(([action, state]) => {
      const rooms: string[] = get(
        state,
        ['transport', 'matrix', 'rooms', action.meta.address],
        [],
      );
      return (
        !!action.payload.roomId &&
        rooms.includes(action.payload.roomId) &&
        rooms[0] !== action.payload.roomId
      );
    }),
    map(([action]) => matrixRoom({ roomId: action.payload.roomId! }, action.meta)),
  );

/**
 * Channel monitoring triggers matrix presence monitoring for partner
 *
 * @param action$  Observable of RaidenActions
 * @returns  Observable of matrixRequestMonitorPresence actions
 */
export const matrixMonitorChannelPresenceEpic = (
  action$: Observable<RaidenAction>,
): Observable<ActionType<typeof matrixRequestMonitorPresence>> =>
  action$.pipe(
    filter(isActionOf(channelMonitored)),
    map(action => matrixRequestMonitorPresence(undefined, { address: action.meta.partner })),
  );

/**
 * Sends Delivered for specific messages
 *
 * @param action$  Observable of RaidenActions
 * @param state$  Observable of RaidenStates
 * @param signer  RaidenEpicDeps members
 * @returns  Observable of messageSend actions
 */
export const deliveredEpic = (
  action$: Observable<RaidenAction>,
  {  }: Observable<RaidenState>,
  { signer }: RaidenEpicDeps,
): Observable<ActionType<typeof messageSend>> => {
  const cache = new LruCache<string, Signed<Delivered>>(32);
  return action$.pipe(
    filter(isActionOf(messageReceived)),
    concatMap(action => {
      const message = action.payload.message;
      if (
        !message ||
        !(
          Signed(Processed).is(message) ||
          Signed(SecretRequest).is(message) ||
          Signed(SecretReveal).is(message)
        )
      )
        return EMPTY;
      const msgId = message.message_identifier,
        key = msgId.toString();
      const cached = cache.get(key);
      if (cached) return of(messageSend({ message: cached }, action.meta));

      const delivered: Delivered = {
        type: MessageType.DELIVERED,
        delivered_message_identifier: msgId, // eslint-disable-line @typescript-eslint/camelcase
      };
      return from(signMessage(signer, delivered)).pipe(
        tap(signed => cache.put(key, signed)),
        map(signed => messageSend({ message: signed }, action.meta)),
      );
    }),
  );
};
